\hypertarget{ostream_8h_source}{}\doxysection{ostream.\+h}
\label{ostream_8h_source}\index{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/ostream.h@{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/ostream.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ std::ostream support}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_OSTREAM\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_OSTREAM\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <fstream>}  \textcolor{comment}{// std::filebuf}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#if defined(\_WIN32) \&\& defined(\_\_GLIBCXX\_\_)}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#  include <ext/stdio\_filebuf.h>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#  include <ext/stdio\_sync\_filebuf.h>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#elif defined(\_WIN32) \&\& defined(\_LIBCPP\_VERSION)}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#  include <\_\_std\_stream>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{comment}{// Generate a unique explicit instantion in every translation unit using a tag}}
\DoxyCodeLine{27 \textcolor{comment}{// type in an anonymous namespace.}}
\DoxyCodeLine{28 \textcolor{keyword}{namespace }\{}
\DoxyCodeLine{29 \textcolor{keyword}{struct }file\_access\_tag \{\};}
\DoxyCodeLine{30 \}  \textcolor{comment}{// namespace}}
\DoxyCodeLine{31 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Tag, \textcolor{keyword}{typename} BufType, FILE* BufType::*FileMemberPtr>}
\DoxyCodeLine{32 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1file__access}{file\_access}} \{}
\DoxyCodeLine{33   \textcolor{keyword}{friend} \textcolor{keyword}{auto} get\_file(BufType\& obj) -\/> FILE* \{ \textcolor{keywordflow}{return} obj.*FileMemberPtr; \}}
\DoxyCodeLine{34 \};}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION}}
\DoxyCodeLine{37 \textcolor{keyword}{template} \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1file__access}{file\_access}}<file\_access\_tag, std::filebuf,}
\DoxyCodeLine{38                            \&std::filebuf::\_Myfile>;}
\DoxyCodeLine{39 \textcolor{keyword}{auto} get\_file(std::filebuf\&) -\/> FILE*;}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#elif defined(\_WIN32) \&\& defined(\_LIBCPP\_VERSION)}}
\DoxyCodeLine{41 \textcolor{keyword}{template} \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1file__access}{file\_access<file\_access\_tag, std::\_\_stdoutbuf<char>}},}
\DoxyCodeLine{42                            \&std::\_\_stdoutbuf<char>::\_\_file\_>;}
\DoxyCodeLine{43 \textcolor{keyword}{auto} get\_file(std::\_\_stdoutbuf<char>\&) -\/> FILE*;}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} write\_ostream\_unicode(std::ostream\& os, fmt::string\_view \mbox{\hyperlink{structdetail_1_1data}{data}}) \{}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION}}
\DoxyCodeLine{48   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* buf = \textcolor{keyword}{dynamic\_cast<}std::filebuf*\textcolor{keyword}{>}(os.rdbuf()))}
\DoxyCodeLine{49     \textcolor{keywordflow}{if} (FILE* f = get\_file(*buf)) \textcolor{keywordflow}{return} write\_console(f, \mbox{\hyperlink{structdetail_1_1data}{data}});}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#elif defined(\_WIN32) \&\& defined(\_\_GLIBCXX\_\_)}}
\DoxyCodeLine{51   \textcolor{keyword}{auto}* rdbuf = os.rdbuf();}
\DoxyCodeLine{52   FILE* c\_file;}
\DoxyCodeLine{53   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* sfbuf = \textcolor{keyword}{dynamic\_cast<}\_\_gnu\_cxx::stdio\_sync\_filebuf<char>*\textcolor{keyword}{>}(rdbuf))}
\DoxyCodeLine{54     c\_file = sfbuf-\/>file();}
\DoxyCodeLine{55   \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* fbuf = \textcolor{keyword}{dynamic\_cast<}\_\_gnu\_cxx::stdio\_filebuf<char>*\textcolor{keyword}{>}(rdbuf))}
\DoxyCodeLine{56     c\_file = fbuf-\/>file();}
\DoxyCodeLine{57   \textcolor{keywordflow}{else}}
\DoxyCodeLine{58     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{59   \textcolor{keywordflow}{if} (c\_file) \textcolor{keywordflow}{return} write\_console(c\_file, \mbox{\hyperlink{structdetail_1_1data}{data}});}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#elif defined(\_WIN32) \&\& defined(\_LIBCPP\_VERSION)}}
\DoxyCodeLine{61   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto}* buf = \textcolor{keyword}{dynamic\_cast<}std::\_\_stdoutbuf<char>*\textcolor{keyword}{>}(os.rdbuf()))}
\DoxyCodeLine{62     \textcolor{keywordflow}{if} (FILE* f = get\_file(*buf)) \textcolor{keywordflow}{return} write\_console(f, \mbox{\hyperlink{structdetail_1_1data}{data}});}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{64   ignore\_unused(os, \mbox{\hyperlink{structdetail_1_1data}{data}});}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{66   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{67 \}}
\DoxyCodeLine{68 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} write\_ostream\_unicode(std::wostream\&,}
\DoxyCodeLine{69                                   fmt::basic\_string\_view<wchar\_t>) \{}
\DoxyCodeLine{70   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{71 \}}
\DoxyCodeLine{72 }
\DoxyCodeLine{73 \textcolor{comment}{// Write the content of buf to os.}}
\DoxyCodeLine{74 \textcolor{comment}{// It is a separate function rather than a part of vprint to simplify testing.}}
\DoxyCodeLine{75 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{76 \textcolor{keywordtype}{void} write\_buffer(std::basic\_ostream<Char>\& os, buffer<Char>\& buf) \{}
\DoxyCodeLine{77   \textcolor{keyword}{const} Char* buf\_data = buf.data();}
\DoxyCodeLine{78   \textcolor{keyword}{using }unsigned\_streamsize = std::make\_unsigned<std::streamsize>::type;}
\DoxyCodeLine{79   unsigned\_streamsize size = buf.size();}
\DoxyCodeLine{80   unsigned\_streamsize max\_size = to\_unsigned(max\_value<std::streamsize>());}
\DoxyCodeLine{81   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{82     unsigned\_streamsize n = size <= max\_size ? size : max\_size;}
\DoxyCodeLine{83     os.write(buf\_data, \textcolor{keyword}{static\_cast<}std::streamsize\textcolor{keyword}{>}(n));}
\DoxyCodeLine{84     buf\_data += n;}
\DoxyCodeLine{85     size -\/= n;}
\DoxyCodeLine{86   \} \textcolor{keywordflow}{while} (size != 0);}
\DoxyCodeLine{87 \}}
\DoxyCodeLine{88 }
\DoxyCodeLine{89 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{90 \textcolor{keywordtype}{void} format\_value(buffer<Char>\& buf, \textcolor{keyword}{const} T\& value,}
\DoxyCodeLine{91                   locale\_ref loc = locale\_ref()) \{}
\DoxyCodeLine{92   \textcolor{keyword}{auto}\&\& format\_buf = formatbuf<std::basic\_streambuf<Char>>(buf);}
\DoxyCodeLine{93   \textcolor{keyword}{auto}\&\& output = std::basic\_ostream<Char>(\&format\_buf);}
\DoxyCodeLine{94 \textcolor{preprocessor}{\#if !defined(FMT\_STATIC\_THOUSANDS\_SEPARATOR)}}
\DoxyCodeLine{95   \textcolor{keywordflow}{if} (loc) output.imbue(loc.get<std::locale>());}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{97   output << value;}
\DoxyCodeLine{98   output.exceptions(std::ios\_base::failbit | std::ios\_base::badbit);}
\DoxyCodeLine{99 \}}
\DoxyCodeLine{100 }
\DoxyCodeLine{101 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1streamed__view}{streamed\_view}} \{ \textcolor{keyword}{const} T\& \mbox{\hyperlink{classdetail_1_1value}{value}}; \};}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{comment}{// Formats an object of type T that has an overloaded ostream operator<<.}}
\DoxyCodeLine{106 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{107 \textcolor{keyword}{struct }\mbox{\hyperlink{structbasic__ostream__formatter}{basic\_ostream\_formatter}} : \mbox{\hyperlink{structformatter}{formatter}}<basic\_string\_view<Char>, Char> \{}
\DoxyCodeLine{108   \textcolor{keywordtype}{void} set\_debug\_format() = \textcolor{keyword}{delete};}
\DoxyCodeLine{109 }
\DoxyCodeLine{110   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{111   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T\& value, \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<OutputIt, Char>}}\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{112       -\/> OutputIt \{}
\DoxyCodeLine{113     \textcolor{keyword}{auto} buffer = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{114     detail::format\_value(buffer, value, ctx.locale());}
\DoxyCodeLine{115     \textcolor{keywordflow}{return} \mbox{\hyperlink{structformatter}{formatter<basic\_string\_view<Char>}}, Char>::format(}
\DoxyCodeLine{116         \{buffer.data(), buffer.size()\}, ctx);}
\DoxyCodeLine{117   \}}
\DoxyCodeLine{118 \};}
\DoxyCodeLine{119 }
\DoxyCodeLine{120 \textcolor{keyword}{using }\mbox{\hyperlink{structbasic__ostream__formatter}{ostream\_formatter}} = \mbox{\hyperlink{structbasic__ostream__formatter}{basic\_ostream\_formatter<char>}};}
\DoxyCodeLine{121 }
\DoxyCodeLine{122 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{123 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<detail::streamed\_view<T>, Char>}
\DoxyCodeLine{124     : \mbox{\hyperlink{structbasic__ostream__formatter}{basic\_ostream\_formatter}}<Char> \{}
\DoxyCodeLine{125   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{126   \textcolor{keyword}{auto} format(\mbox{\hyperlink{structdetail_1_1streamed__view}{detail::streamed\_view<T>}} view,}
\DoxyCodeLine{127               \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<OutputIt, Char>}}\& ctx) \textcolor{keyword}{const} -\/> OutputIt \{}
\DoxyCodeLine{128     \textcolor{keywordflow}{return} \mbox{\hyperlink{structbasic__ostream__formatter}{basic\_ostream\_formatter<Char>::format}}(view.value, ctx);}
\DoxyCodeLine{129   \}}
\DoxyCodeLine{130 \};}
\DoxyCodeLine{131 }
\DoxyCodeLine{142 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{143 \textcolor{keyword}{auto} streamed(\textcolor{keyword}{const} T\& value) -\/> \mbox{\hyperlink{structdetail_1_1streamed__view}{detail::streamed\_view<T>}} \{}
\DoxyCodeLine{144   \textcolor{keywordflow}{return} \{value\};}
\DoxyCodeLine{145 \}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} vprint\_directly(std::ostream\& os, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{150                             \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) \{}
\DoxyCodeLine{151   \textcolor{keyword}{auto} buffer = \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}}();}
\DoxyCodeLine{152   detail::vformat\_to(buffer, format\_str, args);}
\DoxyCodeLine{153   detail::write\_buffer(os, buffer);}
\DoxyCodeLine{154 \}}
\DoxyCodeLine{155 }
\DoxyCodeLine{156 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 FMT\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{159 \textcolor{keywordtype}{void} vprint(std::basic\_ostream<Char>\& os,}
\DoxyCodeLine{160             \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}<type\_identity\_t<Char>> format\_str,}
\DoxyCodeLine{161             \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\mbox{\hyperlink{classbasic__format__context}{buffer\_context}}<type\_identity\_t<Char>>> args) \{}
\DoxyCodeLine{162   \textcolor{keyword}{auto} buffer = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{163   detail::vformat\_to(buffer, format\_str, args);}
\DoxyCodeLine{164   \textcolor{keywordflow}{if} (detail::write\_ostream\_unicode(os, \{buffer.data(), buffer.size()\})) \textcolor{keywordflow}{return};}
\DoxyCodeLine{165   detail::write\_buffer(os, buffer);}
\DoxyCodeLine{166 \}}
\DoxyCodeLine{167 }
\DoxyCodeLine{177 FMT\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{178 \textcolor{keywordtype}{void} print(std::ostream\& os, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{179   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& vargs = fmt::make\_format\_args(args...);}
\DoxyCodeLine{180   \textcolor{keywordflow}{if} (detail::is\_utf8())}
\DoxyCodeLine{181     vprint(os, fmt, vargs);}
\DoxyCodeLine{182   \textcolor{keywordflow}{else}}
\DoxyCodeLine{183     detail::vprint\_directly(os, fmt, vargs);}
\DoxyCodeLine{184 \}}
\DoxyCodeLine{185 }
\DoxyCodeLine{186 FMT\_EXPORT}
\DoxyCodeLine{187 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{188 \textcolor{keywordtype}{void} print(std::wostream\& os,}
\DoxyCodeLine{189            \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}}<\textcolor{keywordtype}{wchar\_t}, type\_identity\_t<Args>...> fmt,}
\DoxyCodeLine{190            \mbox{\hyperlink{classArgs}{Args}}\&\&... args) \{}
\DoxyCodeLine{191   vprint(os, fmt, fmt::make\_format\_args<\mbox{\hyperlink{classbasic__format__context}{buffer\_context<wchar\_t>}}>(args...));}
\DoxyCodeLine{192 \}}
\DoxyCodeLine{193 }
\DoxyCodeLine{194 FMT\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{195 \textcolor{keywordtype}{void} println(std::ostream\& os, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{196   fmt::print(os, \textcolor{stringliteral}{"{}\{\}\(\backslash\)n"{}}, fmt::format(fmt, std::forward<T>(args)...));}
\DoxyCodeLine{197 \}}
\DoxyCodeLine{198 }
\DoxyCodeLine{199 FMT\_EXPORT}
\DoxyCodeLine{200 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{201 \textcolor{keywordtype}{void} println(std::wostream\& os,}
\DoxyCodeLine{202              \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}}<\textcolor{keywordtype}{wchar\_t}, type\_identity\_t<Args>...> fmt,}
\DoxyCodeLine{203              \mbox{\hyperlink{classArgs}{Args}}\&\&... args) \{}
\DoxyCodeLine{204   print(os, L\textcolor{stringliteral}{"{}\{\}\(\backslash\)n"{}}, fmt::format(fmt, std::forward<Args>(args)...));}
\DoxyCodeLine{205 \}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207 FMT\_END\_NAMESPACE}
\DoxyCodeLine{208 }
\DoxyCodeLine{209 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_OSTREAM\_H\_}}

\end{DoxyCode}
