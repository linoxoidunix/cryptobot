\hypertarget{compile_8h_source}{}\doxysection{compile.\+h}
\label{compile_8h_source}\index{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/compile.h@{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/compile.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ experimental format string compilation}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich and fmt contributors}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_COMPILE\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_COMPILE\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}format.h"{}}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{14 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} InputIt>}
\DoxyCodeLine{17 FMT\_CONSTEXPR \textcolor{keyword}{inline} counting\_iterator copy\_str(InputIt begin, InputIt end,}
\DoxyCodeLine{18                                                 counting\_iterator it) \{}
\DoxyCodeLine{19   \textcolor{keywordflow}{return} it + (end -\/ begin);}
\DoxyCodeLine{20 \}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{comment}{// A compile-\/time string which is compiled into fast formatting code.}}
\DoxyCodeLine{23 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1compiled__string}{compiled\_string}} \{\};}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{26 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compiled__string}{is\_compiled\_string}} : std::is\_base\_of<compiled\_string, S> \{\};}
\DoxyCodeLine{27 }
\DoxyCodeLine{41 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#  define FMT\_COMPILE(s) \(\backslash\)}}
\DoxyCodeLine{43 \textcolor{preprocessor}{    FMT\_STRING\_IMPL(s, fmt::detail::compiled\_string, explicit)}}
\DoxyCodeLine{44 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#  define FMT\_COMPILE(s) FMT\_STRING(s)}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{49 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{50           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{51 \textcolor{keyword}{struct }udl\_compiled\_string : \mbox{\hyperlink{classdetail_1_1compiled__string}{compiled\_string}} \{}
\DoxyCodeLine{52   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{53   \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{54     \textcolor{keywordflow}{return} \{Str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}, N -\/ 1\};}
\DoxyCodeLine{55   \}}
\DoxyCodeLine{56 \};}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{58 }
\DoxyCodeLine{59 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Tail>}
\DoxyCodeLine{60 \textcolor{keyword}{const} T\& first(\textcolor{keyword}{const} T\& value, \textcolor{keyword}{const} Tail\&...) \{}
\DoxyCodeLine{61   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{62 \}}
\DoxyCodeLine{63 }
\DoxyCodeLine{64 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{65 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}> \textcolor{keyword}{struct }type\_list \{\};}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{comment}{// Returns a reference to the argument at index N from [first, rest...].}}
\DoxyCodeLine{68 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{69 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keyword}{auto}\& get([[maybe\_unused]] \textcolor{keyword}{const} T\& first,}
\DoxyCodeLine{70                           [[maybe\_unused]] \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... rest) \{}
\DoxyCodeLine{71   \textcolor{keyword}{static\_assert}(N < 1 + \textcolor{keyword}{sizeof}...(Args), \textcolor{stringliteral}{"{}index is out of bounds"{}});}
\DoxyCodeLine{72   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (N == 0)}
\DoxyCodeLine{73     \textcolor{keywordflow}{return} first;}
\DoxyCodeLine{74   \textcolor{keywordflow}{else}}
\DoxyCodeLine{75     \textcolor{keywordflow}{return} detail::get<N -\/ 1>(rest...);}
\DoxyCodeLine{76 \}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{79 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} get\_arg\_index\_by\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name,}
\DoxyCodeLine{80                                     type\_list<Args...>) \{}
\DoxyCodeLine{81   \textcolor{keywordflow}{return} get\_arg\_index\_by\_name<\mbox{\hyperlink{classArgs}{Args}}...>(name);}
\DoxyCodeLine{82 \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename}> \textcolor{keyword}{struct }get\_type\_impl;}
\DoxyCodeLine{85 }
\DoxyCodeLine{86 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}> \textcolor{keyword}{struct }get\_type\_impl<N, type\_list<\mbox{\hyperlink{classArgs}{Args}}...>> \{}
\DoxyCodeLine{87   \textcolor{keyword}{using }type =}
\DoxyCodeLine{88       remove\_cvref\_t<decltype(detail::get<N>(std::declval<Args>()...))>;}
\DoxyCodeLine{89 \};}
\DoxyCodeLine{90 }
\DoxyCodeLine{91 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{92 \textcolor{keyword}{using }get\_type = \textcolor{keyword}{typename} get\_type\_impl<N, T>::type;}
\DoxyCodeLine{93 }
\DoxyCodeLine{94 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }is\_compiled\_format : std::false\_type \{\};}
\DoxyCodeLine{95 }
\DoxyCodeLine{96 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }text \{}
\DoxyCodeLine{97   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} data;}
\DoxyCodeLine{98   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{99 }
\DoxyCodeLine{100   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{101   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&...)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{102     \textcolor{keywordflow}{return} write<Char>(out, data);}
\DoxyCodeLine{103   \}}
\DoxyCodeLine{104 \};}
\DoxyCodeLine{105 }
\DoxyCodeLine{106 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{107 \textcolor{keyword}{struct }is\_compiled\_format<text<Char>> : std::true\_type \{\};}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{110 \textcolor{keyword}{constexpr} text<Char> make\_text(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s, \textcolor{keywordtype}{size\_t} pos,}
\DoxyCodeLine{111                                \textcolor{keywordtype}{size\_t} size) \{}
\DoxyCodeLine{112   \textcolor{keywordflow}{return} \{\{\&s[pos], size\}\};}
\DoxyCodeLine{113 \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }code\_unit \{}
\DoxyCodeLine{116   Char value;}
\DoxyCodeLine{117   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{118 }
\DoxyCodeLine{119   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{120   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&...)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{121     *out++ = value;}
\DoxyCodeLine{122     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{123   \}}
\DoxyCodeLine{124 \};}
\DoxyCodeLine{125 }
\DoxyCodeLine{126 \textcolor{comment}{// This ensures that the argument type is convertible to `const T\&`.}}
\DoxyCodeLine{127 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{128 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} T\& get\_arg\_checked(\textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args) \{}
\DoxyCodeLine{129   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& arg = detail::get<N>(args...);}
\DoxyCodeLine{130   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\mbox{\hyperlink{structdetail_1_1is__named__arg}{detail::is\_named\_arg}}<remove\_cvref\_t<\textcolor{keyword}{decltype}(arg)>>()) \{}
\DoxyCodeLine{131     \textcolor{keywordflow}{return} arg.value;}
\DoxyCodeLine{132   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{133     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{134   \}}
\DoxyCodeLine{135 \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{138 \textcolor{keyword}{struct }is\_compiled\_format<code\_unit<Char>> : std::true\_type \{\};}
\DoxyCodeLine{139 }
\DoxyCodeLine{140 \textcolor{comment}{// A replacement field that refers to argument N.}}
\DoxyCodeLine{141 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N> \textcolor{keyword}{struct }field \{}
\DoxyCodeLine{142   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{143 }
\DoxyCodeLine{144   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{145   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{146     \textcolor{keyword}{const} T\& arg = get\_arg\_checked<T, N>(args...);}
\DoxyCodeLine{147     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_convertible\_v<T, basic\_string\_view<Char>>) \{}
\DoxyCodeLine{148       \textcolor{keyword}{auto} s = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(arg);}
\DoxyCodeLine{149       \textcolor{keywordflow}{return} copy\_str<Char>(s.begin(), s.end(), out);}
\DoxyCodeLine{150     \}}
\DoxyCodeLine{151     \textcolor{keywordflow}{return} write<Char>(out, arg);}
\DoxyCodeLine{152   \}}
\DoxyCodeLine{153 \};}
\DoxyCodeLine{154 }
\DoxyCodeLine{155 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N>}
\DoxyCodeLine{156 \textcolor{keyword}{struct }is\_compiled\_format<field<Char, T, N>> : std::true\_type \{\};}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 \textcolor{comment}{// A replacement field that refers to argument with name.}}
\DoxyCodeLine{159 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }runtime\_named\_field \{}
\DoxyCodeLine{160   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{161   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name;}
\DoxyCodeLine{162 }
\DoxyCodeLine{163   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{164   \textcolor{keyword}{constexpr} \textcolor{keyword}{static} \textcolor{keywordtype}{bool} try\_format\_argument(}
\DoxyCodeLine{165       OutputIt\& out,}
\DoxyCodeLine{166       \textcolor{comment}{// [[maybe\_unused]] due to unused-\/but-\/set-\/parameter warning in GCC 7,8,9}}
\DoxyCodeLine{167       [[maybe\_unused]] \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} arg\_name, \textcolor{keyword}{const} T\& arg) \{}
\DoxyCodeLine{168     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_named\_arg<typename std::remove\_cv<T>::type>::value) \{}
\DoxyCodeLine{169       \textcolor{keywordflow}{if} (arg\_name == arg.name) \{}
\DoxyCodeLine{170         out = write<Char>(out, arg.value);}
\DoxyCodeLine{171         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{172       \}}
\DoxyCodeLine{173     \}}
\DoxyCodeLine{174     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{175   \}}
\DoxyCodeLine{176 }
\DoxyCodeLine{177   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{178   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{179     \textcolor{keywordtype}{bool} found = (try\_format\_argument(out, name, args) || ...);}
\DoxyCodeLine{180     \textcolor{keywordflow}{if} (!found) \{}
\DoxyCodeLine{181       FMT\_THROW(format\_error(\textcolor{stringliteral}{"{}argument with specified name is not found"{}}));}
\DoxyCodeLine{182     \}}
\DoxyCodeLine{183     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{184   \}}
\DoxyCodeLine{185 \};}
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{188 \textcolor{keyword}{struct }is\_compiled\_format<runtime\_named\_field<Char>> : std::true\_type \{\};}
\DoxyCodeLine{189 }
\DoxyCodeLine{190 \textcolor{comment}{// A replacement field that refers to argument N and has format specifiers.}}
\DoxyCodeLine{191 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N> \textcolor{keyword}{struct }spec\_field \{}
\DoxyCodeLine{192   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{193   \mbox{\hyperlink{structformatter}{formatter<T, Char>}} fmt;}
\DoxyCodeLine{194 }
\DoxyCodeLine{195   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{196   \textcolor{keyword}{constexpr} FMT\_INLINE OutputIt format(OutputIt out,}
\DoxyCodeLine{197                                        \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{198     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& vargs =}
\DoxyCodeLine{199         fmt::make\_format\_args<basic\_format\_context<OutputIt, Char>>(args...);}
\DoxyCodeLine{200     \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<OutputIt, Char>}} ctx(out, vargs);}
\DoxyCodeLine{201     \textcolor{keywordflow}{return} fmt.format(get\_arg\_checked<T, N>(args...), ctx);}
\DoxyCodeLine{202   \}}
\DoxyCodeLine{203 \};}
\DoxyCodeLine{204 }
\DoxyCodeLine{205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} N>}
\DoxyCodeLine{206 \textcolor{keyword}{struct }is\_compiled\_format<spec\_field<Char, T, N>> : std::true\_type \{\};}
\DoxyCodeLine{207 }
\DoxyCodeLine{208 \textcolor{keyword}{template} <\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} R> \textcolor{keyword}{struct }concat \{}
\DoxyCodeLine{209   L lhs;}
\DoxyCodeLine{210   R rhs;}
\DoxyCodeLine{211   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} L::char\_type;}
\DoxyCodeLine{212 }
\DoxyCodeLine{213   \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{214   \textcolor{keyword}{constexpr} OutputIt format(OutputIt out, \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{215     out = lhs.format(out, args...);}
\DoxyCodeLine{216     \textcolor{keywordflow}{return} rhs.format(out, args...);}
\DoxyCodeLine{217   \}}
\DoxyCodeLine{218 \};}
\DoxyCodeLine{219 }
\DoxyCodeLine{220 \textcolor{keyword}{template} <\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} R>}
\DoxyCodeLine{221 \textcolor{keyword}{struct }is\_compiled\_format<concat<L, R>> : std::true\_type \{\};}
\DoxyCodeLine{222 }
\DoxyCodeLine{223 \textcolor{keyword}{template} <\textcolor{keyword}{typename} L, \textcolor{keyword}{typename} R>}
\DoxyCodeLine{224 \textcolor{keyword}{constexpr} concat<L, R> make\_concat(L lhs, R rhs) \{}
\DoxyCodeLine{225   \textcolor{keywordflow}{return} \{lhs, rhs\};}
\DoxyCodeLine{226 \}}
\DoxyCodeLine{227 }
\DoxyCodeLine{228 \textcolor{keyword}{struct }unknown\_format \{\};}
\DoxyCodeLine{229 }
\DoxyCodeLine{230 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{231 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} parse\_text(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str, \textcolor{keywordtype}{size\_t} pos) \{}
\DoxyCodeLine{232   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} size = str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}(); pos != size; ++pos) \{}
\DoxyCodeLine{233     \textcolor{keywordflow}{if} (str[pos] == \textcolor{charliteral}{'\{'} || str[pos] == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{break};}
\DoxyCodeLine{234   \}}
\DoxyCodeLine{235   \textcolor{keywordflow}{return} pos;}
\DoxyCodeLine{236 \}}
\DoxyCodeLine{237 }
\DoxyCodeLine{238 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Args, \textcolor{keywordtype}{size\_t} POS, \textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{239 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_format\_string(S format\_str);}
\DoxyCodeLine{240 }
\DoxyCodeLine{241 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Args, \textcolor{keywordtype}{size\_t} POS, \textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{242 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} parse\_tail(T head, S format\_str) \{}
\DoxyCodeLine{243   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (POS !=}
\DoxyCodeLine{244                 \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(format\_str).\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}()) \{}
\DoxyCodeLine{245     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} tail = compile\_format\_string<Args, POS, ID>(format\_str);}
\DoxyCodeLine{246     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<remove\_cvref\_t<\textcolor{keyword}{decltype}(tail)>,}
\DoxyCodeLine{247                                unknown\_format>())}
\DoxyCodeLine{248       \textcolor{keywordflow}{return} tail;}
\DoxyCodeLine{249     \textcolor{keywordflow}{else}}
\DoxyCodeLine{250       \textcolor{keywordflow}{return} make\_concat(head, tail);}
\DoxyCodeLine{251   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{252     \textcolor{keywordflow}{return} head;}
\DoxyCodeLine{253   \}}
\DoxyCodeLine{254 \}}
\DoxyCodeLine{255 }
\DoxyCodeLine{256 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }parse\_specs\_result \{}
\DoxyCodeLine{257   \mbox{\hyperlink{structformatter}{formatter<T, Char>}} fmt;}
\DoxyCodeLine{258   \textcolor{keywordtype}{size\_t} end;}
\DoxyCodeLine{259   \textcolor{keywordtype}{int} next\_arg\_id;}
\DoxyCodeLine{260 \};}
\DoxyCodeLine{261 }
\DoxyCodeLine{262 \textcolor{keyword}{enum} \{ manual\_indexing\_id = -\/1 \};}
\DoxyCodeLine{263 }
\DoxyCodeLine{264 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{265 \textcolor{keyword}{constexpr} parse\_specs\_result<T, Char> parse\_specs(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str,}
\DoxyCodeLine{266                                                   \textcolor{keywordtype}{size\_t} pos, \textcolor{keywordtype}{int} next\_arg\_id) \{}
\DoxyCodeLine{267   str.remove\_prefix(pos);}
\DoxyCodeLine{268   \textcolor{keyword}{auto} ctx =}
\DoxyCodeLine{269       compile\_parse\_context<Char>(str, max\_value<int>(), \textcolor{keyword}{nullptr}, next\_arg\_id);}
\DoxyCodeLine{270   \textcolor{keyword}{auto} f = \mbox{\hyperlink{structformatter}{formatter<T, Char>}}();}
\DoxyCodeLine{271   \textcolor{keyword}{auto} end = f.parse(ctx);}
\DoxyCodeLine{272   \textcolor{keywordflow}{return} \{f, pos + fmt::detail::to\_unsigned(end -\/ str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}()),}
\DoxyCodeLine{273           next\_arg\_id == 0 ? manual\_indexing\_id : ctx.next\_arg\_id()\};}
\DoxyCodeLine{274 \}}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }arg\_id\_handler \{}
\DoxyCodeLine{277   arg\_ref<Char> arg\_id;}
\DoxyCodeLine{278 }
\DoxyCodeLine{279   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} on\_auto() \{}
\DoxyCodeLine{280     FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}handler cannot be used with automatic indexing"{}});}
\DoxyCodeLine{281     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{282   \}}
\DoxyCodeLine{283   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} on\_index(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{284     arg\_id = arg\_ref<Char>(\textcolor{keywordtype}{id});}
\DoxyCodeLine{285     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{286   \}}
\DoxyCodeLine{287   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} on\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{288     arg\_id = arg\_ref<Char>(\textcolor{keywordtype}{id});}
\DoxyCodeLine{289     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{290   \}}
\DoxyCodeLine{291 \};}
\DoxyCodeLine{292 }
\DoxyCodeLine{293 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }parse\_arg\_id\_result \{}
\DoxyCodeLine{294   arg\_ref<Char> arg\_id;}
\DoxyCodeLine{295   \textcolor{keyword}{const} Char* arg\_id\_end;}
\DoxyCodeLine{296 \};}
\DoxyCodeLine{297 }
\DoxyCodeLine{298 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{299 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} parse\_arg\_id(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end) \{}
\DoxyCodeLine{300   \textcolor{keyword}{auto} handler = arg\_id\_handler<Char>\{arg\_ref<Char>\{\}\};}
\DoxyCodeLine{301   \textcolor{keyword}{auto} arg\_id\_end = parse\_arg\_id(begin, end, handler);}
\DoxyCodeLine{302   \textcolor{keywordflow}{return} parse\_arg\_id\_result<Char>\{handler.arg\_id, arg\_id\_end\};}
\DoxyCodeLine{303 \}}
\DoxyCodeLine{304 }
\DoxyCodeLine{305 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }field\_type \{}
\DoxyCodeLine{306   \textcolor{keyword}{using }type = remove\_cvref\_t<T>;}
\DoxyCodeLine{307 \};}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{310 \textcolor{keyword}{struct }field\_type<T, enable\_if\_t<detail::is\_named\_arg<T>::value>> \{}
\DoxyCodeLine{311   \textcolor{keyword}{using }type = remove\_cvref\_t<\textcolor{keyword}{decltype}(T::value)>;}
\DoxyCodeLine{312 \};}
\DoxyCodeLine{313 }
\DoxyCodeLine{314 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} \mbox{\hyperlink{classArgs}{Args}}, \textcolor{keywordtype}{size\_t} END\_POS, \textcolor{keywordtype}{int} ARG\_INDEX, \textcolor{keywordtype}{int} NEXT\_ID,}
\DoxyCodeLine{315           \textcolor{keyword}{typename} S>}
\DoxyCodeLine{316 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} parse\_replacement\_field\_then\_tail(S format\_str) \{}
\DoxyCodeLine{317   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} S::char\_type;}
\DoxyCodeLine{318   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}(format\_str);}
\DoxyCodeLine{319   \textcolor{keyword}{constexpr} char\_type c = END\_POS != str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() ? str[END\_POS] : char\_type();}
\DoxyCodeLine{320   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{321     \textcolor{keywordflow}{return} parse\_tail<Args, END\_POS + 1, NEXT\_ID>(}
\DoxyCodeLine{322         field<char\_type, \textcolor{keyword}{typename} field\_type<T>::type, ARG\_INDEX>(),}
\DoxyCodeLine{323         format\_str);}
\DoxyCodeLine{324   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c != \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{325     FMT\_THROW(format\_error(\textcolor{stringliteral}{"{}expected ':'"{}}));}
\DoxyCodeLine{326   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{327     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} result = parse\_specs<typename field\_type<T>::type>(}
\DoxyCodeLine{328         str, END\_POS + 1, NEXT\_ID == manual\_indexing\_id ? 0 : NEXT\_ID);}
\DoxyCodeLine{329     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (result.end >= str.size() || str[result.end] != \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{330       FMT\_THROW(format\_error(\textcolor{stringliteral}{"{}expected '\}'"{}}));}
\DoxyCodeLine{331       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{332     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{333       \textcolor{keywordflow}{return} parse\_tail<\mbox{\hyperlink{classArgs}{Args}}, result.end + 1, result.next\_arg\_id>(}
\DoxyCodeLine{334           spec\_field<char\_type, typename field\_type<T>::type, ARG\_INDEX>\{}
\DoxyCodeLine{335               result.fmt\},}
\DoxyCodeLine{336           format\_str);}
\DoxyCodeLine{337     \}}
\DoxyCodeLine{338   \}}
\DoxyCodeLine{339 \}}
\DoxyCodeLine{340 }
\DoxyCodeLine{341 \textcolor{comment}{// Compiles a non-\/empty format string and returns the compiled representation}}
\DoxyCodeLine{342 \textcolor{comment}{// or unknown\_format() on unrecognized input.}}
\DoxyCodeLine{343 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Args, \textcolor{keywordtype}{size\_t} POS, \textcolor{keywordtype}{int} ID, \textcolor{keyword}{typename} S>}
\DoxyCodeLine{344 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_format\_string(S format\_str) \{}
\DoxyCodeLine{345   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} S::char\_type;}
\DoxyCodeLine{346   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}}(format\_str);}
\DoxyCodeLine{347   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS] == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{348     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (POS + 1 == str.size())}
\DoxyCodeLine{349       FMT\_THROW(format\_error(\textcolor{stringliteral}{"{}unmatched '\{' in format string"{}}));}
\DoxyCodeLine{350     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS + 1] == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{351       \textcolor{keywordflow}{return} parse\_tail<Args, POS + 2, ID>(make\_text(str, POS, 1), format\_str);}
\DoxyCodeLine{352     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS + 1] == \textcolor{charliteral}{'\}'} || str[POS + 1] == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{353       \textcolor{keyword}{static\_assert}(ID != manual\_indexing\_id,}
\DoxyCodeLine{354                     \textcolor{stringliteral}{"{}cannot switch from manual to automatic argument indexing"{}});}
\DoxyCodeLine{355       \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} next\_id =}
\DoxyCodeLine{356           ID != manual\_indexing\_id ? ID + 1 : manual\_indexing\_id;}
\DoxyCodeLine{357       \textcolor{keywordflow}{return} parse\_replacement\_field\_then\_tail<get\_type<ID, Args>, \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{358                                                POS + 1, ID, next\_id>(}
\DoxyCodeLine{359           format\_str);}
\DoxyCodeLine{360     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{361       \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_id\_result =}
\DoxyCodeLine{362           parse\_arg\_id<ID>(str.data() + POS + 1, str.data() + str.size());}
\DoxyCodeLine{363       \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_id\_end\_pos = arg\_id\_result.arg\_id\_end -\/ str.data();}
\DoxyCodeLine{364       \textcolor{keyword}{constexpr} char\_type c =}
\DoxyCodeLine{365           arg\_id\_end\_pos != str.size() ? str[arg\_id\_end\_pos] : char\_type();}
\DoxyCodeLine{366       \textcolor{keyword}{static\_assert}(c == \textcolor{charliteral}{'\}'} || c == \textcolor{charliteral}{':'}, \textcolor{stringliteral}{"{}missing '\}' in format string"{}});}
\DoxyCodeLine{367       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (arg\_id\_result.arg\_id.kind == arg\_id\_kind::index) \{}
\DoxyCodeLine{368         \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{369             ID == manual\_indexing\_id || ID == 0,}
\DoxyCodeLine{370             \textcolor{stringliteral}{"{}cannot switch from automatic to manual argument indexing"{}});}
\DoxyCodeLine{371         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_index = arg\_id\_result.arg\_id.val.index;}
\DoxyCodeLine{372         \textcolor{keywordflow}{return} parse\_replacement\_field\_then\_tail<get\_type<arg\_index, Args>,}
\DoxyCodeLine{373                                                  \mbox{\hyperlink{classArgs}{Args}}, arg\_id\_end\_pos,}
\DoxyCodeLine{374                                                  arg\_index, manual\_indexing\_id>(}
\DoxyCodeLine{375             format\_str);}
\DoxyCodeLine{376       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (arg\_id\_result.arg\_id.kind == arg\_id\_kind::name) \{}
\DoxyCodeLine{377         \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_index =}
\DoxyCodeLine{378             get\_arg\_index\_by\_name(arg\_id\_result.arg\_id.val.name, \mbox{\hyperlink{classArgs}{Args}}\{\});}
\DoxyCodeLine{379         \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (arg\_index >= 0) \{}
\DoxyCodeLine{380           \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} next\_id =}
\DoxyCodeLine{381               ID != manual\_indexing\_id ? ID + 1 : manual\_indexing\_id;}
\DoxyCodeLine{382           \textcolor{keywordflow}{return} parse\_replacement\_field\_then\_tail<}
\DoxyCodeLine{383               \textcolor{keyword}{decltype}(get\_type<arg\_index, Args>::value), \mbox{\hyperlink{classArgs}{Args}}, arg\_id\_end\_pos,}
\DoxyCodeLine{384               arg\_index, next\_id>(format\_str);}
\DoxyCodeLine{385         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{386           \textcolor{keywordflow}{return} parse\_tail<Args, arg\_id\_end\_pos + 1, ID>(}
\DoxyCodeLine{387               runtime\_named\_field<char\_type>\{arg\_id\_result.arg\_id.val.name\},}
\DoxyCodeLine{388               format\_str);}
\DoxyCodeLine{389         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (c == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{390           \textcolor{keywordflow}{return} unknown\_format();  \textcolor{comment}{// no type info for specs parsing}}
\DoxyCodeLine{391         \}}
\DoxyCodeLine{392       \}}
\DoxyCodeLine{393     \}}
\DoxyCodeLine{394   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str[POS] == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{395     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (POS + 1 == str.size())}
\DoxyCodeLine{396       FMT\_THROW(format\_error(\textcolor{stringliteral}{"{}unmatched '\}' in format string"{}}));}
\DoxyCodeLine{397     \textcolor{keywordflow}{return} parse\_tail<Args, POS + 2, ID>(make\_text(str, POS, 1), format\_str);}
\DoxyCodeLine{398   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{399     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} end = parse\_text(str, POS + 1);}
\DoxyCodeLine{400     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (end -\/ POS > 1) \{}
\DoxyCodeLine{401       \textcolor{keywordflow}{return} parse\_tail<Args, end, ID>(make\_text(str, POS, end -\/ POS),}
\DoxyCodeLine{402                                        format\_str);}
\DoxyCodeLine{403     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{404       \textcolor{keywordflow}{return} parse\_tail<Args, end, ID>(code\_unit<char\_type>\{str[POS]\},}
\DoxyCodeLine{405                                        format\_str);}
\DoxyCodeLine{406     \}}
\DoxyCodeLine{407   \}}
\DoxyCodeLine{408 \}}
\DoxyCodeLine{409 }
\DoxyCodeLine{410 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}, \textcolor{keyword}{typename} S,}
\DoxyCodeLine{411           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__compiled__string}{detail::is\_compiled\_string<S>::value}})>}
\DoxyCodeLine{412 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile(S format\_str) \{}
\DoxyCodeLine{413   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(format\_str);}
\DoxyCodeLine{414   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str.size() == 0) \{}
\DoxyCodeLine{415     \textcolor{keywordflow}{return} detail::make\_text(str, 0, 0);}
\DoxyCodeLine{416   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{417     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} result =}
\DoxyCodeLine{418         detail::compile\_format\_string<detail::type\_list<\mbox{\hyperlink{classArgs}{Args}}...>, 0, 0>(}
\DoxyCodeLine{419             format\_str);}
\DoxyCodeLine{420     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{421   \}}
\DoxyCodeLine{422 \}}
\DoxyCodeLine{423 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{424 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{425 }
\DoxyCodeLine{426 FMT\_BEGIN\_EXPORT}
\DoxyCodeLine{427 }
\DoxyCodeLine{428 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr) \&\& defined(\_\_cpp\_return\_type\_deduction)}}
\DoxyCodeLine{429 }
\DoxyCodeLine{430 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CompiledFormat, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{431           \textcolor{keyword}{typename} Char = \textcolor{keyword}{typename} CompiledFormat::char\_type,}
\DoxyCodeLine{432           FMT\_ENABLE\_IF(detail::is\_compiled\_format<CompiledFormat>::value)>}
\DoxyCodeLine{433 FMT\_INLINE std::basic\_string<Char> format(\textcolor{keyword}{const} CompiledFormat\& cf,}
\DoxyCodeLine{434                                           \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args) \{}
\DoxyCodeLine{435   \textcolor{keyword}{auto} s = std::basic\_string<Char>();}
\DoxyCodeLine{436   cf.format(std::back\_inserter(s), args...);}
\DoxyCodeLine{437   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{438 \}}
\DoxyCodeLine{439 }
\DoxyCodeLine{440 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} CompiledFormat, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{441           FMT\_ENABLE\_IF(detail::is\_compiled\_format<CompiledFormat>::value)>}
\DoxyCodeLine{442 \textcolor{keyword}{constexpr} FMT\_INLINE OutputIt format\_to(OutputIt out, \textcolor{keyword}{const} CompiledFormat\& cf,}
\DoxyCodeLine{443                                         \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args) \{}
\DoxyCodeLine{444   \textcolor{keywordflow}{return} cf.format(out, args...);}
\DoxyCodeLine{445 \}}
\DoxyCodeLine{446 }
\DoxyCodeLine{447 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{448           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__compiled__string}{detail::is\_compiled\_string<S>::value}})>}
\DoxyCodeLine{449 FMT\_INLINE std::basic\_string<typename S::char\_type> format(\textcolor{keyword}{const} S\&,}
\DoxyCodeLine{450                                                            \mbox{\hyperlink{classArgs}{Args}}\&\&... args) \{}
\DoxyCodeLine{451   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<typename S::char\_type, char>::value) \{}
\DoxyCodeLine{452     \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} str = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(S());}
\DoxyCodeLine{453     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (str.size() == 2 \&\& str[0] == \textcolor{charliteral}{'\{'} \&\& str[1] == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{454       \textcolor{keyword}{const} \textcolor{keyword}{auto}\& first = detail::first(args...);}
\DoxyCodeLine{455       \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\mbox{\hyperlink{structdetail_1_1is__named__arg}{detail::is\_named\_arg}}<}
\DoxyCodeLine{456                         remove\_cvref\_t<\textcolor{keyword}{decltype}(first)>>::value) \{}
\DoxyCodeLine{457         \textcolor{keywordflow}{return} fmt::to\_string(first.value);}
\DoxyCodeLine{458       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{459         \textcolor{keywordflow}{return} fmt::to\_string(first);}
\DoxyCodeLine{460       \}}
\DoxyCodeLine{461     \}}
\DoxyCodeLine{462   \}}
\DoxyCodeLine{463   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compiled = detail::compile<\mbox{\hyperlink{classArgs}{Args}}...>(S());}
\DoxyCodeLine{464   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<remove\_cvref\_t<\textcolor{keyword}{decltype}(compiled)>,}
\DoxyCodeLine{465                              detail::unknown\_format>()) \{}
\DoxyCodeLine{466     \textcolor{keywordflow}{return} fmt::format(}
\DoxyCodeLine{467         \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}\textcolor{keyword}{>}(S()),}
\DoxyCodeLine{468         std::forward<Args>(args)...);}
\DoxyCodeLine{469   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{470     \textcolor{keywordflow}{return} fmt::format(compiled, std::forward<Args>(args)...);}
\DoxyCodeLine{471   \}}
\DoxyCodeLine{472 \}}
\DoxyCodeLine{473 }
\DoxyCodeLine{474 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{475           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__compiled__string}{detail::is\_compiled\_string<S>::value}})>}
\DoxyCodeLine{476 FMT\_CONSTEXPR OutputIt format\_to(OutputIt out, \textcolor{keyword}{const} S\&, \mbox{\hyperlink{classArgs}{Args}}\&\&... args) \{}
\DoxyCodeLine{477   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compiled = detail::compile<\mbox{\hyperlink{classArgs}{Args}}...>(S());}
\DoxyCodeLine{478   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_same<remove\_cvref\_t<\textcolor{keyword}{decltype}(compiled)>,}
\DoxyCodeLine{479                              detail::unknown\_format>()) \{}
\DoxyCodeLine{480     \textcolor{keywordflow}{return} fmt::format\_to(}
\DoxyCodeLine{481         out, \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}\textcolor{keyword}{>}(S()),}
\DoxyCodeLine{482         std::forward<Args>(args)...);}
\DoxyCodeLine{483   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{484     \textcolor{keywordflow}{return} fmt::format\_to(out, compiled, std::forward<Args>(args)...);}
\DoxyCodeLine{485   \}}
\DoxyCodeLine{486 \}}
\DoxyCodeLine{487 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{488 }
\DoxyCodeLine{489 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{490           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__compiled__string}{detail::is\_compiled\_string<S>::value}})>}
\DoxyCodeLine{491 \mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result<OutputIt>}} format\_to\_n(OutputIt out, \textcolor{keywordtype}{size\_t} n,}
\DoxyCodeLine{492                                          \textcolor{keyword}{const} S\& format\_str, \mbox{\hyperlink{classArgs}{Args}}\&\&... args) \{}
\DoxyCodeLine{493   \textcolor{keyword}{using }traits = \mbox{\hyperlink{classdetail_1_1fixed__buffer__traits}{detail::fixed\_buffer\_traits}};}
\DoxyCodeLine{494   \textcolor{keyword}{auto} buf = \mbox{\hyperlink{classdetail_1_1iterator__buffer}{detail::iterator\_buffer<OutputIt, char, traits>}}(out, n);}
\DoxyCodeLine{495   format\_to(std::back\_inserter(buf), format\_str, std::forward<Args>(args)...);}
\DoxyCodeLine{496   \textcolor{keywordflow}{return} \{buf.out(), buf.count()\};}
\DoxyCodeLine{497 \}}
\DoxyCodeLine{498 }
\DoxyCodeLine{499 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{500           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__compiled__string}{detail::is\_compiled\_string<S>::value}})>}
\DoxyCodeLine{501 FMT\_CONSTEXPR20 \textcolor{keywordtype}{size\_t} formatted\_size(\textcolor{keyword}{const} S\& format\_str,}
\DoxyCodeLine{502                                       \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args) \{}
\DoxyCodeLine{503   \textcolor{keywordflow}{return} fmt::format\_to(\mbox{\hyperlink{classdetail_1_1counting__iterator}{detail::counting\_iterator}}(), format\_str, args...)}
\DoxyCodeLine{504       .count();}
\DoxyCodeLine{505 \}}
\DoxyCodeLine{506 }
\DoxyCodeLine{507 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{508           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__compiled__string}{detail::is\_compiled\_string<S>::value}})>}
\DoxyCodeLine{509 \textcolor{keywordtype}{void} print(std::FILE* f, \textcolor{keyword}{const} S\& format\_str, \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args) \{}
\DoxyCodeLine{510   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer;}
\DoxyCodeLine{511   fmt::format\_to(std::back\_inserter(buffer), format\_str, args...);}
\DoxyCodeLine{512   detail::print(f, \{buffer.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}(), buffer.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()\});}
\DoxyCodeLine{513 \}}
\DoxyCodeLine{514 }
\DoxyCodeLine{515 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}},}
\DoxyCodeLine{516           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__compiled__string}{detail::is\_compiled\_string<S>::value}})>}
\DoxyCodeLine{517 \textcolor{keywordtype}{void} print(\textcolor{keyword}{const} S\& format\_str, \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&... args) \{}
\DoxyCodeLine{518   print(stdout, format\_str, args...);}
\DoxyCodeLine{519 \}}
\DoxyCodeLine{520 }
\DoxyCodeLine{521 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{522 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{523 \textcolor{keyword}{template} <detail\_exported::fixed\_\textcolor{keywordtype}{string} Str> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}}\_cf() \{}
\DoxyCodeLine{524   \textcolor{keyword}{using }char\_t = remove\_cvref\_t<\textcolor{keyword}{decltype}(Str.data[0])>;}
\DoxyCodeLine{525   \textcolor{keywordflow}{return} detail::udl\_compiled\_string<char\_t, \textcolor{keyword}{sizeof}(Str.data) / \textcolor{keyword}{sizeof}(char\_t),}
\DoxyCodeLine{526                                      Str>();}
\DoxyCodeLine{527 \}}
\DoxyCodeLine{528 \}  \textcolor{comment}{// namespace literals}}
\DoxyCodeLine{529 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{530 }
\DoxyCodeLine{531 FMT\_END\_EXPORT}
\DoxyCodeLine{532 FMT\_END\_NAMESPACE}
\DoxyCodeLine{533 }
\DoxyCodeLine{534 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_COMPILE\_H\_}}

\end{DoxyCode}
