\hypertarget{core_8h_source}{}\doxysection{core.\+h}
\label{core_8h_source}\index{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/core.h@{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/core.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// Formatting library for C++ -\/ the core API for char/UTF-\/8}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{// Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{4 \textcolor{comment}{// All rights reserved.}}
\DoxyCodeLine{5 \textcolor{comment}{//}}
\DoxyCodeLine{6 \textcolor{comment}{// For the license information refer to format.h.}}
\DoxyCodeLine{7 }
\DoxyCodeLine{8 \textcolor{preprocessor}{\#ifndef FMT\_CORE\_H\_}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#define FMT\_CORE\_H\_}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <cstddef>}  \textcolor{comment}{// std::byte}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <cstdio>}   \textcolor{comment}{// std::FILE}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <cstring>}  \textcolor{comment}{// std::strlen}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <iterator>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{18 }
\DoxyCodeLine{19 \textcolor{comment}{// The fmt library version in the form major * 10000 + minor * 100 + patch.}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#define FMT\_VERSION 100001}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#if defined(\_\_clang\_\_) \&\& !defined(\_\_ibmxl\_\_)}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#  define FMT\_CLANG\_VERSION (\_\_clang\_major\_\_ * 100 + \_\_clang\_minor\_\_)}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#  define FMT\_CLANG\_VERSION 0}}
\DoxyCodeLine{26 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{preprocessor}{\#if defined(\_\_GNUC\_\_) \&\& !defined(\_\_clang\_\_) \&\& !defined(\_\_INTEL\_COMPILER) \&\& \(\backslash\)}}
\DoxyCodeLine{29 \textcolor{preprocessor}{    !defined(\_\_NVCOMPILER)}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#  define FMT\_GCC\_VERSION (\_\_GNUC\_\_ * 100 + \_\_GNUC\_MINOR\_\_)}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#  define FMT\_GCC\_VERSION 0}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{preprocessor}{\#ifndef FMT\_GCC\_PRAGMA}}
\DoxyCodeLine{36 \textcolor{comment}{// Workaround \_Pragma bug https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=59884.}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#  if FMT\_GCC\_VERSION >= 504}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#    define FMT\_GCC\_PRAGMA(arg) \_Pragma(arg)}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#    define FMT\_GCC\_PRAGMA(arg)}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{43 }
\DoxyCodeLine{44 \textcolor{preprocessor}{\#ifdef \_\_ICL}}
\DoxyCodeLine{45 \textcolor{preprocessor}{\#  define FMT\_ICC\_VERSION \_\_ICL}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#elif defined(\_\_INTEL\_COMPILER)}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#  define FMT\_ICC\_VERSION \_\_INTEL\_COMPILER}}
\DoxyCodeLine{48 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{49 \textcolor{preprocessor}{\#  define FMT\_ICC\_VERSION 0}}
\DoxyCodeLine{50 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#  define FMT\_MSC\_VERSION \_MSC\_VER}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#  define FMT\_MSC\_WARNING(...) \_\_pragma(warning(\_\_VA\_ARGS\_\_))}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{56 \textcolor{preprocessor}{\#  define FMT\_MSC\_VERSION 0}}
\DoxyCodeLine{57 \textcolor{preprocessor}{\#  define FMT\_MSC\_WARNING(...)}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{59 }
\DoxyCodeLine{60 \textcolor{preprocessor}{\#ifdef \_MSVC\_LANG}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#  define FMT\_CPLUSPLUS \_MSVC\_LANG}}
\DoxyCodeLine{62 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#  define FMT\_CPLUSPLUS \_\_cplusplus}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{65 }
\DoxyCodeLine{66 \textcolor{preprocessor}{\#ifdef \_\_has\_feature}}
\DoxyCodeLine{67 \textcolor{preprocessor}{\#  define FMT\_HAS\_FEATURE(x) \_\_has\_feature(x)}}
\DoxyCodeLine{68 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{69 \textcolor{preprocessor}{\#  define FMT\_HAS\_FEATURE(x) 0}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{71 }
\DoxyCodeLine{72 \textcolor{preprocessor}{\#if defined(\_\_has\_include) || FMT\_ICC\_VERSION >= 1600 || FMT\_MSC\_VERSION > 1900}}
\DoxyCodeLine{73 \textcolor{preprocessor}{\#  define FMT\_HAS\_INCLUDE(x) \_\_has\_include(x)}}
\DoxyCodeLine{74 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#  define FMT\_HAS\_INCLUDE(x) 0}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{77 }
\DoxyCodeLine{78 \textcolor{preprocessor}{\#ifdef \_\_has\_cpp\_attribute}}
\DoxyCodeLine{79 \textcolor{preprocessor}{\#  define FMT\_HAS\_CPP\_ATTRIBUTE(x) \_\_has\_cpp\_attribute(x)}}
\DoxyCodeLine{80 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{81 \textcolor{preprocessor}{\#  define FMT\_HAS\_CPP\_ATTRIBUTE(x) 0}}
\DoxyCodeLine{82 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84 \textcolor{preprocessor}{\#define FMT\_HAS\_CPP14\_ATTRIBUTE(attribute) \(\backslash\)}}
\DoxyCodeLine{85 \textcolor{preprocessor}{  (FMT\_CPLUSPLUS >= 201402L \&\& FMT\_HAS\_CPP\_ATTRIBUTE(attribute))}}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{preprocessor}{\#define FMT\_HAS\_CPP17\_ATTRIBUTE(attribute) \(\backslash\)}}
\DoxyCodeLine{88 \textcolor{preprocessor}{  (FMT\_CPLUSPLUS >= 201703L \&\& FMT\_HAS\_CPP\_ATTRIBUTE(attribute))}}
\DoxyCodeLine{89 }
\DoxyCodeLine{90 \textcolor{comment}{// Check if relaxed C++14 constexpr is supported.}}
\DoxyCodeLine{91 \textcolor{comment}{// GCC doesn't allow throw in constexpr until version 6 (bug 67371).}}
\DoxyCodeLine{92 \textcolor{preprocessor}{\#ifndef FMT\_USE\_CONSTEXPR}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#  if (FMT\_HAS\_FEATURE(cxx\_relaxed\_constexpr) || FMT\_MSC\_VERSION >= 1912 || \(\backslash\)}}
\DoxyCodeLine{94 \textcolor{preprocessor}{       (FMT\_GCC\_VERSION >= 600 \&\& FMT\_CPLUSPLUS >= 201402L)) \&\&             \(\backslash\)}}
\DoxyCodeLine{95 \textcolor{preprocessor}{      !FMT\_ICC\_VERSION \&\& (!defined(\_\_NVCC\_\_) || FMT\_CPLUSPLUS >= 202002L)}}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#    define FMT\_USE\_CONSTEXPR 1}}
\DoxyCodeLine{97 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{98 \textcolor{preprocessor}{\#    define FMT\_USE\_CONSTEXPR 0}}
\DoxyCodeLine{99 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{100 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{101 \textcolor{preprocessor}{\#if FMT\_USE\_CONSTEXPR}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR constexpr}}
\DoxyCodeLine{103 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107 \textcolor{preprocessor}{\#if ((FMT\_CPLUSPLUS >= 202002L) \&\&                            \(\backslash\)}}
\DoxyCodeLine{108 \textcolor{preprocessor}{     (!defined(\_GLIBCXX\_RELEASE) || \_GLIBCXX\_RELEASE > 9)) || \(\backslash\)}}
\DoxyCodeLine{109 \textcolor{preprocessor}{    (FMT\_CPLUSPLUS >= 201709L \&\& FMT\_GCC\_VERSION >= 1002)}}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR20 constexpr}}
\DoxyCodeLine{111 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{112 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR20}}
\DoxyCodeLine{113 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{comment}{// Check if constexpr std::char\_traits<>::\{compare,length\} are supported.}}
\DoxyCodeLine{116 \textcolor{preprocessor}{\#if defined(\_\_GLIBCXX\_\_)}}
\DoxyCodeLine{117 \textcolor{preprocessor}{\#  if FMT\_CPLUSPLUS >= 201703L \&\& defined(\_GLIBCXX\_RELEASE) \&\& \(\backslash\)}}
\DoxyCodeLine{118 \textcolor{preprocessor}{      \_GLIBCXX\_RELEASE >= 7  }\textcolor{comment}{// GCC 7+ libstdc++ has \_GLIBCXX\_RELEASE.}}
\DoxyCodeLine{119 \textcolor{preprocessor}{\#    define FMT\_CONSTEXPR\_CHAR\_TRAITS constexpr}}
\DoxyCodeLine{120 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{121 \textcolor{preprocessor}{\#elif defined(\_LIBCPP\_VERSION) \&\& FMT\_CPLUSPLUS >= 201703L \&\& \(\backslash\)}}
\DoxyCodeLine{122 \textcolor{preprocessor}{    \_LIBCPP\_VERSION >= 4000}}
\DoxyCodeLine{123 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR\_CHAR\_TRAITS constexpr}}
\DoxyCodeLine{124 \textcolor{preprocessor}{\#elif FMT\_MSC\_VERSION >= 1914 \&\& FMT\_CPLUSPLUS >= 201703L}}
\DoxyCodeLine{125 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR\_CHAR\_TRAITS constexpr}}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#ifndef FMT\_CONSTEXPR\_CHAR\_TRAITS}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#  define FMT\_CONSTEXPR\_CHAR\_TRAITS}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{130 }
\DoxyCodeLine{131 \textcolor{comment}{// Check if exceptions are disabled.}}
\DoxyCodeLine{132 \textcolor{preprocessor}{\#ifndef FMT\_EXCEPTIONS}}
\DoxyCodeLine{133 \textcolor{preprocessor}{\#  if (defined(\_\_GNUC\_\_) \&\& !defined(\_\_EXCEPTIONS)) || \(\backslash\)}}
\DoxyCodeLine{134 \textcolor{preprocessor}{      (FMT\_MSC\_VERSION \&\& !\_HAS\_EXCEPTIONS)}}
\DoxyCodeLine{135 \textcolor{preprocessor}{\#    define FMT\_EXCEPTIONS 0}}
\DoxyCodeLine{136 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#    define FMT\_EXCEPTIONS 1}}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{140 }
\DoxyCodeLine{141 \textcolor{comment}{// Disable [[noreturn]] on MSVC/NVCC because of bogus unreachable code warnings.}}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#if FMT\_EXCEPTIONS \&\& FMT\_HAS\_CPP\_ATTRIBUTE(noreturn) \&\& !FMT\_MSC\_VERSION \&\& \(\backslash\)}}
\DoxyCodeLine{143 \textcolor{preprocessor}{    !defined(\_\_NVCC\_\_)}}
\DoxyCodeLine{144 \textcolor{preprocessor}{\#  define FMT\_NORETURN [[noreturn]]}}
\DoxyCodeLine{145 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{146 \textcolor{preprocessor}{\#  define FMT\_NORETURN}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 \textcolor{preprocessor}{\#ifndef FMT\_NODISCARD}}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#  if FMT\_HAS\_CPP17\_ATTRIBUTE(nodiscard)}}
\DoxyCodeLine{151 \textcolor{preprocessor}{\#    define FMT\_NODISCARD [[nodiscard]]}}
\DoxyCodeLine{152 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{153 \textcolor{preprocessor}{\#    define FMT\_NODISCARD}}
\DoxyCodeLine{154 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{155 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{preprocessor}{\#ifndef FMT\_INLINE}}
\DoxyCodeLine{158 \textcolor{preprocessor}{\#  if FMT\_GCC\_VERSION || FMT\_CLANG\_VERSION}}
\DoxyCodeLine{159 \textcolor{preprocessor}{\#    define FMT\_INLINE inline \_\_attribute\_\_((always\_inline))}}
\DoxyCodeLine{160 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{161 \textcolor{preprocessor}{\#    define FMT\_INLINE inline}}
\DoxyCodeLine{162 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{163 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{164 }
\DoxyCodeLine{165 \textcolor{preprocessor}{\#ifdef \_MSC\_VER}}
\DoxyCodeLine{166 \textcolor{preprocessor}{\#  define FMT\_UNCHECKED\_ITERATOR(It) \(\backslash\)}}
\DoxyCodeLine{167 \textcolor{preprocessor}{    using \_Unchecked\_type = It  }\textcolor{comment}{// Mark iterator as checked.}}
\DoxyCodeLine{168 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{169 \textcolor{preprocessor}{\#  define FMT\_UNCHECKED\_ITERATOR(It) using unchecked\_type = It}}
\DoxyCodeLine{170 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{171 }
\DoxyCodeLine{172 \textcolor{preprocessor}{\#ifndef FMT\_BEGIN\_NAMESPACE}}
\DoxyCodeLine{173 \textcolor{preprocessor}{\#  define FMT\_BEGIN\_NAMESPACE \(\backslash\)}}
\DoxyCodeLine{174 \textcolor{preprocessor}{    namespace fmt \{           \(\backslash\)}}
\DoxyCodeLine{175 \textcolor{preprocessor}{    inline namespace v10 \{}}
\DoxyCodeLine{176 \textcolor{preprocessor}{\#  define FMT\_END\_NAMESPACE \(\backslash\)}}
\DoxyCodeLine{177 \textcolor{preprocessor}{    \}                       \(\backslash\)}}
\DoxyCodeLine{178 \textcolor{preprocessor}{    \}}}
\DoxyCodeLine{179 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{preprocessor}{\#ifndef FMT\_EXPORT}}
\DoxyCodeLine{182 \textcolor{preprocessor}{\#  define FMT\_EXPORT}}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#  define FMT\_BEGIN\_EXPORT}}
\DoxyCodeLine{184 \textcolor{preprocessor}{\#  define FMT\_END\_EXPORT}}
\DoxyCodeLine{185 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{preprocessor}{\#if !defined(FMT\_HEADER\_ONLY) \&\& defined(\_WIN32)}}
\DoxyCodeLine{188 \textcolor{preprocessor}{\#  ifdef FMT\_LIB\_EXPORT}}
\DoxyCodeLine{189 \textcolor{preprocessor}{\#    define FMT\_API \_\_declspec(dllexport)}}
\DoxyCodeLine{190 \textcolor{preprocessor}{\#  elif defined(FMT\_SHARED)}}
\DoxyCodeLine{191 \textcolor{preprocessor}{\#    define FMT\_API \_\_declspec(dllimport)}}
\DoxyCodeLine{192 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{193 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{194 \textcolor{preprocessor}{\#  if defined(FMT\_LIB\_EXPORT) || defined(FMT\_SHARED)}}
\DoxyCodeLine{195 \textcolor{preprocessor}{\#    if defined(\_\_GNUC\_\_) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#      define FMT\_API \_\_attribute\_\_((visibility("{}default"{}})))}
\DoxyCodeLine{197 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{198 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{199 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{200 \textcolor{preprocessor}{\#ifndef FMT\_API}}
\DoxyCodeLine{201 \textcolor{preprocessor}{\#  define FMT\_API}}
\DoxyCodeLine{202 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{203 }
\DoxyCodeLine{204 \textcolor{comment}{// libc++ supports string\_view in pre-\/c++17.}}
\DoxyCodeLine{205 \textcolor{preprocessor}{\#if FMT\_HAS\_INCLUDE(<string\_view>) \&\& \(\backslash\)}}
\DoxyCodeLine{206 \textcolor{preprocessor}{    (FMT\_CPLUSPLUS >= 201703L || defined(\_LIBCPP\_VERSION))}}
\DoxyCodeLine{207 \textcolor{preprocessor}{\#  include <string\_view>}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#  define FMT\_USE\_STRING\_VIEW}}
\DoxyCodeLine{209 \textcolor{preprocessor}{\#elif FMT\_HAS\_INCLUDE("{}experimental/string\_view"{}}) \&\& FMT\_CPLUSPLUS >= 201402L}
\DoxyCodeLine{210 \textcolor{preprocessor}{\#  include <experimental/string\_view>}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\#  define FMT\_USE\_EXPERIMENTAL\_STRING\_VIEW}}
\DoxyCodeLine{212 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{213 }
\DoxyCodeLine{214 \textcolor{preprocessor}{\#ifndef FMT\_UNICODE}}
\DoxyCodeLine{215 \textcolor{preprocessor}{\#  define FMT\_UNICODE !FMT\_MSC\_VERSION}}
\DoxyCodeLine{216 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{217 }
\DoxyCodeLine{218 \textcolor{preprocessor}{\#ifndef FMT\_CONSTEVAL}}
\DoxyCodeLine{219 \textcolor{preprocessor}{\#  if ((FMT\_GCC\_VERSION >= 1000 || FMT\_CLANG\_VERSION >= 1101) \&\& \(\backslash\)}}
\DoxyCodeLine{220 \textcolor{preprocessor}{       (!defined(\_\_apple\_build\_version\_\_) ||                     \(\backslash\)}}
\DoxyCodeLine{221 \textcolor{preprocessor}{        \_\_apple\_build\_version\_\_ >= 14000029L) \&\&                 \(\backslash\)}}
\DoxyCodeLine{222 \textcolor{preprocessor}{       FMT\_CPLUSPLUS >= 202002L) ||                              \(\backslash\)}}
\DoxyCodeLine{223 \textcolor{preprocessor}{      (defined(\_\_cpp\_consteval) \&\&                               \(\backslash\)}}
\DoxyCodeLine{224 \textcolor{preprocessor}{       (!FMT\_MSC\_VERSION || \_MSC\_FULL\_VER >= 193030704))}}
\DoxyCodeLine{225 \textcolor{comment}{// consteval is broken in MSVC before VS2022 and Apple clang before 14.}}
\DoxyCodeLine{226 \textcolor{preprocessor}{\#    define FMT\_CONSTEVAL consteval}}
\DoxyCodeLine{227 \textcolor{preprocessor}{\#    define FMT\_HAS\_CONSTEVAL}}
\DoxyCodeLine{228 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{229 \textcolor{preprocessor}{\#    define FMT\_CONSTEVAL}}
\DoxyCodeLine{230 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{231 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{232 }
\DoxyCodeLine{233 \textcolor{preprocessor}{\#ifndef FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{234 \textcolor{preprocessor}{\#  if defined(\_\_cpp\_nontype\_template\_args) \&\&                  \(\backslash\)}}
\DoxyCodeLine{235 \textcolor{preprocessor}{      ((FMT\_GCC\_VERSION >= 903 \&\& FMT\_CPLUSPLUS >= 201709L) || \(\backslash\)}}
\DoxyCodeLine{236 \textcolor{preprocessor}{       \_\_cpp\_nontype\_template\_args >= 201911L) \&\&              \(\backslash\)}}
\DoxyCodeLine{237 \textcolor{preprocessor}{      !defined(\_\_NVCOMPILER) \&\& !defined(\_\_LCC\_\_)}}
\DoxyCodeLine{238 \textcolor{preprocessor}{\#    define FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS 1}}
\DoxyCodeLine{239 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{240 \textcolor{preprocessor}{\#    define FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS 0}}
\DoxyCodeLine{241 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{242 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{243 }
\DoxyCodeLine{244 \textcolor{comment}{// Enable minimal optimizations for more compact code in debug mode.}}
\DoxyCodeLine{245 FMT\_GCC\_PRAGMA(\textcolor{stringliteral}{"{}GCC push\_options"{}})}
\DoxyCodeLine{246 \textcolor{preprocessor}{\#if !defined(\_\_OPTIMIZE\_\_) \&\& !defined(\_\_NVCOMPILER) \&\& !defined(\_\_LCC\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{247 \textcolor{preprocessor}{    !defined(\_\_CUDACC\_\_)}}
\DoxyCodeLine{248 FMT\_GCC\_PRAGMA(\textcolor{stringliteral}{"{}GCC optimize(\(\backslash\)"{}Og\(\backslash\)"{})"{}})}
\DoxyCodeLine{249 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{250 }
\DoxyCodeLine{251 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{252 }
\DoxyCodeLine{253 \textcolor{comment}{// Implementations of enable\_if\_t and other metafunctions for older systems.}}
\DoxyCodeLine{254 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B, \textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{255 \textcolor{keyword}{using }enable\_if\_t = \textcolor{keyword}{typename} std::enable\_if<B, T>::type;}
\DoxyCodeLine{256 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{257 \textcolor{keyword}{using }conditional\_t = \textcolor{keyword}{typename} std::conditional<B, T, F>::type;}
\DoxyCodeLine{258 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B> \textcolor{keyword}{using }bool\_constant = std::integral\_constant<bool, B>;}
\DoxyCodeLine{259 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{260 \textcolor{keyword}{using }remove\_reference\_t = \textcolor{keyword}{typename} std::remove\_reference<T>::type;}
\DoxyCodeLine{261 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{262 \textcolor{keyword}{using }remove\_const\_t = \textcolor{keyword}{typename} std::remove\_const<T>::type;}
\DoxyCodeLine{263 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{264 \textcolor{keyword}{using }remove\_cvref\_t = \textcolor{keyword}{typename} std::remove\_cv<remove\_reference\_t<T>>::type;}
\DoxyCodeLine{265 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structtype__identity}{type\_identity}} \{ \textcolor{keyword}{using }type = T; \};}
\DoxyCodeLine{266 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }type\_identity\_t = \textcolor{keyword}{typename} type\_identity<T>::type;}
\DoxyCodeLine{267 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{268 \textcolor{keyword}{using }underlying\_t = \textcolor{keyword}{typename} std::underlying\_type<T>::type;}
\DoxyCodeLine{269 }
\DoxyCodeLine{270 \textcolor{comment}{// Checks whether T is a container with contiguous storage.}}
\DoxyCodeLine{271 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structis__contiguous}{is\_contiguous}} : std::false\_type \{\};}
\DoxyCodeLine{272 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{273 \textcolor{keyword}{struct }\mbox{\hyperlink{structis__contiguous}{is\_contiguous}}<std::basic\_string<Char>> : std::true\_type \{\};}
\DoxyCodeLine{274 }
\DoxyCodeLine{275 \textcolor{keyword}{struct }\mbox{\hyperlink{structmonostate}{monostate}} \{}
\DoxyCodeLine{276   \textcolor{keyword}{constexpr} \mbox{\hyperlink{structmonostate}{monostate}}() \{\}}
\DoxyCodeLine{277 \};}
\DoxyCodeLine{278 }
\DoxyCodeLine{279 \textcolor{comment}{// An enable\_if helper to be used in template parameters which results in much}}
\DoxyCodeLine{280 \textcolor{comment}{// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed}}
\DoxyCodeLine{281 \textcolor{comment}{// to workaround a bug in MSVC 2019 (see \#1140 and \#1186).}}
\DoxyCodeLine{282 \textcolor{preprocessor}{\#ifdef FMT\_DOC}}
\DoxyCodeLine{283 \textcolor{preprocessor}{\#  define FMT\_ENABLE\_IF(...)}}
\DoxyCodeLine{284 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{285 \textcolor{preprocessor}{\#  define FMT\_ENABLE\_IF(...) fmt::enable\_if\_t<(\_\_VA\_ARGS\_\_), int> = 0}}
\DoxyCodeLine{286 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{287 }
\DoxyCodeLine{288 \textcolor{comment}{// This is defined in core.h instead of format.h to avoid injecting in std.}}
\DoxyCodeLine{289 \textcolor{comment}{// It is a template to avoid undesirable implicit conversions to std::byte.}}
\DoxyCodeLine{290 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_byte}}
\DoxyCodeLine{291 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_same<T, std::\textcolor{keywordtype}{byte}>::value)>}
\DoxyCodeLine{292 \textcolor{keyword}{inline} \textcolor{keyword}{auto} format\_as(T b) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{293   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(b);}
\DoxyCodeLine{294 \}}
\DoxyCodeLine{295 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{298 \textcolor{comment}{// Suppresses "{}unused variable"{} warnings with the method described in}}
\DoxyCodeLine{299 \textcolor{comment}{// https://herbsutter.com/2009/10/18/mailbag-\/shutting-\/up-\/compiler-\/warnings/.}}
\DoxyCodeLine{300 \textcolor{comment}{// (void)var does not work on many Intel compilers.}}
\DoxyCodeLine{301 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T> FMT\_CONSTEXPR \textcolor{keywordtype}{void} ignore\_unused(\textcolor{keyword}{const} T\&...) \{\}}
\DoxyCodeLine{302 }
\DoxyCodeLine{303 \textcolor{keyword}{constexpr} FMT\_INLINE \textcolor{keyword}{auto} is\_constant\_evaluated(}
\DoxyCodeLine{304     \textcolor{keywordtype}{bool} default\_value = \textcolor{keyword}{false}) noexcept -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{305 \textcolor{comment}{// Workaround for incompatibility between libstdc++ consteval-\/based}}
\DoxyCodeLine{306 \textcolor{comment}{// std::is\_constant\_evaluated() implementation and clang-\/14.}}
\DoxyCodeLine{307 \textcolor{comment}{// https://github.com/fmtlib/fmt/issues/3247}}
\DoxyCodeLine{308 \textcolor{preprocessor}{\#if FMT\_CPLUSPLUS >= 202002L \&\& defined(\_GLIBCXX\_RELEASE) \&\& \(\backslash\)}}
\DoxyCodeLine{309 \textcolor{preprocessor}{    \_GLIBCXX\_RELEASE >= 12 \&\&                                \(\backslash\)}}
\DoxyCodeLine{310 \textcolor{preprocessor}{    (FMT\_CLANG\_VERSION >= 1400 \&\& FMT\_CLANG\_VERSION < 1500)}}
\DoxyCodeLine{311   ignore\_unused(default\_value);}
\DoxyCodeLine{312   \textcolor{keywordflow}{return} \_\_builtin\_is\_constant\_evaluated();}
\DoxyCodeLine{313 \textcolor{preprocessor}{\#elif defined(\_\_cpp\_lib\_is\_constant\_evaluated)}}
\DoxyCodeLine{314   ignore\_unused(default\_value);}
\DoxyCodeLine{315   \textcolor{keywordflow}{return} std::is\_constant\_evaluated();}
\DoxyCodeLine{316 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{317   \textcolor{keywordflow}{return} default\_value;}
\DoxyCodeLine{318 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{319 \}}
\DoxyCodeLine{320 }
\DoxyCodeLine{321 \textcolor{comment}{// Suppresses "{}conditional expression is constant"{} warnings.}}
\DoxyCodeLine{322 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} FMT\_INLINE \textcolor{keyword}{auto} const\_check(T value) -\/> T \{}
\DoxyCodeLine{323   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{324 \}}
\DoxyCodeLine{325 }
\DoxyCodeLine{326 FMT\_NORETURN FMT\_API \textcolor{keywordtype}{void} assert\_fail(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* file, \textcolor{keywordtype}{int} line,}
\DoxyCodeLine{327                                       \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message);}
\DoxyCodeLine{328 }
\DoxyCodeLine{329 \textcolor{preprocessor}{\#ifndef FMT\_ASSERT}}
\DoxyCodeLine{330 \textcolor{preprocessor}{\#  ifdef NDEBUG}}
\DoxyCodeLine{331 \textcolor{comment}{// FMT\_ASSERT is not empty to avoid -\/Wempty-\/body.}}
\DoxyCodeLine{332 \textcolor{preprocessor}{\#    define FMT\_ASSERT(condition, message) \(\backslash\)}}
\DoxyCodeLine{333 \textcolor{preprocessor}{      fmt::detail::ignore\_unused((condition), (message))}}
\DoxyCodeLine{334 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{335 \textcolor{preprocessor}{\#    define FMT\_ASSERT(condition, message)                                    \(\backslash\)}}
\DoxyCodeLine{336 \textcolor{preprocessor}{      ((condition) }\textcolor{comment}{/* void() fails with -\/Winvalid-\/constexpr on clang 4.0.1 */}\textcolor{preprocessor}{ \(\backslash\)}}
\DoxyCodeLine{337 \textcolor{preprocessor}{           ? (void)0                                                          \(\backslash\)}}
\DoxyCodeLine{338 \textcolor{preprocessor}{           : fmt::detail::assert\_fail(\_\_FILE\_\_, \_\_LINE\_\_, (message)))}}
\DoxyCodeLine{339 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{340 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{341 }
\DoxyCodeLine{342 \textcolor{preprocessor}{\#if defined(FMT\_USE\_STRING\_VIEW)}}
\DoxyCodeLine{343 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{using }std\_string\_view = std::basic\_string\_view<Char>;}
\DoxyCodeLine{344 \textcolor{preprocessor}{\#elif defined(FMT\_USE\_EXPERIMENTAL\_STRING\_VIEW)}}
\DoxyCodeLine{345 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{346 \textcolor{keyword}{using }std\_string\_view = std::experimental::basic\_string\_view<Char>;}
\DoxyCodeLine{347 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{348 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1std__string__view}{std\_string\_view}} \{\};}
\DoxyCodeLine{349 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 \textcolor{preprocessor}{\#ifdef FMT\_USE\_INT128}}
\DoxyCodeLine{352 \textcolor{comment}{// Do nothing.}}
\DoxyCodeLine{353 \textcolor{preprocessor}{\#elif defined(\_\_SIZEOF\_INT128\_\_) \&\& !defined(\_\_NVCC\_\_) \&\& \(\backslash\)}}
\DoxyCodeLine{354 \textcolor{preprocessor}{    !(FMT\_CLANG\_VERSION \&\& FMT\_MSC\_VERSION)}}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#  define FMT\_USE\_INT128 1}}
\DoxyCodeLine{356 \textcolor{keyword}{using }int128\_opt = \_\_int128\_t;  \textcolor{comment}{// An optional native 128-\/bit integer.}}
\DoxyCodeLine{357 \textcolor{keyword}{using }uint128\_opt = \_\_uint128\_t;}
\DoxyCodeLine{358 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{inline} \textcolor{keyword}{auto} convert\_for\_visit(T \mbox{\hyperlink{classdetail_1_1value}{value}}) -\/> T \{}
\DoxyCodeLine{359   \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1value}{value}};}
\DoxyCodeLine{360 \}}
\DoxyCodeLine{361 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{362 \textcolor{preprocessor}{\#  define FMT\_USE\_INT128 0}}
\DoxyCodeLine{363 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#if !FMT\_USE\_INT128}}
\DoxyCodeLine{365 \textcolor{keyword}{enum class} int128\_opt \{\};}
\DoxyCodeLine{366 \textcolor{keyword}{enum class} uint128\_opt \{\};}
\DoxyCodeLine{367 \textcolor{comment}{// Reduce template instantiations.}}
\DoxyCodeLine{368 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} convert\_for\_visit(T) -\/> \mbox{\hyperlink{structmonostate}{monostate}} \{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{369 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{370 }
\DoxyCodeLine{371 \textcolor{comment}{// Casts a nonnegative integer to unsigned.}}
\DoxyCodeLine{372 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int>}
\DoxyCodeLine{373 FMT\_CONSTEXPR \textcolor{keyword}{auto} to\_unsigned(Int value) -\/>}
\DoxyCodeLine{374     \textcolor{keyword}{typename} std::make\_unsigned<Int>::type \{}
\DoxyCodeLine{375   FMT\_ASSERT(std::is\_unsigned<Int>::value || value >= 0, \textcolor{stringliteral}{"{}negative value"{}});}
\DoxyCodeLine{376   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}typename std::make\_unsigned<Int>::type\textcolor{keyword}{>}(value);}
\DoxyCodeLine{377 \}}
\DoxyCodeLine{378 }
\DoxyCodeLine{379 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} is\_utf8() -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{380   FMT\_MSC\_WARNING(suppress : 4566) \textcolor{keyword}{constexpr} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} section[] = \textcolor{stringliteral}{"{}\(\backslash\)u00A7"{}};}
\DoxyCodeLine{381 }
\DoxyCodeLine{382   \textcolor{comment}{// Avoid buggy sign extensions in MSVC's constant evaluation mode (\#2297).}}
\DoxyCodeLine{383   \textcolor{keyword}{using }uchar = \textcolor{keywordtype}{unsigned} char;}
\DoxyCodeLine{384   \textcolor{keywordflow}{return} FMT\_UNICODE || (\textcolor{keyword}{sizeof}(section) == 3 \&\& uchar(section[0]) == 0xC2 \&\&}
\DoxyCodeLine{385                          uchar(section[1]) == 0xA7);}
\DoxyCodeLine{386 \}}
\DoxyCodeLine{387 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{388 }
\DoxyCodeLine{396 FMT\_EXPORT}
\DoxyCodeLine{397 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} \{}
\DoxyCodeLine{398  \textcolor{keyword}{private}:}
\DoxyCodeLine{399   \textcolor{keyword}{const} Char* data\_;}
\DoxyCodeLine{400   \textcolor{keywordtype}{size\_t} size\_;}
\DoxyCodeLine{401 }
\DoxyCodeLine{402  \textcolor{keyword}{public}:}
\DoxyCodeLine{403   \textcolor{keyword}{using }value\_type = Char;}
\DoxyCodeLine{404   \textcolor{keyword}{using }iterator = \textcolor{keyword}{const} Char*;}
\DoxyCodeLine{405 }
\DoxyCodeLine{406   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}() noexcept : data\_(\textcolor{keyword}{nullptr}), size\_(0) \{\}}
\DoxyCodeLine{407 }
\DoxyCodeLine{409   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__string__view_aae708273ca864680a424c10441799605}{basic\_string\_view}}(\textcolor{keyword}{const} Char* s, \textcolor{keywordtype}{size\_t} count) noexcept}
\DoxyCodeLine{410       : data\_(s), size\_(count) \{\}}
\DoxyCodeLine{411 }
\DoxyCodeLine{418   FMT\_CONSTEXPR\_CHAR\_TRAITS}
\DoxyCodeLine{419   FMT\_INLINE}
\DoxyCodeLine{420   \mbox{\hyperlink{classbasic__string__view_a961254412253f97e1273cdaacb1af1a3}{basic\_string\_view}}(\textcolor{keyword}{const} Char* s)}
\DoxyCodeLine{421       : data\_(s),}
\DoxyCodeLine{422         size\_(detail::const\_check(std::is\_same<Char, char>::value \&\&}
\DoxyCodeLine{423                                   !detail::is\_constant\_evaluated(true))}
\DoxyCodeLine{424                   ? std::strlen(reinterpret\_cast<const char*>(s))}
\DoxyCodeLine{425                   : std::char\_traits<Char>::length(s)) \{\}}
\DoxyCodeLine{426 }
\DoxyCodeLine{428   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Traits, \textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{429   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view_a05e308de94ccd7f6203ba3ea94f68ebd}{basic\_string\_view}}(}
\DoxyCodeLine{430       \textcolor{keyword}{const} std::basic\_string<Char, Traits, Alloc>\& s) noexcept}
\DoxyCodeLine{431       : data\_(s.data()), size\_(s.size()) \{\}}
\DoxyCodeLine{432 }
\DoxyCodeLine{433   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, FMT\_ENABLE\_IF(std::is\_same<}
\DoxyCodeLine{434                                       S, \mbox{\hyperlink{structdetail_1_1std__string__view}{detail::std\_string\_view<Char>}}>::value)>}
\DoxyCodeLine{435   FMT\_CONSTEXPR \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}(S s) noexcept}
\DoxyCodeLine{436       : data\_(s.data()), size\_(s.size()) \{\}}
\DoxyCodeLine{437 }
\DoxyCodeLine{439   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}() const noexcept -\/> const Char* \{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{440 }
\DoxyCodeLine{442   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() const noexcept -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{443 }
\DoxyCodeLine{444   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} begin() const noexcept -\/> iterator \{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{445   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} end() const noexcept -\/> iterator \{ \textcolor{keywordflow}{return} data\_ + size\_; \}}
\DoxyCodeLine{446 }
\DoxyCodeLine{447   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator[](\textcolor{keywordtype}{size\_t} pos) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} -\/> \textcolor{keyword}{const} Char\& \{}
\DoxyCodeLine{448     \textcolor{keywordflow}{return} data\_[pos];}
\DoxyCodeLine{449   \}}
\DoxyCodeLine{450 }
\DoxyCodeLine{451   FMT\_CONSTEXPR \textcolor{keywordtype}{void} remove\_prefix(\textcolor{keywordtype}{size\_t} n) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{452     data\_ += n;}
\DoxyCodeLine{453     size\_ -\/= n;}
\DoxyCodeLine{454   \}}
\DoxyCodeLine{455 }
\DoxyCodeLine{456   FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keywordtype}{bool} starts\_with(}
\DoxyCodeLine{457       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sv) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{458     \textcolor{keywordflow}{return} size\_ >= sv.size\_ \&\&}
\DoxyCodeLine{459            std::char\_traits<Char>::compare(data\_, sv.data\_, sv.size\_) == 0;}
\DoxyCodeLine{460   \}}
\DoxyCodeLine{461   FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keywordtype}{bool} starts\_with(Char c) \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{462     \textcolor{keywordflow}{return} size\_ >= 1 \&\& std::char\_traits<Char>::eq(*data\_, c);}
\DoxyCodeLine{463   \}}
\DoxyCodeLine{464   FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keywordtype}{bool} starts\_with(\textcolor{keyword}{const} Char* s)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{465     \textcolor{keywordflow}{return} starts\_with(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(s));}
\DoxyCodeLine{466   \}}
\DoxyCodeLine{467 }
\DoxyCodeLine{468   \textcolor{comment}{// Lexicographically compare this string reference to other.}}
\DoxyCodeLine{469   FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keyword}{auto} compare(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} other) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{470     \textcolor{keywordtype}{size\_t} str\_size = size\_ < other.size\_ ? size\_ : other.size\_;}
\DoxyCodeLine{471     \textcolor{keywordtype}{int} result = std::char\_traits<Char>::compare(data\_, other.data\_, str\_size);}
\DoxyCodeLine{472     \textcolor{keywordflow}{if} (result == 0)}
\DoxyCodeLine{473       result = size\_ == other.size\_ ? 0 : (size\_ < other.size\_ ? -\/1 : 1);}
\DoxyCodeLine{474     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{475   \}}
\DoxyCodeLine{476 }
\DoxyCodeLine{477   FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator==(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs,}
\DoxyCodeLine{478                                                    \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs)}
\DoxyCodeLine{479       -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{480     \textcolor{keywordflow}{return} lhs.compare(rhs) == 0;}
\DoxyCodeLine{481   \}}
\DoxyCodeLine{482   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator!=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{483     \textcolor{keywordflow}{return} lhs.compare(rhs) != 0;}
\DoxyCodeLine{484   \}}
\DoxyCodeLine{485   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{486     \textcolor{keywordflow}{return} lhs.compare(rhs) < 0;}
\DoxyCodeLine{487   \}}
\DoxyCodeLine{488   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator<=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{489     \textcolor{keywordflow}{return} lhs.compare(rhs) <= 0;}
\DoxyCodeLine{490   \}}
\DoxyCodeLine{491   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator>(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{492     \textcolor{keywordflow}{return} lhs.compare(rhs) > 0;}
\DoxyCodeLine{493   \}}
\DoxyCodeLine{494   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator>=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} lhs, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}} rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{495     \textcolor{keywordflow}{return} lhs.compare(rhs) >= 0;}
\DoxyCodeLine{496   \}}
\DoxyCodeLine{497 \};}
\DoxyCodeLine{498 }
\DoxyCodeLine{499 FMT\_EXPORT}
\DoxyCodeLine{500 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__string__view}{string\_view}} = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char>}};}
\DoxyCodeLine{501 }
\DoxyCodeLine{503 FMT\_EXPORT}
\DoxyCodeLine{504 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structis__char}{is\_char}} : std::false\_type \{\};}
\DoxyCodeLine{505 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structis__char}{is\_char}}<char> : std::true\_type \{\};}
\DoxyCodeLine{506 }
\DoxyCodeLine{507 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{508 }
\DoxyCodeLine{509 \textcolor{comment}{// A base class for compile-\/time strings.}}
\DoxyCodeLine{510 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1compile__string}{compile\_string}} \{\};}
\DoxyCodeLine{511 }
\DoxyCodeLine{512 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{513 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__compile__string}{is\_compile\_string}} : std::is\_base\_of<compile\_string, S> \{\};}
\DoxyCodeLine{514 }
\DoxyCodeLine{515 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{char}<Char>::value)>}
\DoxyCodeLine{516 FMT\_INLINE \textcolor{keyword}{auto} to\_string\_view(\textcolor{keyword}{const} Char* s) -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{517   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{518 \}}
\DoxyCodeLine{519 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Traits, \textcolor{keyword}{typename} Alloc>}
\DoxyCodeLine{520 \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string\_view(\textcolor{keyword}{const} std::basic\_string<Char, Traits, Alloc>\& s)}
\DoxyCodeLine{521     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{522   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{523 \}}
\DoxyCodeLine{524 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{525 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_string\_view(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s)}
\DoxyCodeLine{526     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{527   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{528 \}}
\DoxyCodeLine{529 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char,}
\DoxyCodeLine{530           FMT\_ENABLE\_IF(!std::is\_empty<std\_string\_view<Char>>::value)>}
\DoxyCodeLine{531 \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string\_view(std\_string\_view<Char> s) -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{532   \textcolor{keywordflow}{return} s;}
\DoxyCodeLine{533 \}}
\DoxyCodeLine{534 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, FMT\_ENABLE\_IF(is\_compile\_\textcolor{keywordtype}{string}<S>::value)>}
\DoxyCodeLine{535 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_string\_view(\textcolor{keyword}{const} S\& s)}
\DoxyCodeLine{536     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}} \{}
\DoxyCodeLine{537   \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename S::char\_type>}}(s);}
\DoxyCodeLine{538 \}}
\DoxyCodeLine{539 \textcolor{keywordtype}{void} to\_string\_view(...);}
\DoxyCodeLine{540 }
\DoxyCodeLine{541 \textcolor{comment}{// Specifies whether S is a string type convertible to fmt::basic\_string\_view.}}
\DoxyCodeLine{542 \textcolor{comment}{// It should be a constexpr function but MSVC 2017 fails to compile it in}}
\DoxyCodeLine{543 \textcolor{comment}{// enable\_if and MSVC 2015 fails to compile it as an alias template.}}
\DoxyCodeLine{544 \textcolor{comment}{// ADL is intentionally disabled as to\_string\_view is not an extension point.}}
\DoxyCodeLine{545 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S>}
\DoxyCodeLine{546 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__string}{is\_string}}}
\DoxyCodeLine{547     : std::is\_class<decltype(detail::to\_string\_view(std::declval<S>()))> \{\};}
\DoxyCodeLine{548 }
\DoxyCodeLine{549 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1char__t__impl}{char\_t\_impl}} \{\};}
\DoxyCodeLine{550 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1char__t__impl}{char\_t\_impl}}<S, enable\_if\_t<\mbox{\hyperlink{structdetail_1_1is__string}{is\_string}}<S>::\mbox{\hyperlink{classdetail_1_1value}{value}}>> \{}
\DoxyCodeLine{551   \textcolor{keyword}{using }result = \textcolor{keyword}{decltype}(to\_string\_view(std::declval<S>()));}
\DoxyCodeLine{552   \textcolor{keyword}{using }type = \textcolor{keyword}{typename} result::value\_type;}
\DoxyCodeLine{553 \};}
\DoxyCodeLine{554 }
\DoxyCodeLine{555 \textcolor{keyword}{enum class} type \{}
\DoxyCodeLine{556   none\_type,}
\DoxyCodeLine{557   \textcolor{comment}{// Integer types should go first,}}
\DoxyCodeLine{558   int\_type,}
\DoxyCodeLine{559   uint\_type,}
\DoxyCodeLine{560   long\_long\_type,}
\DoxyCodeLine{561   ulong\_long\_type,}
\DoxyCodeLine{562   int128\_type,}
\DoxyCodeLine{563   uint128\_type,}
\DoxyCodeLine{564   bool\_type,}
\DoxyCodeLine{565   char\_type,}
\DoxyCodeLine{566   last\_integer\_type = char\_type,}
\DoxyCodeLine{567   \textcolor{comment}{// followed by floating-\/point types.}}
\DoxyCodeLine{568   float\_type,}
\DoxyCodeLine{569   double\_type,}
\DoxyCodeLine{570   long\_double\_type,}
\DoxyCodeLine{571   last\_numeric\_type = long\_double\_type,}
\DoxyCodeLine{572   cstring\_type,}
\DoxyCodeLine{573   string\_type,}
\DoxyCodeLine{574   pointer\_type,}
\DoxyCodeLine{575   custom\_type}
\DoxyCodeLine{576 \};}
\DoxyCodeLine{577 }
\DoxyCodeLine{578 \textcolor{comment}{// Maps core type T to the corresponding type enum constant.}}
\DoxyCodeLine{579 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{580 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1type__constant}{type\_constant}} : std::integral\_constant<type, type::custom\_type> \{\};}
\DoxyCodeLine{581 }
\DoxyCodeLine{582 \textcolor{preprocessor}{\#define FMT\_TYPE\_CONSTANT(Type, constant) \(\backslash\)}}
\DoxyCodeLine{583 \textcolor{preprocessor}{  template <typename Char>                \(\backslash\)}}
\DoxyCodeLine{584 \textcolor{preprocessor}{  struct type\_constant<Type, Char>        \(\backslash\)}}
\DoxyCodeLine{585 \textcolor{preprocessor}{      : std::integral\_constant<type, type::constant> \{\}}}
\DoxyCodeLine{586 }
\DoxyCodeLine{587 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{int}, int\_type);}
\DoxyCodeLine{588 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{unsigned}, uint\_type);}
\DoxyCodeLine{589 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, long\_long\_type);}
\DoxyCodeLine{590 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}, ulong\_long\_type);}
\DoxyCodeLine{591 FMT\_TYPE\_CONSTANT(int128\_opt, int128\_type);}
\DoxyCodeLine{592 FMT\_TYPE\_CONSTANT(uint128\_opt, uint128\_type);}
\DoxyCodeLine{593 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{bool}, bool\_type);}
\DoxyCodeLine{594 FMT\_TYPE\_CONSTANT(Char, char\_type);}
\DoxyCodeLine{595 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{float}, float\_type);}
\DoxyCodeLine{596 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{double}, double\_type);}
\DoxyCodeLine{597 FMT\_TYPE\_CONSTANT(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double}, long\_double\_type);}
\DoxyCodeLine{598 FMT\_TYPE\_CONSTANT(\textcolor{keyword}{const} Char*, cstring\_type);}
\DoxyCodeLine{599 FMT\_TYPE\_CONSTANT(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}, string\_type);}
\DoxyCodeLine{600 FMT\_TYPE\_CONSTANT(\textcolor{keyword}{const} \textcolor{keywordtype}{void}*, pointer\_type);}
\DoxyCodeLine{601 }
\DoxyCodeLine{602 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_integral\_type(type t) \{}
\DoxyCodeLine{603   \textcolor{keywordflow}{return} t > type::none\_type \&\& t <= type::last\_integer\_type;}
\DoxyCodeLine{604 \}}
\DoxyCodeLine{605 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} is\_arithmetic\_type(type t) \{}
\DoxyCodeLine{606   \textcolor{keywordflow}{return} t > type::none\_type \&\& t <= type::last\_numeric\_type;}
\DoxyCodeLine{607 \}}
\DoxyCodeLine{608 }
\DoxyCodeLine{609 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} set(type rhs) -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 1 << \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(rhs); \}}
\DoxyCodeLine{610 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} in(type t, \textcolor{keywordtype}{int} set) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{611   \textcolor{keywordflow}{return} ((set >> \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(t)) \& 1) != 0;}
\DoxyCodeLine{612 \}}
\DoxyCodeLine{613 }
\DoxyCodeLine{614 \textcolor{comment}{// Bitsets of types.}}
\DoxyCodeLine{615 \textcolor{keyword}{enum} \{}
\DoxyCodeLine{616   sint\_set =}
\DoxyCodeLine{617       set(type::int\_type) | set(type::long\_long\_type) | set(type::int128\_type),}
\DoxyCodeLine{618   uint\_set = set(type::uint\_type) | set(type::ulong\_long\_type) |}
\DoxyCodeLine{619              set(type::uint128\_type),}
\DoxyCodeLine{620   bool\_set = set(type::bool\_type),}
\DoxyCodeLine{621   char\_set = set(type::char\_type),}
\DoxyCodeLine{622   float\_set = set(type::float\_type) | set(type::double\_type) |}
\DoxyCodeLine{623               set(type::long\_double\_type),}
\DoxyCodeLine{624   string\_set = set(type::string\_type),}
\DoxyCodeLine{625   cstring\_set = set(type::cstring\_type),}
\DoxyCodeLine{626   pointer\_set = set(type::pointer\_type)}
\DoxyCodeLine{627 \};}
\DoxyCodeLine{628 }
\DoxyCodeLine{629 FMT\_NORETURN FMT\_API \textcolor{keywordtype}{void} throw\_format\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message);}
\DoxyCodeLine{630 }
\DoxyCodeLine{631 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1error__handler}{error\_handler}} \{}
\DoxyCodeLine{632   \textcolor{keyword}{constexpr} \mbox{\hyperlink{structdetail_1_1error__handler}{error\_handler}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{633 }
\DoxyCodeLine{634   \textcolor{comment}{// This function is intentionally not constexpr to give a compile-\/time error.}}
\DoxyCodeLine{635   FMT\_NORETURN \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{636     throw\_format\_error(message);}
\DoxyCodeLine{637   \}}
\DoxyCodeLine{638 \};}
\DoxyCodeLine{639 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{640 }
\DoxyCodeLine{642 \textcolor{keyword}{using }detail::throw\_format\_error;}
\DoxyCodeLine{643 }
\DoxyCodeLine{645 \textcolor{keyword}{template} <\textcolor{keyword}{typename} S> \textcolor{keyword}{using }char\_t = \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1char__t__impl}{detail::char\_t\_impl<S>::type}};}
\DoxyCodeLine{646 }
\DoxyCodeLine{654 FMT\_EXPORT}
\DoxyCodeLine{655 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}} \{}
\DoxyCodeLine{656  \textcolor{keyword}{private}:}
\DoxyCodeLine{657   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str\_;}
\DoxyCodeLine{658   \textcolor{keywordtype}{int} next\_arg\_id\_;}
\DoxyCodeLine{659 }
\DoxyCodeLine{660   FMT\_CONSTEXPR \textcolor{keywordtype}{void} do\_check\_arg\_id(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id});}
\DoxyCodeLine{661 }
\DoxyCodeLine{662  \textcolor{keyword}{public}:}
\DoxyCodeLine{663   \textcolor{keyword}{using }char\_type = Char;}
\DoxyCodeLine{664   \textcolor{keyword}{using }iterator = \textcolor{keyword}{const} Char*;}
\DoxyCodeLine{665 }
\DoxyCodeLine{666   \textcolor{keyword}{explicit} \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}}(}
\DoxyCodeLine{667       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, \textcolor{keywordtype}{int} \mbox{\hyperlink{classbasic__format__parse__context_a152d3961cfbc244624a877d827fc1172}{next\_arg\_id}} = 0)}
\DoxyCodeLine{668       : format\_str\_(format\_str), next\_arg\_id\_(\mbox{\hyperlink{classbasic__format__parse__context_a152d3961cfbc244624a877d827fc1172}{next\_arg\_id}}) \{\}}
\DoxyCodeLine{669 }
\DoxyCodeLine{674   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__parse__context_afb21ddaa0d32b5430f99eed530666ea9}{begin}}() const noexcept -\/> iterator \{}
\DoxyCodeLine{675     \textcolor{keywordflow}{return} format\_str\_.begin();}
\DoxyCodeLine{676   \}}
\DoxyCodeLine{677 }
\DoxyCodeLine{681   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__parse__context_a6a0fc217fe680a1b23eada2a53870c41}{end}}() const noexcept -\/> iterator \{ \textcolor{keywordflow}{return} format\_str\_.end(); \}}
\DoxyCodeLine{682 }
\DoxyCodeLine{684   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context_ad18dcd3d0fbeb0174569b88da00c87f2}{advance\_to}}(iterator it) \{}
\DoxyCodeLine{685     format\_str\_.remove\_prefix(detail::to\_unsigned(it -\/ \mbox{\hyperlink{classbasic__format__parse__context_afb21ddaa0d32b5430f99eed530666ea9}{begin}}()));}
\DoxyCodeLine{686   \}}
\DoxyCodeLine{687 }
\DoxyCodeLine{692   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__parse__context_a152d3961cfbc244624a877d827fc1172}{next\_arg\_id}}() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{693     \textcolor{keywordflow}{if} (next\_arg\_id\_ < 0) \{}
\DoxyCodeLine{694       detail::throw\_format\_error(}
\DoxyCodeLine{695           \textcolor{stringliteral}{"{}cannot switch from manual to automatic argument indexing"{}});}
\DoxyCodeLine{696       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{697     \}}
\DoxyCodeLine{698     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = next\_arg\_id\_++;}
\DoxyCodeLine{699     do\_check\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{700     \textcolor{keywordflow}{return} id;}
\DoxyCodeLine{701   \}}
\DoxyCodeLine{702 }
\DoxyCodeLine{707   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context_a83f130644eeb162a932245c95447cf63}{check\_arg\_id}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{708     \textcolor{keywordflow}{if} (next\_arg\_id\_ > 0) \{}
\DoxyCodeLine{709       detail::throw\_format\_error(}
\DoxyCodeLine{710           \textcolor{stringliteral}{"{}cannot switch from automatic to manual argument indexing"{}});}
\DoxyCodeLine{711       \textcolor{keywordflow}{return};}
\DoxyCodeLine{712     \}}
\DoxyCodeLine{713     next\_arg\_id\_ = -\/1;}
\DoxyCodeLine{714     do\_check\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{715   \}}
\DoxyCodeLine{716   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context_a83f130644eeb162a932245c95447cf63}{check\_arg\_id}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}) \{\}}
\DoxyCodeLine{717   FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_dynamic\_spec(\textcolor{keywordtype}{int} arg\_id);}
\DoxyCodeLine{718 \};}
\DoxyCodeLine{719 }
\DoxyCodeLine{720 FMT\_EXPORT}
\DoxyCodeLine{721 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__parse__context}{format\_parse\_context}} = \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<char>}};}
\DoxyCodeLine{722 }
\DoxyCodeLine{723 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{724 \textcolor{comment}{// A parse context with extra data used only in compile-\/time checks.}}
\DoxyCodeLine{725 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{726 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1compile__parse__context}{compile\_parse\_context}} : \textcolor{keyword}{public} \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context}}<Char> \{}
\DoxyCodeLine{727  \textcolor{keyword}{private}:}
\DoxyCodeLine{728   \textcolor{keywordtype}{int} num\_args\_;}
\DoxyCodeLine{729   \textcolor{keyword}{const} type* types\_;}
\DoxyCodeLine{730   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__parse__context}{base}} = \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}};}
\DoxyCodeLine{731 }
\DoxyCodeLine{732  \textcolor{keyword}{public}:}
\DoxyCodeLine{733   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classdetail_1_1compile__parse__context}{compile\_parse\_context}}(}
\DoxyCodeLine{734       \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, \textcolor{keywordtype}{int} num\_args, \textcolor{keyword}{const} type* types,}
\DoxyCodeLine{735       \textcolor{keywordtype}{int} next\_arg\_id = 0)}
\DoxyCodeLine{736       : \mbox{\hyperlink{classbasic__format__parse__context}{base}}(format\_str, next\_arg\_id), num\_args\_(num\_args), types\_(types) \{\}}
\DoxyCodeLine{737 }
\DoxyCodeLine{738   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_args() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} num\_args\_; \}}
\DoxyCodeLine{739   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg\_type(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \textcolor{keyword}{const} -\/> type \{ \textcolor{keywordflow}{return} types\_[id]; \}}
\DoxyCodeLine{740 }
\DoxyCodeLine{741   FMT\_CONSTEXPR \textcolor{keyword}{auto} next\_arg\_id() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{742     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = \mbox{\hyperlink{classbasic__format__parse__context_a152d3961cfbc244624a877d827fc1172}{base::next\_arg\_id}}();}
\DoxyCodeLine{743     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= num\_args\_) throw\_format\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{744     \textcolor{keywordflow}{return} id;}
\DoxyCodeLine{745   \}}
\DoxyCodeLine{746 }
\DoxyCodeLine{747   FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_arg\_id(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{748     \mbox{\hyperlink{classbasic__format__parse__context_a83f130644eeb162a932245c95447cf63}{base::check\_arg\_id}}(\textcolor{keywordtype}{id});}
\DoxyCodeLine{749     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= num\_args\_) throw\_format\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{750   \}}
\DoxyCodeLine{751   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__parse__context_a83f130644eeb162a932245c95447cf63}{base::check\_arg\_id}};}
\DoxyCodeLine{752 }
\DoxyCodeLine{753   FMT\_CONSTEXPR \textcolor{keywordtype}{void} check\_dynamic\_spec(\textcolor{keywordtype}{int} arg\_id) \{}
\DoxyCodeLine{754     detail::ignore\_unused(arg\_id);}
\DoxyCodeLine{755 \textcolor{preprocessor}{\#if !defined(\_\_LCC\_\_)}}
\DoxyCodeLine{756     \textcolor{keywordflow}{if} (arg\_id < num\_args\_ \&\& types\_ \&\& !is\_integral\_type(types\_[arg\_id]))}
\DoxyCodeLine{757       throw\_format\_error(\textcolor{stringliteral}{"{}width/precision is not integer"{}});}
\DoxyCodeLine{758 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{759   \}}
\DoxyCodeLine{760 \};}
\DoxyCodeLine{761 }
\DoxyCodeLine{762 \textcolor{comment}{// Extracts a reference to the container from back\_insert\_iterator.}}
\DoxyCodeLine{763 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{764 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_container(std::back\_insert\_iterator<Container> it)}
\DoxyCodeLine{765     -\/> Container\& \{}
\DoxyCodeLine{766   \textcolor{keyword}{using }base = std::back\_insert\_iterator<Container>;}
\DoxyCodeLine{767   \textcolor{keyword}{struct }accessor : base \{}
\DoxyCodeLine{768     accessor(base b) : base(b) \{\}}
\DoxyCodeLine{769     \textcolor{keyword}{using }base::container;}
\DoxyCodeLine{770   \};}
\DoxyCodeLine{771   \textcolor{keywordflow}{return} *accessor(it).container;}
\DoxyCodeLine{772 \}}
\DoxyCodeLine{773 }
\DoxyCodeLine{774 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} InputIt, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{775 FMT\_CONSTEXPR \textcolor{keyword}{auto} copy\_str(InputIt begin, InputIt end, OutputIt out)}
\DoxyCodeLine{776     -\/> OutputIt \{}
\DoxyCodeLine{777   \textcolor{keywordflow}{while} (begin != end) *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(*begin++);}
\DoxyCodeLine{778   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{779 \}}
\DoxyCodeLine{780 }
\DoxyCodeLine{781 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U,}
\DoxyCodeLine{782           FMT\_ENABLE\_IF(}
\DoxyCodeLine{783               std::is\_same<remove\_const\_t<T>, U>::value\&\& \mbox{\hyperlink{structis__char}{is\_char<U>::value}})>}
\DoxyCodeLine{784 FMT\_CONSTEXPR \textcolor{keyword}{auto} copy\_str(T* begin, T* end, U* out) -\/> U* \{}
\DoxyCodeLine{785   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \textcolor{keywordflow}{return} copy\_str<Char, T*, U*>(begin, end, out);}
\DoxyCodeLine{786   \textcolor{keyword}{auto} size = to\_unsigned(end -\/ begin);}
\DoxyCodeLine{787   \textcolor{keywordflow}{if} (size > 0) memcpy(out, begin, size * \textcolor{keyword}{sizeof}(U));}
\DoxyCodeLine{788   \textcolor{keywordflow}{return} out + size;}
\DoxyCodeLine{789 \}}
\DoxyCodeLine{790 }
\DoxyCodeLine{797 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1buffer}{buffer}} \{}
\DoxyCodeLine{798  \textcolor{keyword}{private}:}
\DoxyCodeLine{799   T* ptr\_;}
\DoxyCodeLine{800   \textcolor{keywordtype}{size\_t} size\_;}
\DoxyCodeLine{801   \textcolor{keywordtype}{size\_t} capacity\_;}
\DoxyCodeLine{802 }
\DoxyCodeLine{803  \textcolor{keyword}{protected}:}
\DoxyCodeLine{804   \textcolor{comment}{// Don't initialize ptr\_ since it is not accessed to save a few cycles.}}
\DoxyCodeLine{805   FMT\_MSC\_WARNING(suppress : 26495)}
\DoxyCodeLine{806   \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}(\textcolor{keywordtype}{size\_t} sz) noexcept : size\_(sz), capacity\_(sz) \{\}}
\DoxyCodeLine{807 }
\DoxyCodeLine{808   FMT\_CONSTEXPR20 \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}(T* p = \textcolor{keyword}{nullptr}, \textcolor{keywordtype}{size\_t} sz = 0, \textcolor{keywordtype}{size\_t} cap = 0) noexcept}
\DoxyCodeLine{809       : ptr\_(p), size\_(sz), capacity\_(cap) \{\}}
\DoxyCodeLine{810 }
\DoxyCodeLine{811   FMT\_CONSTEXPR20 \mbox{\hyperlink{classdetail_1_1buffer}{\string~buffer}}() = \textcolor{keywordflow}{default};}
\DoxyCodeLine{812   \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}(\mbox{\hyperlink{classdetail_1_1buffer}{buffer}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{813 }
\DoxyCodeLine{815   FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1buffer_a5c82aec716b07079ac88194eb9aa7feb}{set}}(T* buf\_data, \textcolor{keywordtype}{size\_t} buf\_capacity) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{816     ptr\_ = buf\_data;}
\DoxyCodeLine{817     capacity\_ = buf\_capacity;}
\DoxyCodeLine{818   \}}
\DoxyCodeLine{819 }
\DoxyCodeLine{821   \textcolor{keyword}{virtual} FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1buffer_ae1afeec5148a94656c7deaaad19d7da6}{grow}}(\textcolor{keywordtype}{size\_t} \mbox{\hyperlink{classdetail_1_1buffer_ac7ff14268d6b32d3d878291445ff4dd3}{capacity}}) = 0;}
\DoxyCodeLine{822 }
\DoxyCodeLine{823  \textcolor{keyword}{public}:}
\DoxyCodeLine{824   \textcolor{keyword}{using }value\_type = T;}
\DoxyCodeLine{825   \textcolor{keyword}{using }const\_reference = \textcolor{keyword}{const} T\&;}
\DoxyCodeLine{826 }
\DoxyCodeLine{827   \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{828   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{829 }
\DoxyCodeLine{830   FMT\_INLINE \textcolor{keyword}{auto} begin() noexcept -\/> T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{831   FMT\_INLINE \textcolor{keyword}{auto} end() noexcept -\/> T* \{ \textcolor{keywordflow}{return} ptr\_ + size\_; \}}
\DoxyCodeLine{832 }
\DoxyCodeLine{833   FMT\_INLINE \textcolor{keyword}{auto} begin() const noexcept -\/> const T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{834   FMT\_INLINE \textcolor{keyword}{auto} end() const noexcept -\/> const T* \{ \textcolor{keywordflow}{return} ptr\_ + size\_; \}}
\DoxyCodeLine{835 }
\DoxyCodeLine{837   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}() const noexcept -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{838 }
\DoxyCodeLine{840   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{classdetail_1_1buffer_ac7ff14268d6b32d3d878291445ff4dd3}{capacity}}() const noexcept -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} capacity\_; \}}
\DoxyCodeLine{841 }
\DoxyCodeLine{843   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}() noexcept -\/> T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{844   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}() const noexcept -\/> const T* \{ \textcolor{keywordflow}{return} ptr\_; \}}
\DoxyCodeLine{845 }
\DoxyCodeLine{847   \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1buffer_a8174757a0d86698229670044730dc59b}{clear}}() \{ size\_ = 0; \}}
\DoxyCodeLine{848 }
\DoxyCodeLine{849   \textcolor{comment}{// Tries resizing the buffer to contain *count* elements. If T is a POD type}}
\DoxyCodeLine{850   \textcolor{comment}{// the new elements may not be initialized.}}
\DoxyCodeLine{851   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} try\_resize(\textcolor{keywordtype}{size\_t} count) \{}
\DoxyCodeLine{852     try\_reserve(count);}
\DoxyCodeLine{853     size\_ = count <= capacity\_ ? count : capacity\_;}
\DoxyCodeLine{854   \}}
\DoxyCodeLine{855 }
\DoxyCodeLine{856   \textcolor{comment}{// Tries increasing the buffer capacity to *new\_capacity*. It can increase the}}
\DoxyCodeLine{857   \textcolor{comment}{// capacity by a smaller amount than requested but guarantees there is space}}
\DoxyCodeLine{858   \textcolor{comment}{// for at least one additional element either by increasing the capacity or by}}
\DoxyCodeLine{859   \textcolor{comment}{// flushing the buffer if it is full.}}
\DoxyCodeLine{860   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} try\_reserve(\textcolor{keywordtype}{size\_t} new\_capacity) \{}
\DoxyCodeLine{861     \textcolor{keywordflow}{if} (new\_capacity > capacity\_) \mbox{\hyperlink{classdetail_1_1buffer_ae1afeec5148a94656c7deaaad19d7da6}{grow}}(new\_capacity);}
\DoxyCodeLine{862   \}}
\DoxyCodeLine{863 }
\DoxyCodeLine{864   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} push\_back(\textcolor{keyword}{const} T\& value) \{}
\DoxyCodeLine{865     try\_reserve(size\_ + 1);}
\DoxyCodeLine{866     ptr\_[size\_++] = value;}
\DoxyCodeLine{867   \}}
\DoxyCodeLine{868 }
\DoxyCodeLine{870   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U> \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1buffer_ab12c0beccf64adf0091468e357ed4b92}{append}}(\textcolor{keyword}{const} U* begin, \textcolor{keyword}{const} U* end);}
\DoxyCodeLine{871 }
\DoxyCodeLine{872   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Idx> FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](Idx index) -\/> T\& \{}
\DoxyCodeLine{873     \textcolor{keywordflow}{return} ptr\_[index];}
\DoxyCodeLine{874   \}}
\DoxyCodeLine{875   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Idx>}
\DoxyCodeLine{876   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](Idx index) \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} T\& \{}
\DoxyCodeLine{877     \textcolor{keywordflow}{return} ptr\_[index];}
\DoxyCodeLine{878   \}}
\DoxyCodeLine{879 \};}
\DoxyCodeLine{880 }
\DoxyCodeLine{881 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1buffer__traits}{buffer\_traits}} \{}
\DoxyCodeLine{882   \textcolor{keyword}{explicit} \mbox{\hyperlink{structdetail_1_1buffer__traits}{buffer\_traits}}(\textcolor{keywordtype}{size\_t}) \{\}}
\DoxyCodeLine{883   \textcolor{keyword}{auto} count() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{884   \textcolor{keyword}{auto} limit(\textcolor{keywordtype}{size\_t} size) -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size; \}}
\DoxyCodeLine{885 \};}
\DoxyCodeLine{886 }
\DoxyCodeLine{887 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1fixed__buffer__traits}{fixed\_buffer\_traits}} \{}
\DoxyCodeLine{888  \textcolor{keyword}{private}:}
\DoxyCodeLine{889   \textcolor{keywordtype}{size\_t} count\_ = 0;}
\DoxyCodeLine{890   \textcolor{keywordtype}{size\_t} limit\_;}
\DoxyCodeLine{891 }
\DoxyCodeLine{892  \textcolor{keyword}{public}:}
\DoxyCodeLine{893   \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1fixed__buffer__traits}{fixed\_buffer\_traits}}(\textcolor{keywordtype}{size\_t} limit) : limit\_(limit) \{\}}
\DoxyCodeLine{894   \textcolor{keyword}{auto} count() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} count\_; \}}
\DoxyCodeLine{895   \textcolor{keyword}{auto} limit(\textcolor{keywordtype}{size\_t} size) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{896     \textcolor{keywordtype}{size\_t} n = limit\_ > count\_ ? limit\_ -\/ count\_ : 0;}
\DoxyCodeLine{897     count\_ += size;}
\DoxyCodeLine{898     \textcolor{keywordflow}{return} size < n ? size : n;}
\DoxyCodeLine{899   \}}
\DoxyCodeLine{900 \};}
\DoxyCodeLine{901 }
\DoxyCodeLine{902 \textcolor{comment}{// A buffer that writes to an output iterator when flushed.}}
\DoxyCodeLine{903 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Traits = buffer\_traits>}
\DoxyCodeLine{904 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iterator__buffer}{iterator\_buffer}} final : \textcolor{keyword}{public} Traits, \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}<T> \{}
\DoxyCodeLine{905  \textcolor{keyword}{private}:}
\DoxyCodeLine{906   OutputIt out\_;}
\DoxyCodeLine{907   \textcolor{keyword}{enum} \{ buffer\_size = 256 \};}
\DoxyCodeLine{908   T data\_[buffer\_size];}
\DoxyCodeLine{909 }
\DoxyCodeLine{910  \textcolor{keyword}{protected}:}
\DoxyCodeLine{911   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1iterator__buffer_a4da5a827afd749bc4687da24e5e91241}{grow}}(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{912     \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}() == buffer\_size) flush();}
\DoxyCodeLine{913   \}}
\DoxyCodeLine{914 }
\DoxyCodeLine{915   \textcolor{keywordtype}{void} flush() \{}
\DoxyCodeLine{916     \textcolor{keyword}{auto} \mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}} = this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}();}
\DoxyCodeLine{917     this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8174757a0d86698229670044730dc59b}{clear}}();}
\DoxyCodeLine{918     out\_ = copy\_str<T>(data\_, data\_ + this-\/>limit(\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}), out\_);}
\DoxyCodeLine{919   \}}
\DoxyCodeLine{920 }
\DoxyCodeLine{921  \textcolor{keyword}{public}:}
\DoxyCodeLine{922   \textcolor{keyword}{explicit} iterator\_buffer(OutputIt out, \textcolor{keywordtype}{size\_t} n = buffer\_size)}
\DoxyCodeLine{923       : Traits(n), buffer<T>(data\_, 0, buffer\_size), out\_(out) \{\}}
\DoxyCodeLine{924   iterator\_buffer(iterator\_buffer\&\& other)}
\DoxyCodeLine{925       : Traits(other), buffer<T>(data\_, 0, buffer\_size), out\_(other.out\_) \{\}}
\DoxyCodeLine{926   \string~iterator\_buffer() \{ flush(); \}}
\DoxyCodeLine{927 }
\DoxyCodeLine{928   \textcolor{keyword}{auto} out() -\/> OutputIt \{}
\DoxyCodeLine{929     flush();}
\DoxyCodeLine{930     \textcolor{keywordflow}{return} out\_;}
\DoxyCodeLine{931   \}}
\DoxyCodeLine{932   \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} Traits::count() + this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}(); \}}
\DoxyCodeLine{933 \};}
\DoxyCodeLine{934 }
\DoxyCodeLine{935 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{936 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iterator__buffer}{iterator\_buffer}}<T*, T, \mbox{\hyperlink{classdetail_1_1fixed__buffer__traits}{fixed\_buffer\_traits}}> final}
\DoxyCodeLine{937     : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1fixed__buffer__traits}{fixed\_buffer\_traits}},}
\DoxyCodeLine{938       \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1buffer}{buffer<T>}} \{}
\DoxyCodeLine{939  \textcolor{keyword}{private}:}
\DoxyCodeLine{940   T* out\_;}
\DoxyCodeLine{941   \textcolor{keyword}{enum} \{ buffer\_size = 256 \};}
\DoxyCodeLine{942   T data\_[buffer\_size];}
\DoxyCodeLine{943 }
\DoxyCodeLine{944  \textcolor{keyword}{protected}:}
\DoxyCodeLine{945   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1iterator__buffer_3_01T_01_5_00_01T_00_01fixed__buffer__traits_01_4_a42f85c60426acaad2c4f17f5c633f082}{grow}}(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{946     \textcolor{keywordflow}{if} (this-\/>size() == this-\/>capacity()) flush();}
\DoxyCodeLine{947   \}}
\DoxyCodeLine{948 }
\DoxyCodeLine{949   \textcolor{keywordtype}{void} flush() \{}
\DoxyCodeLine{950     \textcolor{keywordtype}{size\_t} n = this-\/>limit(this-\/>size());}
\DoxyCodeLine{951     \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{structdetail_1_1data}{data}}() == out\_) \{}
\DoxyCodeLine{952       out\_ += n;}
\DoxyCodeLine{953       this-\/>set(data\_, buffer\_size);}
\DoxyCodeLine{954     \}}
\DoxyCodeLine{955     this-\/>clear();}
\DoxyCodeLine{956   \}}
\DoxyCodeLine{957 }
\DoxyCodeLine{958  \textcolor{keyword}{public}:}
\DoxyCodeLine{959   \textcolor{keyword}{explicit} iterator\_buffer(T* out, \textcolor{keywordtype}{size\_t} n = buffer\_size)}
\DoxyCodeLine{960       : fixed\_buffer\_traits(n), buffer<T>(out, 0, n), out\_(out) \{\}}
\DoxyCodeLine{961   iterator\_buffer(iterator\_buffer\&\& other)}
\DoxyCodeLine{962       : fixed\_buffer\_traits(other),}
\DoxyCodeLine{963         buffer<T>(std::move(other)),}
\DoxyCodeLine{964         out\_(other.out\_) \{}
\DoxyCodeLine{965     \textcolor{keywordflow}{if} (this-\/>data() != out\_) \{}
\DoxyCodeLine{966       this-\/>set(data\_, buffer\_size);}
\DoxyCodeLine{967       this-\/>clear();}
\DoxyCodeLine{968     \}}
\DoxyCodeLine{969   \}}
\DoxyCodeLine{970   \string~iterator\_buffer() \{ flush(); \}}
\DoxyCodeLine{971 }
\DoxyCodeLine{972   \textcolor{keyword}{auto} out() -\/> T* \{}
\DoxyCodeLine{973     flush();}
\DoxyCodeLine{974     \textcolor{keywordflow}{return} out\_;}
\DoxyCodeLine{975   \}}
\DoxyCodeLine{976   \textcolor{keyword}{auto} count() const -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{977     \textcolor{keywordflow}{return} fixed\_buffer\_traits::count() + this-\/>size();}
\DoxyCodeLine{978   \}}
\DoxyCodeLine{979 \};}
\DoxyCodeLine{980 }
\DoxyCodeLine{981 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iterator__buffer}{iterator\_buffer}}<T*, T> final : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1buffer}{buffer<T>}} \{}
\DoxyCodeLine{982  \textcolor{keyword}{protected}:}
\DoxyCodeLine{983   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1iterator__buffer_3_01T_01_5_00_01T_01_4_a7761369f1fc9727647e082234cfe1234}{grow}}(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{\}}
\DoxyCodeLine{984 }
\DoxyCodeLine{985  \textcolor{keyword}{public}:}
\DoxyCodeLine{986   \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1iterator__buffer}{iterator\_buffer}}(T* out, \textcolor{keywordtype}{size\_t} = 0) : \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}<T>(out, 0, \string~size\_t()) \{\}}
\DoxyCodeLine{987 }
\DoxyCodeLine{988   \textcolor{keyword}{auto} out() -\/> T* \{ \textcolor{keywordflow}{return} \&*this-\/>end(); \}}
\DoxyCodeLine{989 \};}
\DoxyCodeLine{990 }
\DoxyCodeLine{991 \textcolor{comment}{// A buffer that writes to a container with the contiguous storage.}}
\DoxyCodeLine{992 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{993 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1iterator__buffer}{iterator\_buffer}}<std::back\_insert\_iterator<Container>,}
\DoxyCodeLine{994                       enable\_if\_t<is\_contiguous<Container>::value,}
\DoxyCodeLine{995                                   typename Container::value\_type>>}
\DoxyCodeLine{996     final : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}<typename Container::value\_type> \{}
\DoxyCodeLine{997  \textcolor{keyword}{private}:}
\DoxyCodeLine{998   Container\& container\_;}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1001   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1iterator__buffer_3_01std_1_1back__insert__iterator_3_01Container_01_4_00_01enablea2d579bc6466b5382e01854ff6e2d68f_a1af4b95b03d67cfc8254f10ec8592b46}{grow}}(\textcolor{keywordtype}{size\_t} \mbox{\hyperlink{classdetail_1_1buffer_ac7ff14268d6b32d3d878291445ff4dd3}{capacity}})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{1002     container\_.resize(\mbox{\hyperlink{classdetail_1_1buffer_ac7ff14268d6b32d3d878291445ff4dd3}{capacity}});}
\DoxyCodeLine{1003     this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a5c82aec716b07079ac88194eb9aa7feb}{set}}(\&container\_[0], \mbox{\hyperlink{classdetail_1_1buffer_ac7ff14268d6b32d3d878291445ff4dd3}{capacity}});}
\DoxyCodeLine{1004   \}}
\DoxyCodeLine{1005 }
\DoxyCodeLine{1006  \textcolor{keyword}{public}:}
\DoxyCodeLine{1007   \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1iterator__buffer}{iterator\_buffer}}(Container\& c)}
\DoxyCodeLine{1008       : \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}<typename Container::value\_type>(c.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()), container\_(c) \{\}}
\DoxyCodeLine{1009   \textcolor{keyword}{explicit} iterator\_buffer(std::back\_insert\_iterator<Container> out, \textcolor{keywordtype}{size\_t} = 0)}
\DoxyCodeLine{1010       : iterator\_buffer(get\_container(out)) \{\}}
\DoxyCodeLine{1011 }
\DoxyCodeLine{1012   \textcolor{keyword}{auto} out() -\/> std::back\_insert\_iterator<Container> \{}
\DoxyCodeLine{1013     \textcolor{keywordflow}{return} std::back\_inserter(container\_);}
\DoxyCodeLine{1014   \}}
\DoxyCodeLine{1015 \};}
\DoxyCodeLine{1016 }
\DoxyCodeLine{1017 \textcolor{comment}{// A buffer that counts the number of code units written discarding the output.}}
\DoxyCodeLine{1018 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = \textcolor{keywordtype}{char}> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1counting__buffer}{counting\_buffer}} final : \textcolor{keyword}{public} \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}<T> \{}
\DoxyCodeLine{1019  \textcolor{keyword}{private}:}
\DoxyCodeLine{1020   \textcolor{keyword}{enum} \{ buffer\_size = 256 \};}
\DoxyCodeLine{1021   T data\_[buffer\_size];}
\DoxyCodeLine{1022   \textcolor{keywordtype}{size\_t} count\_ = 0;}
\DoxyCodeLine{1023 }
\DoxyCodeLine{1024  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1025   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classdetail_1_1counting__buffer_ad3a44d497c6ddd5ac284f57a56639d2f}{grow}}(\textcolor{keywordtype}{size\_t})\textcolor{keyword}{ override }\{}
\DoxyCodeLine{1026     \textcolor{keywordflow}{if} (this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}() != buffer\_size) \textcolor{keywordflow}{return};}
\DoxyCodeLine{1027     count\_ += this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}();}
\DoxyCodeLine{1028     this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8174757a0d86698229670044730dc59b}{clear}}();}
\DoxyCodeLine{1029   \}}
\DoxyCodeLine{1030 }
\DoxyCodeLine{1031  \textcolor{keyword}{public}:}
\DoxyCodeLine{1032   \mbox{\hyperlink{classdetail_1_1counting__buffer}{counting\_buffer}}() : \mbox{\hyperlink{classdetail_1_1buffer}{buffer}}<T>(data\_, 0, buffer\_size) \{\}}
\DoxyCodeLine{1033 }
\DoxyCodeLine{1034   \textcolor{keyword}{auto} count() -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} count\_ + this-\/>\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}(); \}}
\DoxyCodeLine{1035 \};}
\DoxyCodeLine{1036 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{1037 }
\DoxyCodeLine{1038 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1039 FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>::do\_check\_arg\_id}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{1040   \textcolor{comment}{// Argument id is only checked at compile-\/time during parsing because}}
\DoxyCodeLine{1041   \textcolor{comment}{// formatting has its own validation.}}
\DoxyCodeLine{1042   \textcolor{keywordflow}{if} (detail::is\_constant\_evaluated() \&\&}
\DoxyCodeLine{1043       (!FMT\_GCC\_VERSION || FMT\_GCC\_VERSION >= 1200)) \{}
\DoxyCodeLine{1044     \textcolor{keyword}{using }context = \mbox{\hyperlink{classdetail_1_1compile__parse__context}{detail::compile\_parse\_context<Char>}};}
\DoxyCodeLine{1045     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= \textcolor{keyword}{static\_cast<}context*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>num\_args())}
\DoxyCodeLine{1046       detail::throw\_format\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{1047   \}}
\DoxyCodeLine{1048 \}}
\DoxyCodeLine{1049 }
\DoxyCodeLine{1050 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1051 FMT\_CONSTEXPR \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>::check\_dynamic\_spec}}(}
\DoxyCodeLine{1052     \textcolor{keywordtype}{int} arg\_id) \{}
\DoxyCodeLine{1053   \textcolor{keywordflow}{if} (detail::is\_constant\_evaluated() \&\&}
\DoxyCodeLine{1054       (!FMT\_GCC\_VERSION || FMT\_GCC\_VERSION >= 1200)) \{}
\DoxyCodeLine{1055     \textcolor{keyword}{using }context = \mbox{\hyperlink{classdetail_1_1compile__parse__context}{detail::compile\_parse\_context<Char>}};}
\DoxyCodeLine{1056     \textcolor{keyword}{static\_cast<}context*\textcolor{keyword}{>}(\textcolor{keyword}{this})-\/>check\_dynamic\_spec(arg\_id);}
\DoxyCodeLine{1057   \}}
\DoxyCodeLine{1058 \}}
\DoxyCodeLine{1059 }
\DoxyCodeLine{1060 FMT\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}};}
\DoxyCodeLine{1061 FMT\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}};}
\DoxyCodeLine{1062 FMT\_EXPORT \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classdynamic__format__arg__store}{dynamic\_format\_arg\_store}};}
\DoxyCodeLine{1063 }
\DoxyCodeLine{1064 \textcolor{comment}{// A formatter for objects of type T.}}
\DoxyCodeLine{1065 FMT\_EXPORT}
\DoxyCodeLine{1066 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1067 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}} \{}
\DoxyCodeLine{1068   \textcolor{comment}{// A deleted default constructor indicates a disabled formatter.}}
\DoxyCodeLine{1069   \mbox{\hyperlink{structformatter}{formatter}}() = \textcolor{keyword}{delete};}
\DoxyCodeLine{1070 \};}
\DoxyCodeLine{1071 }
\DoxyCodeLine{1072 \textcolor{comment}{// Specifies if T has an enabled formatter specialization. A type can be}}
\DoxyCodeLine{1073 \textcolor{comment}{// formattable even if it doesn't have a formatter e.g. via a conversion.}}
\DoxyCodeLine{1074 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1075 \textcolor{keyword}{using }has\_formatter =}
\DoxyCodeLine{1076     std::is\_constructible<typename Context::template formatter\_type<T>>;}
\DoxyCodeLine{1077 }
\DoxyCodeLine{1078 \textcolor{comment}{// An output iterator that appends to a buffer.}}
\DoxyCodeLine{1079 \textcolor{comment}{// It is used to reduce symbol sizes for the common case.}}
\DoxyCodeLine{1080 \textcolor{keyword}{class }\mbox{\hyperlink{classappender}{appender}} : \textcolor{keyword}{public} std::back\_insert\_iterator<detail::buffer<char>> \{}
\DoxyCodeLine{1081   \textcolor{keyword}{using }base = std::back\_insert\_iterator<detail::buffer<char>>;}
\DoxyCodeLine{1082 }
\DoxyCodeLine{1083  \textcolor{keyword}{public}:}
\DoxyCodeLine{1084   \textcolor{keyword}{using }std::back\_insert\_iterator<\mbox{\hyperlink{classdetail_1_1buffer}{detail::buffer<char>}}>::back\_insert\_iterator;}
\DoxyCodeLine{1085   \mbox{\hyperlink{classappender}{appender}}(base it) noexcept : base(it) \{\}}
\DoxyCodeLine{1086   FMT\_UNCHECKED\_ITERATOR(\mbox{\hyperlink{classappender}{appender}});}
\DoxyCodeLine{1087 }
\DoxyCodeLine{1088   \textcolor{keyword}{auto} operator++() \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{classappender}{appender}}\& \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{1089   \textcolor{keyword}{auto} operator++(\textcolor{keywordtype}{int}) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{classappender}{appender}} \{ \textcolor{keywordflow}{return} *\textcolor{keyword}{this}; \}}
\DoxyCodeLine{1090 \};}
\DoxyCodeLine{1091 }
\DoxyCodeLine{1092 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{1093 }
\DoxyCodeLine{1094 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1095 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} has\_const\_formatter\_impl(T*)}
\DoxyCodeLine{1096     -\/> \textcolor{keyword}{decltype}(\textcolor{keyword}{typename} Context::template formatter\_type<T>().format(}
\DoxyCodeLine{1097                     std::declval<const T\&>(), std::declval<Context\&>()),}
\DoxyCodeLine{1098                 \textcolor{keyword}{true}) \{}
\DoxyCodeLine{1099   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1100 \}}
\DoxyCodeLine{1101 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1102 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} has\_const\_formatter\_impl(...) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1103   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1104 \}}
\DoxyCodeLine{1105 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1106 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} has\_const\_formatter() -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1107   \textcolor{keywordflow}{return} has\_const\_formatter\_impl<Context>(\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr}));}
\DoxyCodeLine{1108 \}}
\DoxyCodeLine{1109 }
\DoxyCodeLine{1110 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1111 \textcolor{keyword}{using }buffer\_appender = conditional\_t<std::is\_same<T, char>::value, \mbox{\hyperlink{classappender}{appender}},}
\DoxyCodeLine{1112                                       std::back\_insert\_iterator<buffer<T>>>;}
\DoxyCodeLine{1113 }
\DoxyCodeLine{1114 \textcolor{comment}{// Maps an output iterator to a buffer.}}
\DoxyCodeLine{1115 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1116 \textcolor{keyword}{auto} get\_buffer(OutputIt out) -\/> iterator\_buffer<OutputIt, T> \{}
\DoxyCodeLine{1117   \textcolor{keywordflow}{return} iterator\_buffer<OutputIt, T>(out);}
\DoxyCodeLine{1118 \}}
\DoxyCodeLine{1119 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Buf,}
\DoxyCodeLine{1120           FMT\_ENABLE\_IF(std::is\_base\_of<buffer<char>, Buf>::value)>}
\DoxyCodeLine{1121 \textcolor{keyword}{auto} get\_buffer(std::back\_insert\_iterator<Buf> out) -\/> buffer<char>\& \{}
\DoxyCodeLine{1122   \textcolor{keywordflow}{return} get\_container(out);}
\DoxyCodeLine{1123 \}}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Buf, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1126 FMT\_INLINE \textcolor{keyword}{auto} get\_iterator(Buf\& buf, OutputIt) -\/> \textcolor{keyword}{decltype}(buf.out()) \{}
\DoxyCodeLine{1127   \textcolor{keywordflow}{return} buf.out();}
\DoxyCodeLine{1128 \}}
\DoxyCodeLine{1129 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1130 \textcolor{keyword}{auto} get\_iterator(buffer<T>\&, OutputIt out) -\/> OutputIt \{}
\DoxyCodeLine{1131   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1132 \}}
\DoxyCodeLine{1133 }
\DoxyCodeLine{1134 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1view}{view}} \{\};}
\DoxyCodeLine{1135 }
\DoxyCodeLine{1136 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1named__arg}{named\_arg}} : \mbox{\hyperlink{structdetail_1_1view}{view}} \{}
\DoxyCodeLine{1137   \textcolor{keyword}{const} Char* name;}
\DoxyCodeLine{1138   \textcolor{keyword}{const} T\& \mbox{\hyperlink{classdetail_1_1value}{value}};}
\DoxyCodeLine{1139   \mbox{\hyperlink{structdetail_1_1named__arg}{named\_arg}}(\textcolor{keyword}{const} Char* n, \textcolor{keyword}{const} T\& v) : name(n), \mbox{\hyperlink{classdetail_1_1value}{value}}(v) \{\}}
\DoxyCodeLine{1140 \};}
\DoxyCodeLine{1141 }
\DoxyCodeLine{1142 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1named__arg__info}{named\_arg\_info}} \{}
\DoxyCodeLine{1143   \textcolor{keyword}{const} Char* name;}
\DoxyCodeLine{1144   \textcolor{keywordtype}{int} id;}
\DoxyCodeLine{1145 \};}
\DoxyCodeLine{1146 }
\DoxyCodeLine{1147 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} NUM\_ARGS, \textcolor{keywordtype}{size\_t} NUM\_NAMED\_ARGS>}
\DoxyCodeLine{1148 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1arg__data}{arg\_data}} \{}
\DoxyCodeLine{1149   \textcolor{comment}{// args\_[0].named\_args points to named\_args\_ to avoid bloating format\_args.}}
\DoxyCodeLine{1150   \textcolor{comment}{// +1 to workaround a bug in gcc 7.5 that causes duplicated-\/branches warning.}}
\DoxyCodeLine{1151   T args\_[1 + (NUM\_ARGS != 0 ? NUM\_ARGS : +1)];}
\DoxyCodeLine{1152   \mbox{\hyperlink{structdetail_1_1named__arg__info}{named\_arg\_info<Char>}} named\_args\_[NUM\_NAMED\_ARGS];}
\DoxyCodeLine{1153 }
\DoxyCodeLine{1154   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... U>}
\DoxyCodeLine{1155   \mbox{\hyperlink{structdetail_1_1arg__data}{arg\_data}}(\textcolor{keyword}{const} U\&... init) : args\_\{T(named\_args\_, NUM\_NAMED\_ARGS), init...\} \{\}}
\DoxyCodeLine{1156   \mbox{\hyperlink{structdetail_1_1arg__data}{arg\_data}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1arg__data}{arg\_data}}\& other) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1157   \textcolor{keyword}{auto} args() \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} T* \{ \textcolor{keywordflow}{return} args\_ + 1; \}}
\DoxyCodeLine{1158   \textcolor{keyword}{auto} named\_args() -\/> \mbox{\hyperlink{structdetail_1_1named__arg__info}{named\_arg\_info<Char>}}* \{ \textcolor{keywordflow}{return} named\_args\_; \}}
\DoxyCodeLine{1159 \};}
\DoxyCodeLine{1160 }
\DoxyCodeLine{1161 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} NUM\_ARGS>}
\DoxyCodeLine{1162 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1arg__data}{arg\_data}}<T, Char, NUM\_ARGS, 0> \{}
\DoxyCodeLine{1163   \textcolor{comment}{// +1 to workaround a bug in gcc 7.5 that causes duplicated-\/branches warning.}}
\DoxyCodeLine{1164   T args\_[NUM\_ARGS != 0 ? NUM\_ARGS : +1];}
\DoxyCodeLine{1165 }
\DoxyCodeLine{1166   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... U>}
\DoxyCodeLine{1167   FMT\_CONSTEXPR FMT\_INLINE \mbox{\hyperlink{structdetail_1_1arg__data}{arg\_data}}(\textcolor{keyword}{const} U\&... init) : args\_\{init...\} \{\}}
\DoxyCodeLine{1168   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} args() \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} T* \{ \textcolor{keywordflow}{return} args\_; \}}
\DoxyCodeLine{1169   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} named\_args() -\/> std::nullptr\_t \{}
\DoxyCodeLine{1170     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1171   \}}
\DoxyCodeLine{1172 \};}
\DoxyCodeLine{1173 }
\DoxyCodeLine{1174 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1175 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} init\_named\_args(\mbox{\hyperlink{structdetail_1_1named__arg__info}{named\_arg\_info<Char>}}*, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{int}) \{\}}
\DoxyCodeLine{1176 }
\DoxyCodeLine{1177 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__named__arg}{is\_named\_arg}} : std::false\_type \{\};}
\DoxyCodeLine{1178 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__statically__named__arg}{is\_statically\_named\_arg}} : std::false\_type \{\};}
\DoxyCodeLine{1179 }
\DoxyCodeLine{1180 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1181 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__named__arg}{is\_named\_arg}}<\mbox{\hyperlink{structdetail_1_1named__arg}{named\_arg}}<Char, T>> : std::true\_type \{\};}
\DoxyCodeLine{1182 }
\DoxyCodeLine{1183 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Tail,}
\DoxyCodeLine{1184           FMT\_ENABLE\_IF(!\mbox{\hyperlink{structdetail_1_1is__named__arg}{is\_named\_arg<T>::value}})>}
\DoxyCodeLine{1185 \textcolor{keywordtype}{void} init\_named\_args(\mbox{\hyperlink{structdetail_1_1named__arg__info}{named\_arg\_info<Char>}}* named\_args, \textcolor{keywordtype}{int} arg\_count,}
\DoxyCodeLine{1186                      \textcolor{keywordtype}{int} named\_arg\_count, \textcolor{keyword}{const} T\&, \textcolor{keyword}{const} Tail\&... args) \{}
\DoxyCodeLine{1187   init\_named\_args(named\_args, arg\_count + 1, named\_arg\_count, args...);}
\DoxyCodeLine{1188 \}}
\DoxyCodeLine{1189 }
\DoxyCodeLine{1190 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... Tail,}
\DoxyCodeLine{1191           FMT\_ENABLE\_IF(is\_named\_arg<T>::value)>}
\DoxyCodeLine{1192 \textcolor{keywordtype}{void} init\_named\_args(named\_arg\_info<Char>* named\_args, \textcolor{keywordtype}{int} arg\_count,}
\DoxyCodeLine{1193                      \textcolor{keywordtype}{int} named\_arg\_count, \textcolor{keyword}{const} T\& arg, \textcolor{keyword}{const} Tail\&... args) \{}
\DoxyCodeLine{1194   named\_args[named\_arg\_count++] = \{arg.name, arg\_count\};}
\DoxyCodeLine{1195   init\_named\_args(named\_args, arg\_count + 1, named\_arg\_count, args...);}
\DoxyCodeLine{1196 \}}
\DoxyCodeLine{1197 }
\DoxyCodeLine{1198 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{1199 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keywordtype}{void} init\_named\_args(std::nullptr\_t, \textcolor{keywordtype}{int}, \textcolor{keywordtype}{int},}
\DoxyCodeLine{1200                                               \textcolor{keyword}{const} \mbox{\hyperlink{classArgs}{Args}}\&...) \{\}}
\DoxyCodeLine{1201 }
\DoxyCodeLine{1202 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B = false> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count() -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} B ? 1 : 0; \}}
\DoxyCodeLine{1203 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} B1, \textcolor{keywordtype}{bool} B2, \textcolor{keywordtype}{bool}... Tail> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count() -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{1204   \textcolor{keywordflow}{return} (B1 ? 1 : 0) + count<B2, Tail...>();}
\DoxyCodeLine{1205 \}}
\DoxyCodeLine{1206 }
\DoxyCodeLine{1207 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count\_named\_args() -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{1208   \textcolor{keywordflow}{return} count<is\_named\_arg<Args>::value...>();}
\DoxyCodeLine{1209 \}}
\DoxyCodeLine{1210 }
\DoxyCodeLine{1211 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{1212 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} count\_statically\_named\_args() -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{1213   \textcolor{keywordflow}{return} count<is\_statically\_named\_arg<Args>::value...>();}
\DoxyCodeLine{1214 \}}
\DoxyCodeLine{1215 }
\DoxyCodeLine{1216 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1unformattable}{unformattable}} \{\};}
\DoxyCodeLine{1217 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1unformattable__char}{unformattable\_char}} : \mbox{\hyperlink{structdetail_1_1unformattable}{unformattable}} \{\};}
\DoxyCodeLine{1218 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1unformattable__pointer}{unformattable\_pointer}} : \mbox{\hyperlink{structdetail_1_1unformattable}{unformattable}} \{\};}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1string__value}{string\_value}} \{}
\DoxyCodeLine{1221   \textcolor{keyword}{const} Char* \mbox{\hyperlink{structdetail_1_1data}{data}};}
\DoxyCodeLine{1222   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{1223 \};}
\DoxyCodeLine{1224 }
\DoxyCodeLine{1225 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1named__arg__value}{named\_arg\_value}} \{}
\DoxyCodeLine{1226   \textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1named__arg__info}{named\_arg\_info<Char>}}* \mbox{\hyperlink{structdetail_1_1data}{data}};}
\DoxyCodeLine{1227   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{1228 \};}
\DoxyCodeLine{1229 }
\DoxyCodeLine{1230 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1custom__value}{custom\_value}} \{}
\DoxyCodeLine{1231   \textcolor{keyword}{using }parse\_context = \textcolor{keyword}{typename} Context::parse\_context\_type;}
\DoxyCodeLine{1232   \textcolor{keywordtype}{void}* \mbox{\hyperlink{classdetail_1_1value}{value}};}
\DoxyCodeLine{1233   void (*format)(\textcolor{keywordtype}{void}* arg, parse\_context\& parse\_ctx, Context\& ctx);}
\DoxyCodeLine{1234 \};}
\DoxyCodeLine{1235 }
\DoxyCodeLine{1236 \textcolor{comment}{// A formatting argument value.}}
\DoxyCodeLine{1237 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1value}{value}} \{}
\DoxyCodeLine{1238  \textcolor{keyword}{public}:}
\DoxyCodeLine{1239   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Context::char\_type;}
\DoxyCodeLine{1240 }
\DoxyCodeLine{1241   \textcolor{keyword}{union }\{}
\DoxyCodeLine{1242     \mbox{\hyperlink{structmonostate}{monostate}} no\_value;}
\DoxyCodeLine{1243     \textcolor{keywordtype}{int} int\_value;}
\DoxyCodeLine{1244     \textcolor{keywordtype}{unsigned} uint\_value;}
\DoxyCodeLine{1245     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} long\_long\_value;}
\DoxyCodeLine{1246     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} ulong\_long\_value;}
\DoxyCodeLine{1247     int128\_opt int128\_value;}
\DoxyCodeLine{1248     uint128\_opt uint128\_value;}
\DoxyCodeLine{1249     \textcolor{keywordtype}{bool} bool\_value;}
\DoxyCodeLine{1250     char\_type char\_value;}
\DoxyCodeLine{1251     \textcolor{keywordtype}{float} float\_value;}
\DoxyCodeLine{1252     \textcolor{keywordtype}{double} double\_value;}
\DoxyCodeLine{1253     \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} long\_double\_value;}
\DoxyCodeLine{1254     \textcolor{keyword}{const} \textcolor{keywordtype}{void}* pointer;}
\DoxyCodeLine{1255     \mbox{\hyperlink{structdetail_1_1string__value}{string\_value<char\_type>}} string;}
\DoxyCodeLine{1256     \mbox{\hyperlink{structdetail_1_1custom__value}{custom\_value<Context>}} custom;}
\DoxyCodeLine{1257     \mbox{\hyperlink{structdetail_1_1named__arg__value}{named\_arg\_value<char\_type>}} named\_args;}
\DoxyCodeLine{1258   \};}
\DoxyCodeLine{1259 }
\DoxyCodeLine{1260   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}() : no\_value() \{\}}
\DoxyCodeLine{1261   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{int} val) : int\_value(val) \{\}}
\DoxyCodeLine{1262   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{unsigned} val) : uint\_value(val) \{\}}
\DoxyCodeLine{1263   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) : long\_long\_value(val) \{\}}
\DoxyCodeLine{1264   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) : ulong\_long\_value(val) \{\}}
\DoxyCodeLine{1265   FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(int128\_opt val) : int128\_value(val) \{\}}
\DoxyCodeLine{1266   FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(uint128\_opt val) : uint128\_value(val) \{\}}
\DoxyCodeLine{1267   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{float} val) : float\_value(val) \{\}}
\DoxyCodeLine{1268   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{double} val) : double\_value(val) \{\}}
\DoxyCodeLine{1269   FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) : long\_double\_value(val) \{\}}
\DoxyCodeLine{1270   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keywordtype}{bool} val) : bool\_value(val) \{\}}
\DoxyCodeLine{1271   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(char\_type val) : char\_value(val) \{\}}
\DoxyCodeLine{1272   FMT\_CONSTEXPR FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keyword}{const} char\_type* val) \{}
\DoxyCodeLine{1273     \textcolor{keywordtype}{string}.data = val;}
\DoxyCodeLine{1274     \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \textcolor{keywordtype}{string}.size = \{\};}
\DoxyCodeLine{1275   \}}
\DoxyCodeLine{1276   FMT\_CONSTEXPR FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} val) \{}
\DoxyCodeLine{1277     \textcolor{keywordtype}{string}.data = val.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{1278     \textcolor{keywordtype}{string}.size = val.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{1279   \}}
\DoxyCodeLine{1280   FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* val) : pointer(val) \{\}}
\DoxyCodeLine{1281   FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1named__arg__info}{named\_arg\_info<char\_type>}}* args, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{1282       : named\_args\{args, size\} \{\}}
\DoxyCodeLine{1283 }
\DoxyCodeLine{1284   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_CONSTEXPR FMT\_INLINE \mbox{\hyperlink{classdetail_1_1value}{value}}(T\& val) \{}
\DoxyCodeLine{1285     \textcolor{keyword}{using }value\_type = remove\_const\_t<T>;}
\DoxyCodeLine{1286     custom.value = \textcolor{keyword}{const\_cast<}value\_type*\textcolor{keyword}{>}(\&val);}
\DoxyCodeLine{1287     \textcolor{comment}{// Get the formatter type through the context to allow different contexts}}
\DoxyCodeLine{1288     \textcolor{comment}{// have different extension points, e.g. `formatter<T>` for `format` and}}
\DoxyCodeLine{1289     \textcolor{comment}{// `printf\_formatter<T>` for `printf`.}}
\DoxyCodeLine{1290     custom.format = format\_custom\_arg<}
\DoxyCodeLine{1291         value\_type, \textcolor{keyword}{typename} Context::template formatter\_type<value\_type>>;}
\DoxyCodeLine{1292   \}}
\DoxyCodeLine{1293   \mbox{\hyperlink{classdetail_1_1value}{value}}(\mbox{\hyperlink{structdetail_1_1unformattable}{unformattable}});}
\DoxyCodeLine{1294   \mbox{\hyperlink{classdetail_1_1value}{value}}(\mbox{\hyperlink{structdetail_1_1unformattable__char}{unformattable\_char}});}
\DoxyCodeLine{1295   \mbox{\hyperlink{classdetail_1_1value}{value}}(\mbox{\hyperlink{structdetail_1_1unformattable__pointer}{unformattable\_pointer}});}
\DoxyCodeLine{1296 }
\DoxyCodeLine{1297  \textcolor{keyword}{private}:}
\DoxyCodeLine{1298   \textcolor{comment}{// Formats an argument of a custom type, such as a user-\/defined class.}}
\DoxyCodeLine{1299   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Formatter>}
\DoxyCodeLine{1300   \textcolor{keyword}{static} \textcolor{keywordtype}{void} format\_custom\_arg(\textcolor{keywordtype}{void}* arg,}
\DoxyCodeLine{1301                                 \textcolor{keyword}{typename} Context::parse\_context\_type\& parse\_ctx,}
\DoxyCodeLine{1302                                 Context\& ctx) \{}
\DoxyCodeLine{1303     \textcolor{keyword}{auto} f = Formatter();}
\DoxyCodeLine{1304     parse\_ctx.advance\_to(f.parse(parse\_ctx));}
\DoxyCodeLine{1305     \textcolor{keyword}{using }qualified\_type =}
\DoxyCodeLine{1306         conditional\_t<has\_const\_formatter<T, Context>(), \textcolor{keyword}{const} T, T>;}
\DoxyCodeLine{1307     ctx.advance\_to(f.format(*\textcolor{keyword}{static\_cast<}qualified\_type*\textcolor{keyword}{>}(arg), ctx));}
\DoxyCodeLine{1308   \}}
\DoxyCodeLine{1309 \};}
\DoxyCodeLine{1310 }
\DoxyCodeLine{1311 \textcolor{comment}{// To minimize the number of types we need to deal with, long is translated}}
\DoxyCodeLine{1312 \textcolor{comment}{// either to int or to long long depending on its size.}}
\DoxyCodeLine{1313 \textcolor{keyword}{enum} \{ long\_short = \textcolor{keyword}{sizeof}(long) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}) \};}
\DoxyCodeLine{1314 \textcolor{keyword}{using }long\_type = conditional\_t<long\_short, int, long long>;}
\DoxyCodeLine{1315 \textcolor{keyword}{using }ulong\_type = conditional\_t<long\_short, unsigned, unsigned long long>;}
\DoxyCodeLine{1316 }
\DoxyCodeLine{1317 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1format__as__result}{format\_as\_result}} \{}
\DoxyCodeLine{1318   \textcolor{keyword}{template} <\textcolor{keyword}{typename} U,}
\DoxyCodeLine{1319             FMT\_ENABLE\_IF(std::is\_enum<U>::value || std::is\_class<U>::value)>}
\DoxyCodeLine{1320   \textcolor{keyword}{static} \textcolor{keyword}{auto} map(U*) -\/> \textcolor{keyword}{decltype}(format\_as(std::declval<U>()));}
\DoxyCodeLine{1321   \textcolor{keyword}{static} \textcolor{keyword}{auto} map(...) -\/> void;}
\DoxyCodeLine{1322 }
\DoxyCodeLine{1323   \textcolor{keyword}{using }type = \textcolor{keyword}{decltype}(map(\textcolor{keyword}{static\_cast<}T*\textcolor{keyword}{>}(\textcolor{keyword}{nullptr})));}
\DoxyCodeLine{1324 \};}
\DoxyCodeLine{1325 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }format\_as\_t = \textcolor{keyword}{typename} format\_as\_result<T>::type;}
\DoxyCodeLine{1326 }
\DoxyCodeLine{1327 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1328 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__format__as}{has\_format\_as}}}
\DoxyCodeLine{1329     : bool\_constant<!std::is\_same<format\_as\_t<T>, void>::value> \{\};}
\DoxyCodeLine{1330 }
\DoxyCodeLine{1331 \textcolor{comment}{// Maps formatting arguments to core types.}}
\DoxyCodeLine{1332 \textcolor{comment}{// arg\_mapper reports errors by returning unformattable instead of using}}
\DoxyCodeLine{1333 \textcolor{comment}{// static\_assert because it's used in the is\_formattable trait.}}
\DoxyCodeLine{1334 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1arg__mapper}{arg\_mapper}} \{}
\DoxyCodeLine{1335   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Context::char\_type;}
\DoxyCodeLine{1336 }
\DoxyCodeLine{1337   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char} val) -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1338   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} val) -\/> \textcolor{keywordtype}{unsigned} \{}
\DoxyCodeLine{1339     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1340   \}}
\DoxyCodeLine{1341   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{short} val) -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1342   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} val) -\/> \textcolor{keywordtype}{unsigned} \{}
\DoxyCodeLine{1343     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1344   \}}
\DoxyCodeLine{1345   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{int} val) -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1346   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} val) -\/> \textcolor{keywordtype}{unsigned} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1347   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{long} val) -\/> long\_type \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1348   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} val) -\/> ulong\_type \{}
\DoxyCodeLine{1349     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1350   \}}
\DoxyCodeLine{1351   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val) -\/> \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1352   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} val)}
\DoxyCodeLine{1353       -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{1354     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1355   \}}
\DoxyCodeLine{1356   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(int128\_opt val) -\/> int128\_opt \{}
\DoxyCodeLine{1357     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1358   \}}
\DoxyCodeLine{1359   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(uint128\_opt val) -\/> uint128\_opt \{}
\DoxyCodeLine{1360     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1361   \}}
\DoxyCodeLine{1362   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{bool} val) -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_same<T, \textcolor{keywordtype}{char}>::value ||}
\DoxyCodeLine{1365                                       std::is\_same<T, \textcolor{keywordtype}{char}\_type>::value)>}
\DoxyCodeLine{1366   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(T val) -\/> char\_type \{}
\DoxyCodeLine{1367     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1368   \}}
\DoxyCodeLine{1369   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, enable\_if\_t<(std::is\_same<T, \textcolor{keywordtype}{wchar\_t}>::value ||}
\DoxyCodeLine{1370 \#ifdef \_\_cpp\_\textcolor{keywordtype}{char8\_t}}
\DoxyCodeLine{1371                                      std::is\_same<T, \textcolor{keywordtype}{char8\_t}>::value ||}
\DoxyCodeLine{1372 \#endif}
\DoxyCodeLine{1373                                      std::is\_same<T, \textcolor{keywordtype}{char16\_t}>::value ||}
\DoxyCodeLine{1374                                      std::is\_same<T, \textcolor{keywordtype}{char32\_t}>::value) \&\&}
\DoxyCodeLine{1375                                         !std::is\_same<T, \textcolor{keywordtype}{char}\_type>::value,}
\DoxyCodeLine{1376                                     \textcolor{keywordtype}{int}> = 0>}
\DoxyCodeLine{1377   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(T) -\/> \mbox{\hyperlink{structdetail_1_1unformattable__char}{unformattable\_char}} \{}
\DoxyCodeLine{1378     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1379   \}}
\DoxyCodeLine{1380 }
\DoxyCodeLine{1381   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{float} val) -\/> \textcolor{keywordtype}{float} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1382   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{double} val) -\/> \textcolor{keywordtype}{double} \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1383   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{long} \textcolor{keywordtype}{double} val) -\/> \textcolor{keywordtype}{long} \textcolor{keywordtype}{double} \{}
\DoxyCodeLine{1384     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1385   \}}
\DoxyCodeLine{1386 }
\DoxyCodeLine{1387   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(char\_type* val) -\/> \textcolor{keyword}{const} char\_type* \{}
\DoxyCodeLine{1388     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1389   \}}
\DoxyCodeLine{1390   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} char\_type* val) -\/> \textcolor{keyword}{const} char\_type* \{}
\DoxyCodeLine{1391     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1392   \}}
\DoxyCodeLine{1393   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1394             FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__string}{is\_string<T>::value}} \&\& !std::is\_pointer<T>::value \&\&}
\DoxyCodeLine{1395                           std::is\_same<char\_type, char\_t<T>>::value)>}
\DoxyCodeLine{1396   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& val)}
\DoxyCodeLine{1397       -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_type>}} \{}
\DoxyCodeLine{1398     \textcolor{keywordflow}{return} to\_string\_view(val);}
\DoxyCodeLine{1399   \}}
\DoxyCodeLine{1400   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T,}
\DoxyCodeLine{1401             FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__string}{is\_string<T>::value}} \&\& !std::is\_pointer<T>::value \&\&}
\DoxyCodeLine{1402                           !std::is\_same<char\_type, char\_t<T>>::value)>}
\DoxyCodeLine{1403   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\&) -\/> \mbox{\hyperlink{structdetail_1_1unformattable__char}{unformattable\_char}} \{}
\DoxyCodeLine{1404     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1405   \}}
\DoxyCodeLine{1406 }
\DoxyCodeLine{1407   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keywordtype}{void}* val) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{ \textcolor{keywordflow}{return} val; \}}
\DoxyCodeLine{1408   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} \textcolor{keywordtype}{void}* val) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{1409     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1410   \}}
\DoxyCodeLine{1411   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(std::nullptr\_t val) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{1412     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1413   \}}
\DoxyCodeLine{1414 }
\DoxyCodeLine{1415   \textcolor{comment}{// Use SFINAE instead of a const T* parameter to avoid a conflict with the}}
\DoxyCodeLine{1416   \textcolor{comment}{// array overload.}}
\DoxyCodeLine{1417   \textcolor{keyword}{template} <}
\DoxyCodeLine{1418       \textcolor{keyword}{typename} T,}
\DoxyCodeLine{1419       FMT\_ENABLE\_IF(}
\DoxyCodeLine{1420           std::is\_pointer<T>::value || std::is\_member\_pointer<T>::value ||}
\DoxyCodeLine{1421           std::is\_function<\textcolor{keyword}{typename} std::remove\_pointer<T>::type>::value ||}
\DoxyCodeLine{1422           (std::is\_convertible<const T\&, const void*>::value \&\&}
\DoxyCodeLine{1423            !std::is\_convertible<const T\&, const char\_type*>::value \&\&}
\DoxyCodeLine{1424            !has\_formatter<T, Context>::value))>}
\DoxyCodeLine{1425   FMT\_CONSTEXPR \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\&) -\/> \mbox{\hyperlink{structdetail_1_1unformattable__pointer}{unformattable\_pointer}} \{}
\DoxyCodeLine{1426     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1427   \}}
\DoxyCodeLine{1428 }
\DoxyCodeLine{1429   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, std::size\_t N,}
\DoxyCodeLine{1430             FMT\_ENABLE\_IF(!std::is\_same<T, wchar\_t>::value)>}
\DoxyCodeLine{1431   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T (\&values)[N]) -\/> \textcolor{keyword}{const} T (\&)[N] \{}
\DoxyCodeLine{1432     \textcolor{keywordflow}{return} values;}
\DoxyCodeLine{1433   \}}
\DoxyCodeLine{1434 }
\DoxyCodeLine{1435   \textcolor{comment}{// Only map owning types because mapping views can be unsafe.}}
\DoxyCodeLine{1436   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U = format\_as\_t<T>,}
\DoxyCodeLine{1437             FMT\_ENABLE\_IF(std::is\_arithmetic<U>::value)>}
\DoxyCodeLine{1438   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& val) -\/> \textcolor{keyword}{decltype}(this-\/>map(U())) \{}
\DoxyCodeLine{1439     \textcolor{keywordflow}{return} map(format\_as(val));}
\DoxyCodeLine{1440   \}}
\DoxyCodeLine{1441 }
\DoxyCodeLine{1442   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U = remove\_const\_t<T>>}
\DoxyCodeLine{1443   \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1arg__mapper_1_1formattable}{formattable}} : bool\_constant<has\_const\_formatter<U, Context>() ||}
\DoxyCodeLine{1444                                      (has\_formatter<U, Context>::value \&\&}
\DoxyCodeLine{1445                                       !std::is\_const<T>::value)> \{\};}
\DoxyCodeLine{1446 }
\DoxyCodeLine{1447   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(formattable<T>::value)>}
\DoxyCodeLine{1448   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} do\_map(T\& val) -\/> T\& \{}
\DoxyCodeLine{1449     \textcolor{keywordflow}{return} val;}
\DoxyCodeLine{1450   \}}
\DoxyCodeLine{1451   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!formattable<T>::value)>}
\DoxyCodeLine{1452   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} do\_map(T\&) -\/> \mbox{\hyperlink{structdetail_1_1unformattable}{unformattable}} \{}
\DoxyCodeLine{1453     \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{1454   \}}
\DoxyCodeLine{1455 }
\DoxyCodeLine{1456   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} U = remove\_const\_t<T>,}
\DoxyCodeLine{1457             FMT\_ENABLE\_IF((std::is\_\textcolor{keyword}{class}<U>::value || std::is\_enum<U>::value ||}
\DoxyCodeLine{1458                            std::is\_union<U>::value) \&\&}
\DoxyCodeLine{1459                           !is\_\textcolor{keywordtype}{string}<U>::value \&\& !is\_\textcolor{keywordtype}{char}<U>::value \&\&}
\DoxyCodeLine{1460                           !is\_named\_arg<U>::value \&\&}
\DoxyCodeLine{1461                           !std::is\_arithmetic<format\_as\_t<U>>::value)>}
\DoxyCodeLine{1462   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(T\& val) -\/> \textcolor{keyword}{decltype}(this-\/>do\_map(val)) \{}
\DoxyCodeLine{1463     \textcolor{keywordflow}{return} do\_map(val);}
\DoxyCodeLine{1464   \}}
\DoxyCodeLine{1465 }
\DoxyCodeLine{1466   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_named\_arg<T>::value)>}
\DoxyCodeLine{1467   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} map(\textcolor{keyword}{const} T\& named\_arg)}
\DoxyCodeLine{1468       -\/> \textcolor{keyword}{decltype}(this-\/>map(named\_arg.value)) \{}
\DoxyCodeLine{1469     \textcolor{keywordflow}{return} map(named\_arg.value);}
\DoxyCodeLine{1470   \}}
\DoxyCodeLine{1471 }
\DoxyCodeLine{1472   \textcolor{keyword}{auto} map(...) -\/> unformattable \{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{1473 \};}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475 \textcolor{comment}{// A type constant after applying arg\_mapper<Context>.}}
\DoxyCodeLine{1476 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1477 \textcolor{keyword}{using }mapped\_type\_constant =}
\DoxyCodeLine{1478     type\_constant<decltype(arg\_mapper<Context>().map(std::declval<const T\&>())),}
\DoxyCodeLine{1479                   \textcolor{keyword}{typename} Context::char\_type>;}
\DoxyCodeLine{1480 }
\DoxyCodeLine{1481 \textcolor{keyword}{enum} \{ packed\_arg\_bits = 4 \};}
\DoxyCodeLine{1482 \textcolor{comment}{// Maximum number of arguments with packed types.}}
\DoxyCodeLine{1483 \textcolor{keyword}{enum} \{ max\_packed\_args = 62 / packed\_arg\_bits \};}
\DoxyCodeLine{1484 enum : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{ is\_unpacked\_bit = 1ULL << 63 \};}
\DoxyCodeLine{1485 enum : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{ has\_named\_args\_bit = 1ULL << 62 \};}
\DoxyCodeLine{1486 }
\DoxyCodeLine{1487 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} InputIt>}
\DoxyCodeLine{1488 \textcolor{keyword}{auto} copy\_str(InputIt begin, InputIt end, \mbox{\hyperlink{classappender}{appender}} out) -\/> \mbox{\hyperlink{classappender}{appender}} \{}
\DoxyCodeLine{1489   get\_container(out).append(begin, end);}
\DoxyCodeLine{1490   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1491 \}}
\DoxyCodeLine{1492 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} InputIt>}
\DoxyCodeLine{1493 \textcolor{keyword}{auto} copy\_str(InputIt begin, InputIt end,}
\DoxyCodeLine{1494               std::back\_insert\_iterator<std::string> out)}
\DoxyCodeLine{1495     -\/> std::back\_insert\_iterator<std::string> \{}
\DoxyCodeLine{1496   get\_container(out).append(begin, end);}
\DoxyCodeLine{1497   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1498 \}}
\DoxyCodeLine{1499 }
\DoxyCodeLine{1500 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} R, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1501 FMT\_CONSTEXPR \textcolor{keyword}{auto} copy\_str(R\&\& rng, OutputIt out) -\/> OutputIt \{}
\DoxyCodeLine{1502   \textcolor{keywordflow}{return} detail::copy\_str<Char>(rng.begin(), rng.end(), out);}
\DoxyCodeLine{1503 \}}
\DoxyCodeLine{1504 }
\DoxyCodeLine{1505 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 500}}
\DoxyCodeLine{1506 \textcolor{comment}{// A workaround for gcc 4.8 to make void\_t work in a SFINAE context.}}
\DoxyCodeLine{1507 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{struct }void\_t\_impl \{ \textcolor{keyword}{using }type = void; \};}
\DoxyCodeLine{1508 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T> \textcolor{keyword}{using }void\_t = \textcolor{keyword}{typename} void\_t\_impl<T...>::type;}
\DoxyCodeLine{1509 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1510 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{using }void\_t = void;}
\DoxyCodeLine{1511 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1512 }
\DoxyCodeLine{1513 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{1514 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__output__iterator}{is\_output\_iterator}} : std::false\_type \{\};}
\DoxyCodeLine{1515 }
\DoxyCodeLine{1516 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1517 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__output__iterator}{is\_output\_iterator}}<}
\DoxyCodeLine{1518     It, T,}
\DoxyCodeLine{1519     void\_t<typename std::iterator\_traits<It>::iterator\_category,}
\DoxyCodeLine{1520            \textcolor{keyword}{decltype}(*std::declval<It>() = std::declval<T>())>>}
\DoxyCodeLine{1521     : std::true\_type \{\};}
\DoxyCodeLine{1522 }
\DoxyCodeLine{1523 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__back__insert__iterator}{is\_back\_insert\_iterator}} : std::false\_type \{\};}
\DoxyCodeLine{1524 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{1525 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__back__insert__iterator}{is\_back\_insert\_iterator<std::back\_insert\_iterator<Container>}}>}
\DoxyCodeLine{1526     : std::true\_type \{\};}
\DoxyCodeLine{1527 }
\DoxyCodeLine{1528 \textcolor{comment}{// A type-\/erased reference to an std::locale to avoid a heavy <locale> include.}}
\DoxyCodeLine{1529 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} \{}
\DoxyCodeLine{1530  \textcolor{keyword}{private}:}
\DoxyCodeLine{1531   \textcolor{keyword}{const} \textcolor{keywordtype}{void}* locale\_;  \textcolor{comment}{// A type-\/erased pointer to std::locale.}}
\DoxyCodeLine{1532 }
\DoxyCodeLine{1533  \textcolor{keyword}{public}:}
\DoxyCodeLine{1534   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}}() : locale\_(\textcolor{keyword}{nullptr}) \{\}}
\DoxyCodeLine{1535   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale> \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}}(\textcolor{keyword}{const} Locale\& loc);}
\DoxyCodeLine{1536 }
\DoxyCodeLine{1537   \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} locale\_ != \textcolor{keyword}{nullptr}; \}}
\DoxyCodeLine{1538 }
\DoxyCodeLine{1539   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale> \textcolor{keyword}{auto} get() \textcolor{keyword}{const} -\/> Locale;}
\DoxyCodeLine{1540 \};}
\DoxyCodeLine{1541 }
\DoxyCodeLine{1542 \textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} encode\_types() -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{1543   \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{1544 \}}
\DoxyCodeLine{1545 }
\DoxyCodeLine{1546 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} Arg, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{1547 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} encode\_types() -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{1548   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(mapped\_type\_constant<Arg, Context>::value) |}
\DoxyCodeLine{1549          (encode\_types<Context, Args...>() << packed\_arg\_bits);}
\DoxyCodeLine{1550 \}}
\DoxyCodeLine{1551 }
\DoxyCodeLine{1552 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr)}}
\DoxyCodeLine{1553 \textcolor{comment}{// This type is intentionally undefined, only used for errors}}
\DoxyCodeLine{1554 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }type\_is\_unformattable\_for;}
\DoxyCodeLine{1555 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1556 }
\DoxyCodeLine{1557 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} PACKED, \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(PACKED)>}
\DoxyCodeLine{1558 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} make\_arg(T\& val) -\/> value<Context> \{}
\DoxyCodeLine{1559   \textcolor{keyword}{using }arg\_type = remove\_cvref\_t<decltype(arg\_mapper<Context>().map(val))>;}
\DoxyCodeLine{1560 }
\DoxyCodeLine{1561   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} formattable\_char =}
\DoxyCodeLine{1562       !std::is\_same<arg\_type, unformattable\_char>::value;}
\DoxyCodeLine{1563   \textcolor{keyword}{static\_assert}(formattable\_char, \textcolor{stringliteral}{"{}Mixing character types is disallowed."{}});}
\DoxyCodeLine{1564 }
\DoxyCodeLine{1565   \textcolor{comment}{// Formatting of arbitrary pointers is disallowed. If you want to format a}}
\DoxyCodeLine{1566   \textcolor{comment}{// pointer cast it to `void*` or `const void*`. In particular, this forbids}}
\DoxyCodeLine{1567   \textcolor{comment}{// formatting of `[const] volatile char*` printed as bool by iostreams.}}
\DoxyCodeLine{1568   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} formattable\_pointer =}
\DoxyCodeLine{1569       !std::is\_same<arg\_type, unformattable\_pointer>::value;}
\DoxyCodeLine{1570   \textcolor{keyword}{static\_assert}(formattable\_pointer,}
\DoxyCodeLine{1571                 \textcolor{stringliteral}{"{}Formatting of non-\/void pointers is disallowed."{}});}
\DoxyCodeLine{1572 }
\DoxyCodeLine{1573   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} formattable = !std::is\_same<arg\_type, unformattable>::value;}
\DoxyCodeLine{1574 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr)}}
\DoxyCodeLine{1575   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (!formattable) \{}
\DoxyCodeLine{1576     type\_is\_unformattable\_for<T, typename Context::char\_type> \_;}
\DoxyCodeLine{1577   \}}
\DoxyCodeLine{1578 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1579   \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{1580       formattable,}
\DoxyCodeLine{1581       \textcolor{stringliteral}{"{}Cannot format an argument. To make type T formattable provide a "{}}}
\DoxyCodeLine{1582       \textcolor{stringliteral}{"{}formatter<T> specialization: https://fmt.dev/latest/api.html\#udt"{}});}
\DoxyCodeLine{1583   \textcolor{keywordflow}{return} \{arg\_mapper<Context>().map(val)\};}
\DoxyCodeLine{1584 \}}
\DoxyCodeLine{1585 }
\DoxyCodeLine{1586 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1587 FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_arg(T\& val) -\/> \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \{}
\DoxyCodeLine{1588   \textcolor{keyword}{auto} arg = \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}();}
\DoxyCodeLine{1589   arg.type\_ = mapped\_type\_constant<T, Context>::value;}
\DoxyCodeLine{1590   arg.value\_ = make\_arg<true, Context>(val);}
\DoxyCodeLine{1591   \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1592 \}}
\DoxyCodeLine{1593 }
\DoxyCodeLine{1594 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} PACKED, \textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!PACKED)>}
\DoxyCodeLine{1595 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} make\_arg(T\& val) -\/> \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}} \{}
\DoxyCodeLine{1596   \textcolor{keywordflow}{return} make\_arg<Context>(val);}
\DoxyCodeLine{1597 \}}
\DoxyCodeLine{1598 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{1599 FMT\_BEGIN\_EXPORT}
\DoxyCodeLine{1600 }
\DoxyCodeLine{1601 \textcolor{comment}{// A formatting argument. It is a trivially copyable/constructible type to}}
\DoxyCodeLine{1602 \textcolor{comment}{// allow storage in basic\_memory\_buffer.}}
\DoxyCodeLine{1603 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}} \{}
\DoxyCodeLine{1604  \textcolor{keyword}{private}:}
\DoxyCodeLine{1605   \mbox{\hyperlink{classdetail_1_1value}{detail::value<Context>}} value\_;}
\DoxyCodeLine{1606   detail::type type\_;}
\DoxyCodeLine{1607 }
\DoxyCodeLine{1608   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ContextType, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1609   \textcolor{keyword}{friend} FMT\_CONSTEXPR \textcolor{keyword}{auto} detail::make\_arg(T\& value)}
\DoxyCodeLine{1610       -\/> \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<ContextType>}};}
\DoxyCodeLine{1611 }
\DoxyCodeLine{1612   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Visitor, \textcolor{keyword}{typename} Ctx>}
\DoxyCodeLine{1613   \textcolor{keyword}{friend} FMT\_CONSTEXPR \textcolor{keyword}{auto} visit\_format\_arg(Visitor\&\& vis,}
\DoxyCodeLine{1614                                              \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Ctx>}}\& arg)}
\DoxyCodeLine{1615       -\/> \textcolor{keyword}{decltype}(vis(0));}
\DoxyCodeLine{1616 }
\DoxyCodeLine{1617   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<Context>;}
\DoxyCodeLine{1618   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classdynamic__format__arg__store}{dynamic\_format\_arg\_store}}<Context>;}
\DoxyCodeLine{1619 }
\DoxyCodeLine{1620   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Context::char\_type;}
\DoxyCodeLine{1621 }
\DoxyCodeLine{1622   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} NUM\_ARGS, \textcolor{keywordtype}{size\_t} NUM\_NAMED\_ARGS>}
\DoxyCodeLine{1623   \textcolor{keyword}{friend} \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1arg__data}{detail::arg\_data}};}
\DoxyCodeLine{1624 }
\DoxyCodeLine{1625   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}}(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1named__arg__info}{detail::named\_arg\_info<char\_type>}}* args, \textcolor{keywordtype}{size\_t} size)}
\DoxyCodeLine{1626       : value\_(args, size) \{\}}
\DoxyCodeLine{1627 }
\DoxyCodeLine{1628  \textcolor{keyword}{public}:}
\DoxyCodeLine{1629   \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__arg_1_1handle}{handle}} \{}
\DoxyCodeLine{1630    \textcolor{keyword}{public}:}
\DoxyCodeLine{1631     \textcolor{keyword}{explicit} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{handle}}(\mbox{\hyperlink{structdetail_1_1custom__value}{detail::custom\_value<Context>}} custom) : custom\_(custom) \{\}}
\DoxyCodeLine{1632 }
\DoxyCodeLine{1633     \textcolor{keywordtype}{void} format(\textcolor{keyword}{typename} Context::parse\_context\_type\& parse\_ctx,}
\DoxyCodeLine{1634                 Context\& ctx)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{1635       custom\_.format(custom\_.value, parse\_ctx, ctx);}
\DoxyCodeLine{1636     \}}
\DoxyCodeLine{1637 }
\DoxyCodeLine{1638    \textcolor{keyword}{private}:}
\DoxyCodeLine{1639     \mbox{\hyperlink{structdetail_1_1custom__value}{detail::custom\_value<Context>}} custom\_;}
\DoxyCodeLine{1640   \};}
\DoxyCodeLine{1641 }
\DoxyCodeLine{1642   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}}() : type\_(detail::type::none\_type) \{\}}
\DoxyCodeLine{1643 }
\DoxyCodeLine{1644   \textcolor{keyword}{constexpr} \textcolor{keyword}{explicit} \textcolor{keyword}{operator} bool() const noexcept \{}
\DoxyCodeLine{1645     \textcolor{keywordflow}{return} type\_ != detail::type::none\_type;}
\DoxyCodeLine{1646   \}}
\DoxyCodeLine{1647 }
\DoxyCodeLine{1648   \textcolor{keyword}{auto} type() const -\/> detail::type \{ \textcolor{keywordflow}{return} type\_; \}}
\DoxyCodeLine{1649 }
\DoxyCodeLine{1650   \textcolor{keyword}{auto} is\_integral() const -\/> \textcolor{keywordtype}{bool} \{ \textcolor{keywordflow}{return} detail::is\_integral\_type(type\_); \}}
\DoxyCodeLine{1651   \textcolor{keyword}{auto} is\_arithmetic() const -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1652     \textcolor{keywordflow}{return} detail::is\_arithmetic\_type(type\_);}
\DoxyCodeLine{1653   \}}
\DoxyCodeLine{1654 \};}
\DoxyCodeLine{1655 }
\DoxyCodeLine{1663 FMT\_EXPORT}
\DoxyCodeLine{1664 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Visitor, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{1665 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} visit\_format\_arg(}
\DoxyCodeLine{1666     Visitor\&\& vis, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}\& arg) -\/> \textcolor{keyword}{decltype}(vis(0)) \{}
\DoxyCodeLine{1667   \textcolor{keywordflow}{switch} (arg.type\_) \{}
\DoxyCodeLine{1668   \textcolor{keywordflow}{case} detail::type::none\_type:}
\DoxyCodeLine{1669     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1670   \textcolor{keywordflow}{case} detail::type::int\_type:}
\DoxyCodeLine{1671     \textcolor{keywordflow}{return} vis(arg.value\_.int\_value);}
\DoxyCodeLine{1672   \textcolor{keywordflow}{case} detail::type::uint\_type:}
\DoxyCodeLine{1673     \textcolor{keywordflow}{return} vis(arg.value\_.uint\_value);}
\DoxyCodeLine{1674   \textcolor{keywordflow}{case} detail::type::long\_long\_type:}
\DoxyCodeLine{1675     \textcolor{keywordflow}{return} vis(arg.value\_.long\_long\_value);}
\DoxyCodeLine{1676   \textcolor{keywordflow}{case} detail::type::ulong\_long\_type:}
\DoxyCodeLine{1677     \textcolor{keywordflow}{return} vis(arg.value\_.ulong\_long\_value);}
\DoxyCodeLine{1678   \textcolor{keywordflow}{case} detail::type::int128\_type:}
\DoxyCodeLine{1679     \textcolor{keywordflow}{return} vis(detail::convert\_for\_visit(arg.value\_.int128\_value));}
\DoxyCodeLine{1680   \textcolor{keywordflow}{case} detail::type::uint128\_type:}
\DoxyCodeLine{1681     \textcolor{keywordflow}{return} vis(detail::convert\_for\_visit(arg.value\_.uint128\_value));}
\DoxyCodeLine{1682   \textcolor{keywordflow}{case} detail::type::bool\_type:}
\DoxyCodeLine{1683     \textcolor{keywordflow}{return} vis(arg.value\_.bool\_value);}
\DoxyCodeLine{1684   \textcolor{keywordflow}{case} detail::type::char\_type:}
\DoxyCodeLine{1685     \textcolor{keywordflow}{return} vis(arg.value\_.char\_value);}
\DoxyCodeLine{1686   \textcolor{keywordflow}{case} detail::type::float\_type:}
\DoxyCodeLine{1687     \textcolor{keywordflow}{return} vis(arg.value\_.float\_value);}
\DoxyCodeLine{1688   \textcolor{keywordflow}{case} detail::type::double\_type:}
\DoxyCodeLine{1689     \textcolor{keywordflow}{return} vis(arg.value\_.double\_value);}
\DoxyCodeLine{1690   \textcolor{keywordflow}{case} detail::type::long\_double\_type:}
\DoxyCodeLine{1691     \textcolor{keywordflow}{return} vis(arg.value\_.long\_double\_value);}
\DoxyCodeLine{1692   \textcolor{keywordflow}{case} detail::type::cstring\_type:}
\DoxyCodeLine{1693     \textcolor{keywordflow}{return} vis(arg.value\_.string.data);}
\DoxyCodeLine{1694   \textcolor{keywordflow}{case} detail::type::string\_type:}
\DoxyCodeLine{1695     \textcolor{keyword}{using }sv = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<typename Context::char\_type>}};}
\DoxyCodeLine{1696     \textcolor{keywordflow}{return} vis(sv(arg.value\_.string.data, arg.value\_.string.size));}
\DoxyCodeLine{1697   \textcolor{keywordflow}{case} detail::type::pointer\_type:}
\DoxyCodeLine{1698     \textcolor{keywordflow}{return} vis(arg.value\_.pointer);}
\DoxyCodeLine{1699   \textcolor{keywordflow}{case} detail::type::custom\_type:}
\DoxyCodeLine{1700     \textcolor{keywordflow}{return} vis(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<Context>::handle}}(arg.value\_.custom));}
\DoxyCodeLine{1701   \}}
\DoxyCodeLine{1702   \textcolor{keywordflow}{return} vis(\mbox{\hyperlink{structmonostate}{monostate}}());}
\DoxyCodeLine{1703 \}}
\DoxyCodeLine{1704 }
\DoxyCodeLine{1705 \textcolor{comment}{// Formatting context.}}
\DoxyCodeLine{1706 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}} \{}
\DoxyCodeLine{1707  \textcolor{keyword}{private}:}
\DoxyCodeLine{1708   OutputIt out\_;}
\DoxyCodeLine{1709   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_format\_context>}} args\_;}
\DoxyCodeLine{1710   \mbox{\hyperlink{classdetail_1_1locale__ref}{detail::locale\_ref}} loc\_;}
\DoxyCodeLine{1711 }
\DoxyCodeLine{1712  \textcolor{keyword}{public}:}
\DoxyCodeLine{1713   \textcolor{keyword}{using }iterator = OutputIt;}
\DoxyCodeLine{1714   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__arg}{format\_arg}} = \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<basic\_format\_context>}};}
\DoxyCodeLine{1715   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__args}{format\_args}} = \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<basic\_format\_context>}};}
\DoxyCodeLine{1716   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__parse__context}{parse\_context\_type}} = \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}};}
\DoxyCodeLine{1717   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }\mbox{\hyperlink{structformatter}{formatter\_type}} = \mbox{\hyperlink{structformatter}{formatter<T, Char>}};}
\DoxyCodeLine{1718 }
\DoxyCodeLine{1720   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__context_a71fea7d34edb618df612644dfd02a896}{char\_type}} = Char;}
\DoxyCodeLine{1721 }
\DoxyCodeLine{1722   \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}}(\mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}}\&\&) = \textcolor{keywordflow}{default};}
\DoxyCodeLine{1723   \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1724   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{1729   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__context_af9f83b3b640bc3cb8d6cb93332bb27a1}{basic\_format\_context}}(OutputIt out, \mbox{\hyperlink{classbasic__format__args}{format\_args}} ctx\_args,}
\DoxyCodeLine{1730                                  \mbox{\hyperlink{classdetail_1_1locale__ref}{detail::locale\_ref}} loc = \{\})}
\DoxyCodeLine{1731       : out\_(out), args\_(ctx\_args), loc\_(loc) \{\}}
\DoxyCodeLine{1732 }
\DoxyCodeLine{1733   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} arg(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \textcolor{keyword}{const} -\/> format\_arg \{ \textcolor{keywordflow}{return} args\_.\mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{1734   FMT\_CONSTEXPR \textcolor{keyword}{auto} arg(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) -\/> format\_arg \{}
\DoxyCodeLine{1735     \textcolor{keywordflow}{return} args\_.\mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(name);}
\DoxyCodeLine{1736   \}}
\DoxyCodeLine{1737   FMT\_CONSTEXPR \textcolor{keyword}{auto} arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1738     \textcolor{keywordflow}{return} args\_.get\_id(name);}
\DoxyCodeLine{1739   \}}
\DoxyCodeLine{1740   \textcolor{keyword}{auto} args() const -\/> const \mbox{\hyperlink{classbasic__format__args}{format\_args}}\& \{ \textcolor{keywordflow}{return} args\_; \}}
\DoxyCodeLine{1741 }
\DoxyCodeLine{1742   FMT\_CONSTEXPR \textcolor{keyword}{auto} error\_handler() -\/> \mbox{\hyperlink{structdetail_1_1error__handler}{detail::error\_handler}} \{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{1743   \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{ error\_handler().on\_error(message); \}}
\DoxyCodeLine{1744 }
\DoxyCodeLine{1745   \textcolor{comment}{// Returns an iterator to the beginning of the output range.}}
\DoxyCodeLine{1746   FMT\_CONSTEXPR \textcolor{keyword}{auto} out() -\/> iterator \{ \textcolor{keywordflow}{return} out\_; \}}
\DoxyCodeLine{1747 }
\DoxyCodeLine{1748   \textcolor{comment}{// Advances the begin iterator to ``it``.}}
\DoxyCodeLine{1749   \textcolor{keywordtype}{void} advance\_to(iterator it) \{}
\DoxyCodeLine{1750     \textcolor{keywordflow}{if} (!\mbox{\hyperlink{structdetail_1_1is__back__insert__iterator}{detail::is\_back\_insert\_iterator<iterator>}}()) out\_ = it;}
\DoxyCodeLine{1751   \}}
\DoxyCodeLine{1752 }
\DoxyCodeLine{1753   FMT\_CONSTEXPR \textcolor{keyword}{auto} locale() -\/> \mbox{\hyperlink{classdetail_1_1locale__ref}{detail::locale\_ref}} \{ \textcolor{keywordflow}{return} loc\_; \}}
\DoxyCodeLine{1754 \};}
\DoxyCodeLine{1755 }
\DoxyCodeLine{1756 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1757 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__context}{buffer\_context}} =}
\DoxyCodeLine{1758     \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<detail::buffer\_appender<Char>}}, Char>;}
\DoxyCodeLine{1759 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__context}{format\_context}} = \mbox{\hyperlink{classbasic__format__context}{buffer\_context<char>}};}
\DoxyCodeLine{1760 }
\DoxyCodeLine{1761 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{1762 \textcolor{keyword}{using }is\_formattable = bool\_constant<!std::is\_base\_of<}
\DoxyCodeLine{1763     \mbox{\hyperlink{structdetail_1_1unformattable}{detail::unformattable}}, \textcolor{keyword}{decltype}(\mbox{\hyperlink{structdetail_1_1arg__mapper}{detail::arg\_mapper<buffer\_context<Char>}}>()}
\DoxyCodeLine{1764                                         .map(std::declval<T\&>()))>::value>;}
\DoxyCodeLine{1765 }
\DoxyCodeLine{1773 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{1774 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}}
\DoxyCodeLine{1775 \#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}
\DoxyCodeLine{1776     \textcolor{comment}{// Workaround a GCC template argument substitution bug.}}
\DoxyCodeLine{1777     : \textcolor{keyword}{public} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}}}
\DoxyCodeLine{1778 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1779 \{}
\DoxyCodeLine{1780  \textcolor{keyword}{private}:}
\DoxyCodeLine{1781   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} num\_args = \textcolor{keyword}{sizeof}...(Args);}
\DoxyCodeLine{1782   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} num\_named\_args = detail::count\_named\_args<\mbox{\hyperlink{classArgs}{Args}}...>();}
\DoxyCodeLine{1783   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_packed = num\_args <= detail::max\_packed\_args;}
\DoxyCodeLine{1784 }
\DoxyCodeLine{1785   \textcolor{keyword}{using }value\_type = conditional\_t<is\_packed, detail::value<Context>,}
\DoxyCodeLine{1786                                    \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}}>;}
\DoxyCodeLine{1787 }
\DoxyCodeLine{1788   \mbox{\hyperlink{structdetail_1_1arg__data}{detail::arg\_data}}<value\_type, \textcolor{keyword}{typename} Context::char\_type, num\_args,}
\DoxyCodeLine{1789                    num\_named\_args>}
\DoxyCodeLine{1790       data\_;}
\DoxyCodeLine{1791 }
\DoxyCodeLine{1792   \textcolor{keyword}{friend} \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<Context>;}
\DoxyCodeLine{1793 }
\DoxyCodeLine{1794   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc =}
\DoxyCodeLine{1795       (is\_packed ? detail::encode\_types<Context, \mbox{\hyperlink{classArgs}{Args}}...>()}
\DoxyCodeLine{1796                  : detail::is\_unpacked\_bit | num\_args) |}
\DoxyCodeLine{1797       (num\_named\_args != 0}
\DoxyCodeLine{1798            ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(detail::has\_named\_args\_bit)}
\DoxyCodeLine{1799            : 0);}
\DoxyCodeLine{1800 }
\DoxyCodeLine{1801  \textcolor{keyword}{public}:}
\DoxyCodeLine{1802   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1803   FMT\_CONSTEXPR FMT\_INLINE \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}(T\&... args)}
\DoxyCodeLine{1804       :}
\DoxyCodeLine{1805 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}}
\DoxyCodeLine{1806         \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<Context>}}(*\textcolor{keyword}{this}),}
\DoxyCodeLine{1807 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1808         data\_\{detail::make\_arg<is\_packed, Context>(args)...\} \{}
\DoxyCodeLine{1809     \textcolor{keywordflow}{if} (detail::const\_check(num\_named\_args != 0))}
\DoxyCodeLine{1810       detail::init\_named\_args(data\_.named\_args(), 0, 0, args...);}
\DoxyCodeLine{1811   \}}
\DoxyCodeLine{1812 \};}
\DoxyCodeLine{1813 }
\DoxyCodeLine{1822 \textcolor{comment}{// Arguments are taken by lvalue references to avoid some lifetime issues.}}
\DoxyCodeLine{1823 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context = \mbox{\hyperlink{classbasic__format__context}{format\_context}}, \textcolor{keyword}{typename}... T>}
\DoxyCodeLine{1824 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} make\_format\_args(T\&... args)}
\DoxyCodeLine{1825     -\/> \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<Context, remove\_cvref\_t<T>}}...> \{}
\DoxyCodeLine{1826   \textcolor{keywordflow}{return} \{args...\};}
\DoxyCodeLine{1827 \}}
\DoxyCodeLine{1828 }
\DoxyCodeLine{1840 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1841 \textcolor{keyword}{inline} \textcolor{keyword}{auto} arg(\textcolor{keyword}{const} Char* name, \textcolor{keyword}{const} T\& arg) -\/> \mbox{\hyperlink{structdetail_1_1named__arg}{detail::named\_arg<Char, T>}} \{}
\DoxyCodeLine{1842   \textcolor{keyword}{static\_assert}(!\mbox{\hyperlink{structdetail_1_1is__named__arg}{detail::is\_named\_arg<T>}}(), \textcolor{stringliteral}{"{}nested named arguments"{}});}
\DoxyCodeLine{1843   \textcolor{keywordflow}{return} \{name, arg\};}
\DoxyCodeLine{1844 \}}
\DoxyCodeLine{1845 FMT\_END\_EXPORT}
\DoxyCodeLine{1846 }
\DoxyCodeLine{1857 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}} \{}
\DoxyCodeLine{1858  \textcolor{keyword}{public}:}
\DoxyCodeLine{1859   \textcolor{keyword}{using }size\_type = int;}
\DoxyCodeLine{1860   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__arg}{format\_arg}} = \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<Context>}};}
\DoxyCodeLine{1861 }
\DoxyCodeLine{1862  \textcolor{keyword}{private}:}
\DoxyCodeLine{1863   \textcolor{comment}{// A descriptor that contains information about formatting arguments.}}
\DoxyCodeLine{1864   \textcolor{comment}{// If the number of arguments is less or equal to max\_packed\_args then}}
\DoxyCodeLine{1865   \textcolor{comment}{// argument types are passed in the descriptor. This reduces binary code size}}
\DoxyCodeLine{1866   \textcolor{comment}{// per formatting function call.}}
\DoxyCodeLine{1867   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc\_;}
\DoxyCodeLine{1868   \textcolor{keyword}{union }\{}
\DoxyCodeLine{1869     \textcolor{comment}{// If is\_packed() returns true then argument values are stored in values\_;}}
\DoxyCodeLine{1870     \textcolor{comment}{// otherwise they are stored in args\_. This is done to improve cache}}
\DoxyCodeLine{1871     \textcolor{comment}{// locality and reduce compiled code size since storing larger objects}}
\DoxyCodeLine{1872     \textcolor{comment}{// may require more code (at least on x86-\/64) even if the same amount of}}
\DoxyCodeLine{1873     \textcolor{comment}{// data is actually copied to stack. It saves \string~10\% on the bloat test.}}
\DoxyCodeLine{1874     \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1value}{detail::value<Context>}}* values\_;}
\DoxyCodeLine{1875     \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}}* args\_;}
\DoxyCodeLine{1876   \};}
\DoxyCodeLine{1877 }
\DoxyCodeLine{1878   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_packed() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1879     \textcolor{keywordflow}{return} (desc\_ \& detail::is\_unpacked\_bit) == 0;}
\DoxyCodeLine{1880   \}}
\DoxyCodeLine{1881   \textcolor{keyword}{auto} has\_named\_args() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1882     \textcolor{keywordflow}{return} (desc\_ \& detail::has\_named\_args\_bit) != 0;}
\DoxyCodeLine{1883   \}}
\DoxyCodeLine{1884 }
\DoxyCodeLine{1885   FMT\_CONSTEXPR \textcolor{keyword}{auto} type(\textcolor{keywordtype}{int} index) \textcolor{keyword}{const} -\/> detail::type \{}
\DoxyCodeLine{1886     \textcolor{keywordtype}{int} shift = index * detail::packed\_arg\_bits;}
\DoxyCodeLine{1887     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} mask = (1 << detail::packed\_arg\_bits) -\/ 1;}
\DoxyCodeLine{1888     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}detail::type\textcolor{keyword}{>}((desc\_ >> shift) \& mask);}
\DoxyCodeLine{1889   \}}
\DoxyCodeLine{1890 }
\DoxyCodeLine{1891   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc,}
\DoxyCodeLine{1892                                          \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1value}{detail::value<Context>}}* values)}
\DoxyCodeLine{1893       : desc\_(desc), values\_(values) \{\}}
\DoxyCodeLine{1894   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} desc, \textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}}* args)}
\DoxyCodeLine{1895       : desc\_(desc), args\_(args) \{\}}
\DoxyCodeLine{1896 }
\DoxyCodeLine{1897  \textcolor{keyword}{public}:}
\DoxyCodeLine{1898   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}() : desc\_(0), args\_(\textcolor{keyword}{nullptr}) \{\}}
\DoxyCodeLine{1899 }
\DoxyCodeLine{1905   \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{1906   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classbasic__format__args_ac40bdd2deb4a1000df76553387588775}{basic\_format\_args}}(}
\DoxyCodeLine{1907       \textcolor{keyword}{const} \mbox{\hyperlink{classformat__arg__store}{format\_arg\_store<Context, Args...>}}\& store)}
\DoxyCodeLine{1908       : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(\mbox{\hyperlink{classformat__arg__store}{format\_arg\_store}}<Context, \mbox{\hyperlink{classArgs}{Args}}...>::desc,}
\DoxyCodeLine{1909                           store.data\_.args()) \{\}}
\DoxyCodeLine{1910 }
\DoxyCodeLine{1917   \textcolor{keyword}{constexpr} FMT\_INLINE \mbox{\hyperlink{classbasic__format__args_a69dd0f6fb0e95f42f57cc3bfb095a397}{basic\_format\_args}}(}
\DoxyCodeLine{1918       \textcolor{keyword}{const} \mbox{\hyperlink{classdynamic__format__arg__store}{dynamic\_format\_arg\_store<Context>}}\& store)}
\DoxyCodeLine{1919       : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(store.get\_types(), store.data()) \{\}}
\DoxyCodeLine{1920 }
\DoxyCodeLine{1926   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classbasic__format__args_a1b6a098d11577f454964b51c2d7f9027}{basic\_format\_args}}(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__format__arg}{format\_arg}}* args, \textcolor{keywordtype}{int} count)}
\DoxyCodeLine{1927       : \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}(detail::is\_unpacked\_bit | detail::to\_unsigned(count),}
\DoxyCodeLine{1928                           args) \{\}}
\DoxyCodeLine{1929 }
\DoxyCodeLine{1931   FMT\_CONSTEXPR \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} \{}
\DoxyCodeLine{1932     \mbox{\hyperlink{classbasic__format__arg}{format\_arg}} arg;}
\DoxyCodeLine{1933     \textcolor{keywordflow}{if} (!is\_packed()) \{}
\DoxyCodeLine{1934       \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} < max\_size()) arg = args\_[id];}
\DoxyCodeLine{1935       \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1936     \}}
\DoxyCodeLine{1937     \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id} >= detail::max\_packed\_args) \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1938     arg.type\_ = type(\textcolor{keywordtype}{id});}
\DoxyCodeLine{1939     \textcolor{keywordflow}{if} (arg.type\_ == detail::type::none\_type) \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1940     arg.value\_ = values\_[id];}
\DoxyCodeLine{1941     \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{1942   \}}
\DoxyCodeLine{1943 }
\DoxyCodeLine{1944   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1945   \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) \textcolor{keyword}{const} -\/> format\_arg \{}
\DoxyCodeLine{1946     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = get\_id(name);}
\DoxyCodeLine{1947     \textcolor{keywordflow}{return} \textcolor{keywordtype}{id} >= 0 ? \mbox{\hyperlink{classbasic__format__args_a3339d3a4e4daaf7bb0de1a8084e7f086}{get}}(\textcolor{keywordtype}{id}) : format\_arg();}
\DoxyCodeLine{1948   \}}
\DoxyCodeLine{1949 }
\DoxyCodeLine{1950   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1951   \textcolor{keyword}{auto} get\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1952     \textcolor{keywordflow}{if} (!has\_named\_args()) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1953     \textcolor{keyword}{const} \textcolor{keyword}{auto}\& named\_args =}
\DoxyCodeLine{1954         (is\_packed() ? values\_[-\/1] : args\_[-\/1].value\_).named\_args;}
\DoxyCodeLine{1955     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < named\_args.size; ++i) \{}
\DoxyCodeLine{1956       \textcolor{keywordflow}{if} (named\_args.data[i].name == name) \textcolor{keywordflow}{return} named\_args.data[i].id;}
\DoxyCodeLine{1957     \}}
\DoxyCodeLine{1958     \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{1959   \}}
\DoxyCodeLine{1960 }
\DoxyCodeLine{1961   \textcolor{keyword}{auto} max\_size() const -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1962     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} max\_packed = detail::max\_packed\_args;}
\DoxyCodeLine{1963     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(is\_packed() ? max\_packed}
\DoxyCodeLine{1964                                         : desc\_ \& \string~detail::is\_unpacked\_bit);}
\DoxyCodeLine{1965   \}}
\DoxyCodeLine{1966 \};}
\DoxyCodeLine{1967 }
\DoxyCodeLine{1969 \textcolor{comment}{// A separate type would result in shorter symbols but break ABI compatibility}}
\DoxyCodeLine{1970 \textcolor{comment}{// between clang and gcc on ARM (\#1919).}}
\DoxyCodeLine{1971 FMT\_EXPORT \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__args}{format\_args}} = \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<format\_context>}};}
\DoxyCodeLine{1972 }
\DoxyCodeLine{1973 \textcolor{comment}{// We cannot use enum classes as bit fields because of a gcc bug, so we put them}}
\DoxyCodeLine{1974 \textcolor{comment}{// in namespaces instead (https://gcc.gnu.org/bugzilla/show\_bug.cgi?id=61414).}}
\DoxyCodeLine{1975 \textcolor{comment}{// Additionally, if an underlying type is specified, older gcc incorrectly warns}}
\DoxyCodeLine{1976 \textcolor{comment}{// that the type is too small. Both bugs are fixed in gcc 9.3.}}
\DoxyCodeLine{1977 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 903}}
\DoxyCodeLine{1978 \textcolor{preprocessor}{\#  define FMT\_ENUM\_UNDERLYING\_TYPE(type)}}
\DoxyCodeLine{1979 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1980 \textcolor{preprocessor}{\#  define FMT\_ENUM\_UNDERLYING\_TYPE(type) : type}}
\DoxyCodeLine{1981 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1982 \textcolor{keyword}{namespace }align \{}
\DoxyCodeLine{1983 \textcolor{keyword}{enum} type FMT\_ENUM\_UNDERLYING\_TYPE(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})\{none, left, right, center,}
\DoxyCodeLine{1984                                                   numeric\};}
\DoxyCodeLine{1985 \}}
\DoxyCodeLine{1986 \textcolor{keyword}{using }align\_t = align::type;}
\DoxyCodeLine{1987 \textcolor{keyword}{namespace }sign \{}
\DoxyCodeLine{1988 \textcolor{keyword}{enum} type FMT\_ENUM\_UNDERLYING\_TYPE(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char})\{none, minus, plus, space\};}
\DoxyCodeLine{1989 \}}
\DoxyCodeLine{1990 \textcolor{keyword}{using }sign\_t = sign::type;}
\DoxyCodeLine{1991 }
\DoxyCodeLine{1992 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{1993 }
\DoxyCodeLine{1994 \textcolor{comment}{// Workaround an array initialization issue in gcc 4.8.}}
\DoxyCodeLine{1995 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1fill__t}{fill\_t}} \{}
\DoxyCodeLine{1996  \textcolor{keyword}{private}:}
\DoxyCodeLine{1997   \textcolor{keyword}{enum} \{ max\_size = 4 \};}
\DoxyCodeLine{1998   Char data\_[max\_size] = \{Char(\textcolor{charliteral}{' '}), Char(0), Char(0), Char(0)\};}
\DoxyCodeLine{1999   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} size\_ = 1;}
\DoxyCodeLine{2000 }
\DoxyCodeLine{2001  \textcolor{keyword}{public}:}
\DoxyCodeLine{2002   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator=(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s) \{}
\DoxyCodeLine{2003     \textcolor{keyword}{auto} size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{2004     FMT\_ASSERT(size <= max\_size, \textcolor{stringliteral}{"{}invalid fill"{}});}
\DoxyCodeLine{2005     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < size; ++i) data\_[i] = s[i];}
\DoxyCodeLine{2006     size\_ = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(size);}
\DoxyCodeLine{2007   \}}
\DoxyCodeLine{2008 }
\DoxyCodeLine{2009   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} size() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} size\_; \}}
\DoxyCodeLine{2010   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \mbox{\hyperlink{structdetail_1_1data}{data}}() \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} Char* \{ \textcolor{keywordflow}{return} data\_; \}}
\DoxyCodeLine{2011 }
\DoxyCodeLine{2012   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](\textcolor{keywordtype}{size\_t} index) -\/> Char\& \{ \textcolor{keywordflow}{return} data\_[index]; \}}
\DoxyCodeLine{2013   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator[](\textcolor{keywordtype}{size\_t} index) \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} Char\& \{}
\DoxyCodeLine{2014     \textcolor{keywordflow}{return} data\_[index];}
\DoxyCodeLine{2015   \}}
\DoxyCodeLine{2016 \};}
\DoxyCodeLine{2017 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{2018 }
\DoxyCodeLine{2019 \textcolor{keyword}{enum class} presentation\_type : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{2020   none,}
\DoxyCodeLine{2021   dec,             \textcolor{comment}{// 'd'}}
\DoxyCodeLine{2022   oct,             \textcolor{comment}{// 'o'}}
\DoxyCodeLine{2023   hex\_lower,       \textcolor{comment}{// 'x'}}
\DoxyCodeLine{2024   hex\_upper,       \textcolor{comment}{// 'X'}}
\DoxyCodeLine{2025   bin\_lower,       \textcolor{comment}{// 'b'}}
\DoxyCodeLine{2026   bin\_upper,       \textcolor{comment}{// 'B'}}
\DoxyCodeLine{2027   hexfloat\_lower,  \textcolor{comment}{// 'a'}}
\DoxyCodeLine{2028   hexfloat\_upper,  \textcolor{comment}{// 'A'}}
\DoxyCodeLine{2029   exp\_lower,       \textcolor{comment}{// 'e'}}
\DoxyCodeLine{2030   exp\_upper,       \textcolor{comment}{// 'E'}}
\DoxyCodeLine{2031   fixed\_lower,     \textcolor{comment}{// 'f'}}
\DoxyCodeLine{2032   fixed\_upper,     \textcolor{comment}{// 'F'}}
\DoxyCodeLine{2033   general\_lower,   \textcolor{comment}{// 'g'}}
\DoxyCodeLine{2034   general\_upper,   \textcolor{comment}{// 'G'}}
\DoxyCodeLine{2035   chr,             \textcolor{comment}{// 'c'}}
\DoxyCodeLine{2036   string,          \textcolor{comment}{// 's'}}
\DoxyCodeLine{2037   pointer,         \textcolor{comment}{// 'p'}}
\DoxyCodeLine{2038   debug            \textcolor{comment}{// '?'}}
\DoxyCodeLine{2039 \};}
\DoxyCodeLine{2040 }
\DoxyCodeLine{2041 \textcolor{comment}{// Format specifiers for built-\/in and string types.}}
\DoxyCodeLine{2042 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}> \textcolor{keyword}{struct }\mbox{\hyperlink{structformat__specs}{format\_specs}} \{}
\DoxyCodeLine{2043   \textcolor{keywordtype}{int} width;}
\DoxyCodeLine{2044   \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{2045   presentation\_type type;}
\DoxyCodeLine{2046   align\_t align : 4;}
\DoxyCodeLine{2047   sign\_t sign : 3;}
\DoxyCodeLine{2048   \textcolor{keywordtype}{bool} alt : 1;  \textcolor{comment}{// Alternate form ('\#').}}
\DoxyCodeLine{2049   \textcolor{keywordtype}{bool} localized : 1;}
\DoxyCodeLine{2050   \mbox{\hyperlink{structdetail_1_1fill__t}{detail::fill\_t<Char>}} fill;}
\DoxyCodeLine{2051 }
\DoxyCodeLine{2052   \textcolor{keyword}{constexpr} \mbox{\hyperlink{structformat__specs}{format\_specs}}()}
\DoxyCodeLine{2053       : width(0),}
\DoxyCodeLine{2054         precision(-\/1),}
\DoxyCodeLine{2055         type(presentation\_type::none),}
\DoxyCodeLine{2056         align(align::none),}
\DoxyCodeLine{2057         sign(sign::none),}
\DoxyCodeLine{2058         alt(\textcolor{keyword}{false}),}
\DoxyCodeLine{2059         localized(\textcolor{keyword}{false}) \{\}}
\DoxyCodeLine{2060 \};}
\DoxyCodeLine{2061 }
\DoxyCodeLine{2062 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{2063 }
\DoxyCodeLine{2064 \textcolor{keyword}{enum class} arg\_id\_kind \{ none, index, name \};}
\DoxyCodeLine{2065 }
\DoxyCodeLine{2066 \textcolor{comment}{// An argument reference.}}
\DoxyCodeLine{2067 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref}} \{}
\DoxyCodeLine{2068   FMT\_CONSTEXPR \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref}}() : kind(arg\_id\_kind::none), val() \{\}}
\DoxyCodeLine{2069 }
\DoxyCodeLine{2070   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref}}(\textcolor{keywordtype}{int} index)}
\DoxyCodeLine{2071       : kind(arg\_id\_kind::index), val(index) \{\}}
\DoxyCodeLine{2072   FMT\_CONSTEXPR \textcolor{keyword}{explicit} \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name)}
\DoxyCodeLine{2073       : kind(arg\_id\_kind::name), val(name) \{\}}
\DoxyCodeLine{2074 }
\DoxyCodeLine{2075   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator=(\textcolor{keywordtype}{int} idx) -\/> \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref}}\& \{}
\DoxyCodeLine{2076     kind = arg\_id\_kind::index;}
\DoxyCodeLine{2077     val.index = idx;}
\DoxyCodeLine{2078     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2079   \}}
\DoxyCodeLine{2080 }
\DoxyCodeLine{2081   arg\_id\_kind kind;}
\DoxyCodeLine{2082   \textcolor{keyword}{union }\mbox{\hyperlink{uniondetail_1_1arg__ref_1_1value}{value}} \{}
\DoxyCodeLine{2083     FMT\_CONSTEXPR \mbox{\hyperlink{uniondetail_1_1arg__ref_1_1value}{value}}(\textcolor{keywordtype}{int} idx = 0) : index(idx) \{\}}
\DoxyCodeLine{2084     FMT\_CONSTEXPR \mbox{\hyperlink{uniondetail_1_1arg__ref_1_1value}{value}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} n) : name(n) \{\}}
\DoxyCodeLine{2085 }
\DoxyCodeLine{2086     \textcolor{keywordtype}{int} index;}
\DoxyCodeLine{2087     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name;}
\DoxyCodeLine{2088   \} val;}
\DoxyCodeLine{2089 \};}
\DoxyCodeLine{2090 }
\DoxyCodeLine{2091 \textcolor{comment}{// Format specifiers with width and precision resolved at formatting rather}}
\DoxyCodeLine{2092 \textcolor{comment}{// than parsing time to allow reusing the same parsed specifiers with}}
\DoxyCodeLine{2093 \textcolor{comment}{// different sets of arguments (precompilation of format strings).}}
\DoxyCodeLine{2094 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{2095 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dynamic__format__specs}{dynamic\_format\_specs}} : \mbox{\hyperlink{structformat__specs}{format\_specs}}<Char> \{}
\DoxyCodeLine{2096   \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref<Char>}} width\_ref;}
\DoxyCodeLine{2097   \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref<Char>}} precision\_ref;}
\DoxyCodeLine{2098 \};}
\DoxyCodeLine{2099 }
\DoxyCodeLine{2100 \textcolor{comment}{// Converts a character to ASCII. Returns '\(\backslash\)0' on conversion failure.}}
\DoxyCodeLine{2101 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<Char>::value)>}
\DoxyCodeLine{2102 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_ascii(Char c) -\/> \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{2103   \textcolor{keywordflow}{return} c <= 0xff ? static\_cast<char>(c) : \textcolor{stringliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2104 \}}
\DoxyCodeLine{2105 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, FMT\_ENABLE\_IF(std::is\_enum<Char>::value)>}
\DoxyCodeLine{2106 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_ascii(Char c) -\/> \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{2107   \textcolor{keywordflow}{return} c <= 0xff ? static\_cast<char>(c) : \textcolor{stringliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2108 \}}
\DoxyCodeLine{2109 }
\DoxyCodeLine{2110 \textcolor{comment}{// Returns the number of code units in a code point or 1 on error.}}
\DoxyCodeLine{2111 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2112 FMT\_CONSTEXPR \textcolor{keyword}{auto} code\_point\_length(\textcolor{keyword}{const} Char* begin) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2113   \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(Char) != 1)) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2114   \textcolor{keyword}{auto} c = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(*begin);}
\DoxyCodeLine{2115   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((0x3a55000000000000ull >> (2 * (c >> 3))) \& 0x3) + 1;}
\DoxyCodeLine{2116 \}}
\DoxyCodeLine{2117 }
\DoxyCodeLine{2118 \textcolor{comment}{// Return the result via the out param to workaround gcc bug 77539.}}
\DoxyCodeLine{2119 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_CONSTEXPR, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Ptr = const T*>}
\DoxyCodeLine{2120 FMT\_CONSTEXPR \textcolor{keyword}{auto} find(Ptr first, Ptr last, T value, Ptr\& out) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2121   \textcolor{keywordflow}{for} (out = first; out != last; ++out) \{}
\DoxyCodeLine{2122     \textcolor{keywordflow}{if} (*out == value) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2123   \}}
\DoxyCodeLine{2124   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2125 \}}
\DoxyCodeLine{2126 }
\DoxyCodeLine{2127 \textcolor{keyword}{template} <>}
\DoxyCodeLine{2128 \textcolor{keyword}{inline} \textcolor{keyword}{auto} find<false, char>(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* first, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* last, \textcolor{keywordtype}{char} value,}
\DoxyCodeLine{2129                               \textcolor{keyword}{const} \textcolor{keywordtype}{char}*\& out) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2130   out = \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(}
\DoxyCodeLine{2131       std::memchr(first, value, to\_unsigned(last -\/ first)));}
\DoxyCodeLine{2132   \textcolor{keywordflow}{return} out != \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2133 \}}
\DoxyCodeLine{2134 }
\DoxyCodeLine{2135 \textcolor{comment}{// Parses the range [begin, end) as an unsigned integer. This function assumes}}
\DoxyCodeLine{2136 \textcolor{comment}{// that the range is non-\/empty and the first character is a digit.}}
\DoxyCodeLine{2137 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2138 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_nonnegative\_int(\textcolor{keyword}{const} Char*\& begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2139                                          \textcolor{keywordtype}{int} error\_value) \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2140   FMT\_ASSERT(begin != end \&\& \textcolor{charliteral}{'0'} <= *begin \&\& *begin <= \textcolor{charliteral}{'9'}, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2141   \textcolor{keywordtype}{unsigned} value = 0, prev = 0;}
\DoxyCodeLine{2142   \textcolor{keyword}{auto} p = begin;}
\DoxyCodeLine{2143   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2144     prev = value;}
\DoxyCodeLine{2145     value = value * 10 + unsigned(*p -\/ \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2146     ++p;}
\DoxyCodeLine{2147   \} \textcolor{keywordflow}{while} (p != end \&\& \textcolor{charliteral}{'0'} <= *p \&\& *p <= \textcolor{charliteral}{'9'});}
\DoxyCodeLine{2148   \textcolor{keyword}{auto} num\_digits = p -\/ begin;}
\DoxyCodeLine{2149   begin = p;}
\DoxyCodeLine{2150   \textcolor{keywordflow}{if} (num\_digits <= std::numeric\_limits<int>::digits10)}
\DoxyCodeLine{2151     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(value);}
\DoxyCodeLine{2152   \textcolor{comment}{// Check for overflow.}}
\DoxyCodeLine{2153   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} max = to\_unsigned((std::numeric\_limits<int>::max)());}
\DoxyCodeLine{2154   \textcolor{keywordflow}{return} num\_digits == std::numeric\_limits<int>::digits10 + 1 \&\&}
\DoxyCodeLine{2155                  prev * 10ull + unsigned(p[-\/1] -\/ \textcolor{charliteral}{'0'}) <= max}
\DoxyCodeLine{2156              ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(value)}
\DoxyCodeLine{2157              : error\_value;}
\DoxyCodeLine{2158 \}}
\DoxyCodeLine{2159 }
\DoxyCodeLine{2160 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} parse\_align(\textcolor{keywordtype}{char} c) -\/> align\_t \{}
\DoxyCodeLine{2161   \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{2162   \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:}
\DoxyCodeLine{2163     \textcolor{keywordflow}{return} align::left;}
\DoxyCodeLine{2164   \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{2165     \textcolor{keywordflow}{return} align::right;}
\DoxyCodeLine{2166   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string^'}:}
\DoxyCodeLine{2167     \textcolor{keywordflow}{return} align::center;}
\DoxyCodeLine{2168   \}}
\DoxyCodeLine{2169   \textcolor{keywordflow}{return} align::none;}
\DoxyCodeLine{2170 \}}
\DoxyCodeLine{2171 }
\DoxyCodeLine{2172 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_name\_start(Char c) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2173   \textcolor{keywordflow}{return} (\textcolor{charliteral}{'a'} <= c \&\& c <= \textcolor{charliteral}{'z'}) || (\textcolor{charliteral}{'A'} <= c \&\& c <= \textcolor{charliteral}{'Z'}) || c == \textcolor{charliteral}{'\_'};}
\DoxyCodeLine{2174 \}}
\DoxyCodeLine{2175 }
\DoxyCodeLine{2176 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2177 FMT\_CONSTEXPR \textcolor{keyword}{auto} do\_parse\_arg\_id(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2178                                    Handler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2179   Char c = *begin;}
\DoxyCodeLine{2180   \textcolor{keywordflow}{if} (c >= \textcolor{charliteral}{'0'} \&\& c <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2181     \textcolor{keywordtype}{int} index = 0;}
\DoxyCodeLine{2182     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} max = (std::numeric\_limits<int>::max)();}
\DoxyCodeLine{2183     \textcolor{keywordflow}{if} (c != \textcolor{charliteral}{'0'})}
\DoxyCodeLine{2184       index = parse\_nonnegative\_int(begin, end, max);}
\DoxyCodeLine{2185     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2186       ++begin;}
\DoxyCodeLine{2187     \textcolor{keywordflow}{if} (begin == end || (*begin != \textcolor{charliteral}{'\}'} \&\& *begin != \textcolor{charliteral}{':'}))}
\DoxyCodeLine{2188       throw\_format\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2189     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2190       handler.on\_index(index);}
\DoxyCodeLine{2191     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2192   \}}
\DoxyCodeLine{2193   \textcolor{keywordflow}{if} (!is\_name\_start(c)) \{}
\DoxyCodeLine{2194     throw\_format\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2195     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2196   \}}
\DoxyCodeLine{2197   \textcolor{keyword}{auto} it = begin;}
\DoxyCodeLine{2198   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2199     ++it;}
\DoxyCodeLine{2200   \} \textcolor{keywordflow}{while} (it != end \&\& (is\_name\_start(*it) || (\textcolor{charliteral}{'0'} <= *it \&\& *it <= \textcolor{charliteral}{'9'})));}
\DoxyCodeLine{2201   handler.on\_name(\{begin, to\_unsigned(it -\/ begin)\});}
\DoxyCodeLine{2202   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2203 \}}
\DoxyCodeLine{2204 }
\DoxyCodeLine{2205 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2206 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} parse\_arg\_id(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2207                                            Handler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2208   FMT\_ASSERT(begin != end, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2209   Char c = *begin;}
\DoxyCodeLine{2210   \textcolor{keywordflow}{if} (c != \textcolor{charliteral}{'\}'} \&\& c != \textcolor{charliteral}{':'}) \textcolor{keywordflow}{return} do\_parse\_arg\_id(begin, end, handler);}
\DoxyCodeLine{2211   handler.on\_auto();}
\DoxyCodeLine{2212   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2213 \}}
\DoxyCodeLine{2214 }
\DoxyCodeLine{2215 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dynamic__spec__id__handler}{dynamic\_spec\_id\_handler}} \{}
\DoxyCodeLine{2216   \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& ctx;}
\DoxyCodeLine{2217   \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref<Char>}}\& ref;}
\DoxyCodeLine{2218 }
\DoxyCodeLine{2219   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_auto() \{}
\DoxyCodeLine{2220     \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = ctx.\mbox{\hyperlink{classbasic__format__parse__context_a152d3961cfbc244624a877d827fc1172}{next\_arg\_id}}();}
\DoxyCodeLine{2221     ref = \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref<Char>}}(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2222     ctx.check\_dynamic\_spec(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2223   \}}
\DoxyCodeLine{2224   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_index(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2225     ref = \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref<Char>}}(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2226     ctx.\mbox{\hyperlink{classbasic__format__parse__context_a83f130644eeb162a932245c95447cf63}{check\_arg\_id}}(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2227     ctx.check\_dynamic\_spec(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2228   \}}
\DoxyCodeLine{2229   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2230     ref = \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref<Char>}}(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2231     ctx.\mbox{\hyperlink{classbasic__format__parse__context_a83f130644eeb162a932245c95447cf63}{check\_arg\_id}}(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2232   \}}
\DoxyCodeLine{2233 \};}
\DoxyCodeLine{2234 }
\DoxyCodeLine{2235 \textcolor{comment}{// Parses [integer | "{}\{"{} [arg\_id] "{}\}"{}].}}
\DoxyCodeLine{2236 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2237 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_dynamic\_spec(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2238                                       \textcolor{keywordtype}{int}\& \mbox{\hyperlink{classdetail_1_1value}{value}}, \mbox{\hyperlink{structdetail_1_1arg__ref}{arg\_ref<Char>}}\& ref,}
\DoxyCodeLine{2239                                       \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& ctx)}
\DoxyCodeLine{2240     -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2241   FMT\_ASSERT(begin != end, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2242   \textcolor{keywordflow}{if} (\textcolor{charliteral}{'0'} <= *begin \&\& *begin <= \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{2243     \textcolor{keywordtype}{int} val = parse\_nonnegative\_int(begin, end, -\/1);}
\DoxyCodeLine{2244     \textcolor{keywordflow}{if} (val != -\/1)}
\DoxyCodeLine{2245       \mbox{\hyperlink{classdetail_1_1value}{value}} = val;}
\DoxyCodeLine{2246     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2247       throw\_format\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{2248   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2249     ++begin;}
\DoxyCodeLine{2250     \textcolor{keyword}{auto} handler = dynamic\_spec\_id\_handler<Char>\{ctx, ref\};}
\DoxyCodeLine{2251     \textcolor{keywordflow}{if} (begin != end) begin = parse\_arg\_id(begin, end, handler);}
\DoxyCodeLine{2252     \textcolor{keywordflow}{if} (begin != end \&\& *begin == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{return} ++begin;}
\DoxyCodeLine{2253     throw\_format\_error(\textcolor{stringliteral}{"{}invalid format string"{}});}
\DoxyCodeLine{2254   \}}
\DoxyCodeLine{2255   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2256 \}}
\DoxyCodeLine{2257 }
\DoxyCodeLine{2258 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2259 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_precision(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2260                                    \textcolor{keywordtype}{int}\& value, arg\_ref<Char>\& ref,}
\DoxyCodeLine{2261                                    \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& ctx)}
\DoxyCodeLine{2262     -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2263   ++begin;}
\DoxyCodeLine{2264   \textcolor{keywordflow}{if} (begin == end || *begin == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2265     throw\_format\_error(\textcolor{stringliteral}{"{}invalid precision"{}});}
\DoxyCodeLine{2266     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2267   \}}
\DoxyCodeLine{2268   \textcolor{keywordflow}{return} parse\_dynamic\_spec(begin, end, value, ref, ctx);}
\DoxyCodeLine{2269 \}}
\DoxyCodeLine{2270 }
\DoxyCodeLine{2271 \textcolor{keyword}{enum class} state \{ start, align, sign, hash, zero, width, precision, locale \};}
\DoxyCodeLine{2272 }
\DoxyCodeLine{2273 \textcolor{comment}{// Parses standard format specifiers.}}
\DoxyCodeLine{2274 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2275 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} parse\_format\_specs(}
\DoxyCodeLine{2276     \textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end, dynamic\_format\_specs<Char>\& specs,}
\DoxyCodeLine{2277     \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& ctx, type arg\_type) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2278   \textcolor{keyword}{auto} c = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2279   \textcolor{keywordflow}{if} (end -\/ begin > 1) \{}
\DoxyCodeLine{2280     \textcolor{keyword}{auto} next = to\_ascii(begin[1]);}
\DoxyCodeLine{2281     c = parse\_align(next) == align::none ? to\_ascii(*begin) : \textcolor{stringliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{2282   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2283     \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2284     c = to\_ascii(*begin);}
\DoxyCodeLine{2285   \}}
\DoxyCodeLine{2286 }
\DoxyCodeLine{2287   \textcolor{keyword}{struct }\{}
\DoxyCodeLine{2288     state current\_state = state::start;}
\DoxyCodeLine{2289     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(state s, \textcolor{keywordtype}{bool} valid = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{2290       \textcolor{keywordflow}{if} (current\_state >= s || !valid)}
\DoxyCodeLine{2291         throw\_format\_error(\textcolor{stringliteral}{"{}invalid format specifier"{}});}
\DoxyCodeLine{2292       current\_state = s;}
\DoxyCodeLine{2293     \}}
\DoxyCodeLine{2294   \} enter\_state;}
\DoxyCodeLine{2295 }
\DoxyCodeLine{2296   \textcolor{keyword}{using }pres = presentation\_type;}
\DoxyCodeLine{2297   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} integral\_set = sint\_set | uint\_set | bool\_set | char\_set;}
\DoxyCodeLine{2298   \textcolor{keyword}{struct }\{}
\DoxyCodeLine{2299     \textcolor{keyword}{const} Char*\& begin;}
\DoxyCodeLine{2300     dynamic\_format\_specs<Char>\& specs;}
\DoxyCodeLine{2301     type arg\_type;}
\DoxyCodeLine{2302 }
\DoxyCodeLine{2303     FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(pres type, \textcolor{keywordtype}{int} set) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2304       \textcolor{keywordflow}{if} (!in(arg\_type, set)) throw\_format\_error(\textcolor{stringliteral}{"{}invalid format specifier"{}});}
\DoxyCodeLine{2305       specs.type = type;}
\DoxyCodeLine{2306       \textcolor{keywordflow}{return} begin + 1;}
\DoxyCodeLine{2307     \}}
\DoxyCodeLine{2308   \} parse\_presentation\_type\{begin, specs, arg\_type\};}
\DoxyCodeLine{2309 }
\DoxyCodeLine{2310   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2311     \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{2312     \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:}
\DoxyCodeLine{2313     \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{2314     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string^'}:}
\DoxyCodeLine{2315       enter\_state(state::align);}
\DoxyCodeLine{2316       specs.align = parse\_align(c);}
\DoxyCodeLine{2317       ++begin;}
\DoxyCodeLine{2318       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2319     \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{2320     \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{2321     \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{2322       enter\_state(state::sign, in(arg\_type, sint\_set | float\_set));}
\DoxyCodeLine{2323       \textcolor{keywordflow}{switch} (c) \{}
\DoxyCodeLine{2324       \textcolor{keywordflow}{case} \textcolor{charliteral}{'+'}:}
\DoxyCodeLine{2325         specs.sign = sign::plus;}
\DoxyCodeLine{2326         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2327       \textcolor{keywordflow}{case} \textcolor{charliteral}{'-\/'}:}
\DoxyCodeLine{2328         specs.sign = sign::minus;}
\DoxyCodeLine{2329         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2330       \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:}
\DoxyCodeLine{2331         specs.sign = sign::space;}
\DoxyCodeLine{2332         \textcolor{keywordflow}{break};}
\DoxyCodeLine{2333       \}}
\DoxyCodeLine{2334       ++begin;}
\DoxyCodeLine{2335       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2336     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\#'}:}
\DoxyCodeLine{2337       enter\_state(state::hash, is\_arithmetic\_type(arg\_type));}
\DoxyCodeLine{2338       specs.alt = \textcolor{keyword}{true};}
\DoxyCodeLine{2339       ++begin;}
\DoxyCodeLine{2340       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2341     \textcolor{keywordflow}{case} \textcolor{charliteral}{'0'}:}
\DoxyCodeLine{2342       enter\_state(state::zero);}
\DoxyCodeLine{2343       \textcolor{keywordflow}{if} (!is\_arithmetic\_type(arg\_type))}
\DoxyCodeLine{2344         throw\_format\_error(\textcolor{stringliteral}{"{}format specifier requires numeric argument"{}});}
\DoxyCodeLine{2345       \textcolor{keywordflow}{if} (specs.align == align::none) \{}
\DoxyCodeLine{2346         \textcolor{comment}{// Ignore 0 if align is specified for compatibility with std::format.}}
\DoxyCodeLine{2347         specs.align = align::numeric;}
\DoxyCodeLine{2348         specs.fill[0] = Char(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{2349       \}}
\DoxyCodeLine{2350       ++begin;}
\DoxyCodeLine{2351       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2352     \textcolor{keywordflow}{case} \textcolor{charliteral}{'1'}:}
\DoxyCodeLine{2353     \textcolor{keywordflow}{case} \textcolor{charliteral}{'2'}:}
\DoxyCodeLine{2354     \textcolor{keywordflow}{case} \textcolor{charliteral}{'3'}:}
\DoxyCodeLine{2355     \textcolor{keywordflow}{case} \textcolor{charliteral}{'4'}:}
\DoxyCodeLine{2356     \textcolor{keywordflow}{case} \textcolor{charliteral}{'5'}:}
\DoxyCodeLine{2357     \textcolor{keywordflow}{case} \textcolor{charliteral}{'6'}:}
\DoxyCodeLine{2358     \textcolor{keywordflow}{case} \textcolor{charliteral}{'7'}:}
\DoxyCodeLine{2359     \textcolor{keywordflow}{case} \textcolor{charliteral}{'8'}:}
\DoxyCodeLine{2360     \textcolor{keywordflow}{case} \textcolor{charliteral}{'9'}:}
\DoxyCodeLine{2361     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}:}
\DoxyCodeLine{2362       enter\_state(state::width);}
\DoxyCodeLine{2363       begin = parse\_dynamic\_spec(begin, end, specs.width, specs.width\_ref, ctx);}
\DoxyCodeLine{2364       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2365     \textcolor{keywordflow}{case} \textcolor{charliteral}{'.'}:}
\DoxyCodeLine{2366       enter\_state(state::precision,}
\DoxyCodeLine{2367                   in(arg\_type, float\_set | string\_set | cstring\_set));}
\DoxyCodeLine{2368       begin = parse\_precision(begin, end, specs.precision, specs.precision\_ref,}
\DoxyCodeLine{2369                               ctx);}
\DoxyCodeLine{2370       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2371     \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}:}
\DoxyCodeLine{2372       enter\_state(state::locale, is\_arithmetic\_type(arg\_type));}
\DoxyCodeLine{2373       specs.localized = \textcolor{keyword}{true};}
\DoxyCodeLine{2374       ++begin;}
\DoxyCodeLine{2375       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2376     \textcolor{keywordflow}{case} \textcolor{charliteral}{'d'}:}
\DoxyCodeLine{2377       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::dec, integral\_set);}
\DoxyCodeLine{2378     \textcolor{keywordflow}{case} \textcolor{charliteral}{'o'}:}
\DoxyCodeLine{2379       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::oct, integral\_set);}
\DoxyCodeLine{2380     \textcolor{keywordflow}{case} \textcolor{charliteral}{'x'}:}
\DoxyCodeLine{2381       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::hex\_lower, integral\_set);}
\DoxyCodeLine{2382     \textcolor{keywordflow}{case} \textcolor{charliteral}{'X'}:}
\DoxyCodeLine{2383       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::hex\_upper, integral\_set);}
\DoxyCodeLine{2384     \textcolor{keywordflow}{case} \textcolor{charliteral}{'b'}:}
\DoxyCodeLine{2385       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::bin\_lower, integral\_set);}
\DoxyCodeLine{2386     \textcolor{keywordflow}{case} \textcolor{charliteral}{'B'}:}
\DoxyCodeLine{2387       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::bin\_upper, integral\_set);}
\DoxyCodeLine{2388     \textcolor{keywordflow}{case} \textcolor{charliteral}{'a'}:}
\DoxyCodeLine{2389       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::hexfloat\_lower, float\_set);}
\DoxyCodeLine{2390     \textcolor{keywordflow}{case} \textcolor{charliteral}{'A'}:}
\DoxyCodeLine{2391       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::hexfloat\_upper, float\_set);}
\DoxyCodeLine{2392     \textcolor{keywordflow}{case} \textcolor{charliteral}{'e'}:}
\DoxyCodeLine{2393       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::exp\_lower, float\_set);}
\DoxyCodeLine{2394     \textcolor{keywordflow}{case} \textcolor{charliteral}{'E'}:}
\DoxyCodeLine{2395       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::exp\_upper, float\_set);}
\DoxyCodeLine{2396     \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'}:}
\DoxyCodeLine{2397       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::fixed\_lower, float\_set);}
\DoxyCodeLine{2398     \textcolor{keywordflow}{case} \textcolor{charliteral}{'F'}:}
\DoxyCodeLine{2399       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::fixed\_upper, float\_set);}
\DoxyCodeLine{2400     \textcolor{keywordflow}{case} \textcolor{charliteral}{'g'}:}
\DoxyCodeLine{2401       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::general\_lower, float\_set);}
\DoxyCodeLine{2402     \textcolor{keywordflow}{case} \textcolor{charliteral}{'G'}:}
\DoxyCodeLine{2403       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::general\_upper, float\_set);}
\DoxyCodeLine{2404     \textcolor{keywordflow}{case} \textcolor{charliteral}{'c'}:}
\DoxyCodeLine{2405       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::chr, integral\_set);}
\DoxyCodeLine{2406     \textcolor{keywordflow}{case} \textcolor{charliteral}{'s'}:}
\DoxyCodeLine{2407       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::string,}
\DoxyCodeLine{2408                                      bool\_set | string\_set | cstring\_set);}
\DoxyCodeLine{2409     \textcolor{keywordflow}{case} \textcolor{charliteral}{'p'}:}
\DoxyCodeLine{2410       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::pointer, pointer\_set | cstring\_set);}
\DoxyCodeLine{2411     \textcolor{keywordflow}{case} \textcolor{charliteral}{'?'}:}
\DoxyCodeLine{2412       \textcolor{keywordflow}{return} parse\_presentation\_type(pres::debug,}
\DoxyCodeLine{2413                                      char\_set | string\_set | cstring\_set);}
\DoxyCodeLine{2414     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\}'}:}
\DoxyCodeLine{2415       \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2416     \textcolor{keywordflow}{default}: \{}
\DoxyCodeLine{2417       \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2418       \textcolor{comment}{// Parse fill and alignment.}}
\DoxyCodeLine{2419       \textcolor{keyword}{auto} fill\_end = begin + code\_point\_length(begin);}
\DoxyCodeLine{2420       \textcolor{keywordflow}{if} (end -\/ fill\_end <= 0) \{}
\DoxyCodeLine{2421         throw\_format\_error(\textcolor{stringliteral}{"{}invalid format specifier"{}});}
\DoxyCodeLine{2422         \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2423       \}}
\DoxyCodeLine{2424       \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2425         throw\_format\_error(\textcolor{stringliteral}{"{}invalid fill character '\{'"{}});}
\DoxyCodeLine{2426         \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2427       \}}
\DoxyCodeLine{2428       \textcolor{keyword}{auto} align = parse\_align(to\_ascii(*fill\_end));}
\DoxyCodeLine{2429       enter\_state(state::align, align != align::none);}
\DoxyCodeLine{2430       specs.fill = \{begin, to\_unsigned(fill\_end -\/ begin)\};}
\DoxyCodeLine{2431       specs.align = align;}
\DoxyCodeLine{2432       begin = fill\_end + 1;}
\DoxyCodeLine{2433     \}}
\DoxyCodeLine{2434     \}}
\DoxyCodeLine{2435     \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2436     c = to\_ascii(*begin);}
\DoxyCodeLine{2437   \}}
\DoxyCodeLine{2438 \}}
\DoxyCodeLine{2439 }
\DoxyCodeLine{2440 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2441 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_replacement\_field(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2442                                            Handler\&\& handler) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2443   \textcolor{keyword}{struct }id\_adapter \{}
\DoxyCodeLine{2444     Handler\& handler;}
\DoxyCodeLine{2445     \textcolor{keywordtype}{int} arg\_id;}
\DoxyCodeLine{2446 }
\DoxyCodeLine{2447     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_auto() \{ arg\_id = handler.on\_arg\_id(); \}}
\DoxyCodeLine{2448     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_index(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) \{ arg\_id = handler.on\_arg\_id(\textcolor{keywordtype}{id}); \}}
\DoxyCodeLine{2449     FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) \{}
\DoxyCodeLine{2450       arg\_id = handler.on\_arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{2451     \}}
\DoxyCodeLine{2452   \};}
\DoxyCodeLine{2453 }
\DoxyCodeLine{2454   ++begin;}
\DoxyCodeLine{2455   \textcolor{keywordflow}{if} (begin == end) \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}invalid format string"{}}), end;}
\DoxyCodeLine{2456   \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2457     handler.on\_replacement\_field(handler.on\_arg\_id(), begin);}
\DoxyCodeLine{2458   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*begin == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2459     handler.on\_text(begin, begin + 1);}
\DoxyCodeLine{2460   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2461     \textcolor{keyword}{auto} adapter = id\_adapter\{handler, 0\};}
\DoxyCodeLine{2462     begin = parse\_arg\_id(begin, end, adapter);}
\DoxyCodeLine{2463     Char c = begin != end ? *begin : Char();}
\DoxyCodeLine{2464     \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2465       handler.on\_replacement\_field(adapter.arg\_id, begin);}
\DoxyCodeLine{2466     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{':'}) \{}
\DoxyCodeLine{2467       begin = handler.on\_format\_specs(adapter.arg\_id, begin + 1, end);}
\DoxyCodeLine{2468       \textcolor{keywordflow}{if} (begin == end || *begin != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2469         \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}unknown format specifier"{}}), end;}
\DoxyCodeLine{2470     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2471       \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}missing '\}' in format string"{}}), end;}
\DoxyCodeLine{2472     \}}
\DoxyCodeLine{2473   \}}
\DoxyCodeLine{2474   \textcolor{keywordflow}{return} begin + 1;}
\DoxyCodeLine{2475 \}}
\DoxyCodeLine{2476 }
\DoxyCodeLine{2477 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} IS\_CONSTEXPR, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Handler>}
\DoxyCodeLine{2478 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keywordtype}{void} parse\_format\_string(}
\DoxyCodeLine{2479     \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} format\_str, Handler\&\& handler) \{}
\DoxyCodeLine{2480   \textcolor{keyword}{auto} begin = format\_str.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{2481   \textcolor{keyword}{auto} end = begin + format\_str.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{2482   \textcolor{keywordflow}{if} (end -\/ begin < 32) \{}
\DoxyCodeLine{2483     \textcolor{comment}{// Use a simple loop instead of memchr for small strings.}}
\DoxyCodeLine{2484     \textcolor{keyword}{const} Char* p = begin;}
\DoxyCodeLine{2485     \textcolor{keywordflow}{while} (p != end) \{}
\DoxyCodeLine{2486       \textcolor{keyword}{auto} c = *p++;}
\DoxyCodeLine{2487       \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2488         handler.on\_text(begin, p -\/ 1);}
\DoxyCodeLine{2489         begin = p = parse\_replacement\_field(p -\/ 1, end, handler);}
\DoxyCodeLine{2490       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'}) \{}
\DoxyCodeLine{2491         \textcolor{keywordflow}{if} (p == end || *p != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2492           \textcolor{keywordflow}{return} handler.on\_error(\textcolor{stringliteral}{"{}unmatched '\}' in format string"{}});}
\DoxyCodeLine{2493         handler.on\_text(begin, p);}
\DoxyCodeLine{2494         begin = ++p;}
\DoxyCodeLine{2495       \}}
\DoxyCodeLine{2496     \}}
\DoxyCodeLine{2497     handler.on\_text(begin, end);}
\DoxyCodeLine{2498     \textcolor{keywordflow}{return};}
\DoxyCodeLine{2499   \}}
\DoxyCodeLine{2500   \textcolor{keyword}{struct }writer \{}
\DoxyCodeLine{2501     FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} Char* from, \textcolor{keyword}{const} Char* to) \{}
\DoxyCodeLine{2502       \textcolor{keywordflow}{if} (from == to) \textcolor{keywordflow}{return};}
\DoxyCodeLine{2503       \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2504         \textcolor{keyword}{const} Char* p = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2505         \textcolor{keywordflow}{if} (!find<IS\_CONSTEXPR>(from, to, Char(\textcolor{charliteral}{'\}'}), p))}
\DoxyCodeLine{2506           \textcolor{keywordflow}{return} handler\_.on\_text(from, to);}
\DoxyCodeLine{2507         ++p;}
\DoxyCodeLine{2508         \textcolor{keywordflow}{if} (p == to || *p != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{2509           \textcolor{keywordflow}{return} handler\_.on\_error(\textcolor{stringliteral}{"{}unmatched '\}' in format string"{}});}
\DoxyCodeLine{2510         handler\_.on\_text(from, p);}
\DoxyCodeLine{2511         from = p + 1;}
\DoxyCodeLine{2512       \}}
\DoxyCodeLine{2513     \}}
\DoxyCodeLine{2514     Handler\& handler\_;}
\DoxyCodeLine{2515   \} write = \{handler\};}
\DoxyCodeLine{2516   \textcolor{keywordflow}{while} (begin != end) \{}
\DoxyCodeLine{2517     \textcolor{comment}{// Doing two passes with memchr (one for '\{' and another for '\}') is up to}}
\DoxyCodeLine{2518     \textcolor{comment}{// 2.5x faster than the naive one-\/pass implementation on big format strings.}}
\DoxyCodeLine{2519     \textcolor{keyword}{const} Char* p = begin;}
\DoxyCodeLine{2520     \textcolor{keywordflow}{if} (*begin != \textcolor{charliteral}{'\{'} \&\& !find<IS\_CONSTEXPR>(begin + 1, end, Char(\textcolor{charliteral}{'\{'}), p))}
\DoxyCodeLine{2521       \textcolor{keywordflow}{return} write(begin, end);}
\DoxyCodeLine{2522     write(begin, p);}
\DoxyCodeLine{2523     begin = parse\_replacement\_field(p, end, handler);}
\DoxyCodeLine{2524   \}}
\DoxyCodeLine{2525 \}}
\DoxyCodeLine{2526 }
\DoxyCodeLine{2527 template <typename T, bool = is\_named\_arg<T>::value> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1strip__named__arg}{strip\_named\_arg}} \{}
\DoxyCodeLine{2528   \textcolor{keyword}{using }type = T;}
\DoxyCodeLine{2529 \};}
\DoxyCodeLine{2530 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1strip__named__arg}{strip\_named\_arg}}<T, true> \{}
\DoxyCodeLine{2531   \textcolor{keyword}{using }type = remove\_cvref\_t<\textcolor{keyword}{decltype}(T::value)>;}
\DoxyCodeLine{2532 \};}
\DoxyCodeLine{2533 }
\DoxyCodeLine{2534 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{2535 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_format\_specs(ParseContext\& ctx)}
\DoxyCodeLine{2536     -\/> \textcolor{keyword}{decltype}(ctx.begin()) \{}
\DoxyCodeLine{2537   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} ParseContext::char\_type;}
\DoxyCodeLine{2538   \textcolor{keyword}{using }context = \mbox{\hyperlink{classbasic__format__context}{buffer\_context<char\_type>}};}
\DoxyCodeLine{2539   \textcolor{keyword}{using }mapped\_type = conditional\_t<}
\DoxyCodeLine{2540       \mbox{\hyperlink{structdetail_1_1type__constant}{mapped\_type\_constant<T, context>::value}} != type::custom\_type,}
\DoxyCodeLine{2541       \textcolor{keyword}{decltype}(\mbox{\hyperlink{structdetail_1_1arg__mapper}{arg\_mapper<context>}}().map(std::declval<const T\&>())),}
\DoxyCodeLine{2542       \textcolor{keyword}{typename} strip\_named\_arg<T>::type>;}
\DoxyCodeLine{2543 \textcolor{preprocessor}{\#if defined(\_\_cpp\_if\_constexpr)}}
\DoxyCodeLine{2544   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::is\_default\_constructible\_v<}
\DoxyCodeLine{2545                     \mbox{\hyperlink{structformatter}{formatter<mapped\_type, char\_type>}}>) \{}
\DoxyCodeLine{2546     \textcolor{keywordflow}{return} \mbox{\hyperlink{structformatter}{formatter<mapped\_type, char\_type>}}().parse(ctx);}
\DoxyCodeLine{2547   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2548     type\_is\_unformattable\_for<T, char\_type> \_;}
\DoxyCodeLine{2549     \textcolor{keywordflow}{return} ctx.begin();}
\DoxyCodeLine{2550   \}}
\DoxyCodeLine{2551 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2552   \textcolor{keywordflow}{return} \mbox{\hyperlink{structformatter}{formatter<mapped\_type, char\_type>}}().parse(ctx);}
\DoxyCodeLine{2553 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2554 \}}
\DoxyCodeLine{2555 }
\DoxyCodeLine{2556 \textcolor{comment}{// Checks char specs and returns true iff the presentation type is char-\/like.}}
\DoxyCodeLine{2557 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2558 FMT\_CONSTEXPR \textcolor{keyword}{auto} check\_char\_specs(\textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2559   \textcolor{keywordflow}{if} (specs.type != presentation\_type::none \&\&}
\DoxyCodeLine{2560       specs.type != presentation\_type::chr \&\&}
\DoxyCodeLine{2561       specs.type != presentation\_type::debug) \{}
\DoxyCodeLine{2562     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2563   \}}
\DoxyCodeLine{2564   \textcolor{keywordflow}{if} (specs.align == align::numeric || specs.sign != sign::none || specs.alt)}
\DoxyCodeLine{2565     throw\_format\_error(\textcolor{stringliteral}{"{}invalid format specifier for char"{}});}
\DoxyCodeLine{2566   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2567 \}}
\DoxyCodeLine{2568 }
\DoxyCodeLine{2569 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{2570 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} N, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2571 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} get\_arg\_index\_by\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2572   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (is\_statically\_named\_arg<T>()) \{}
\DoxyCodeLine{2573     \textcolor{keywordflow}{if} (name == T::name) \textcolor{keywordflow}{return} N;}
\DoxyCodeLine{2574   \}}
\DoxyCodeLine{2575   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\textcolor{keyword}{sizeof}...(Args) > 0)}
\DoxyCodeLine{2576     \textcolor{keywordflow}{return} get\_arg\_index\_by\_name<N + 1, \mbox{\hyperlink{classArgs}{Args}}...>(name);}
\DoxyCodeLine{2577   (void)name;  \textcolor{comment}{// Workaround an MSVC bug about "{}unused"{} parameter.}}
\DoxyCodeLine{2578   \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2579 \}}
\DoxyCodeLine{2580 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2581 }
\DoxyCodeLine{2582 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2583 FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_arg\_index\_by\_name(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} name) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2584 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{2585   \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (\textcolor{keyword}{sizeof}...(Args) > 0)}
\DoxyCodeLine{2586     \textcolor{keywordflow}{return} get\_arg\_index\_by\_name<0, \mbox{\hyperlink{classArgs}{Args}}...>(name);}
\DoxyCodeLine{2587 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2588   (void)name;}
\DoxyCodeLine{2589   \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2590 \}}
\DoxyCodeLine{2591 }
\DoxyCodeLine{2592 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1format__string__checker}{format\_string\_checker}} \{}
\DoxyCodeLine{2593  \textcolor{keyword}{private}:}
\DoxyCodeLine{2594   \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1compile__parse__context}{parse\_context\_type}} = \mbox{\hyperlink{classdetail_1_1compile__parse__context}{compile\_parse\_context<Char>}};}
\DoxyCodeLine{2595   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} num\_args = \textcolor{keyword}{sizeof}...(Args);}
\DoxyCodeLine{2596 }
\DoxyCodeLine{2597   \textcolor{comment}{// Format specifier parsing function.}}
\DoxyCodeLine{2598   \textcolor{comment}{// In the future basic\_format\_parse\_context will replace compile\_parse\_context}}
\DoxyCodeLine{2599   \textcolor{comment}{// here and will use is\_constant\_evaluated and downcasting to access the data}}
\DoxyCodeLine{2600   \textcolor{comment}{// needed for compile-\/time checks: https://godbolt.org/z/GvWzcTjh1.}}
\DoxyCodeLine{2601   \textcolor{keyword}{using }parse\_func = \textcolor{keyword}{const} Char* (*)(\mbox{\hyperlink{classdetail_1_1compile__parse__context}{parse\_context\_type}}\&);}
\DoxyCodeLine{2602 }
\DoxyCodeLine{2603   type types\_[num\_args > 0 ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(num\_args) : 1];}
\DoxyCodeLine{2604   \mbox{\hyperlink{classdetail_1_1compile__parse__context}{parse\_context\_type}} context\_;}
\DoxyCodeLine{2605   parse\_func parse\_funcs\_[num\_args > 0 ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(num\_args) : 1];}
\DoxyCodeLine{2606 }
\DoxyCodeLine{2607  \textcolor{keyword}{public}:}
\DoxyCodeLine{2608   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classdetail_1_1format__string__checker}{format\_string\_checker}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fmt)}
\DoxyCodeLine{2609       : types\_\{\mbox{\hyperlink{structdetail_1_1type__constant}{mapped\_type\_constant<Args, buffer\_context<Char>}}>::value...\},}
\DoxyCodeLine{2610         context\_(fmt, num\_args, types\_),}
\DoxyCodeLine{2611         parse\_funcs\_\{\&parse\_format\_specs<Args, parse\_context\_type>...\} \{\}}
\DoxyCodeLine{2612 }
\DoxyCodeLine{2613   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char*, \textcolor{keyword}{const} Char*) \{\}}
\DoxyCodeLine{2614 }
\DoxyCodeLine{2615   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id() -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} context\_.next\_arg\_id(); \}}
\DoxyCodeLine{2616   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2617     \textcolor{keywordflow}{return} context\_.check\_arg\_id(\textcolor{keywordtype}{id}), id;}
\DoxyCodeLine{2618   \}}
\DoxyCodeLine{2619   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2620 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{2621     \textcolor{keyword}{auto} index = get\_arg\_index\_by\_name<\mbox{\hyperlink{classArgs}{Args}}...>(id);}
\DoxyCodeLine{2622     \textcolor{keywordflow}{if} (index < 0) on\_error(\textcolor{stringliteral}{"{}named argument is not found"{}});}
\DoxyCodeLine{2623     \textcolor{keywordflow}{return} index;}
\DoxyCodeLine{2624 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2625     (void)\textcolor{keywordtype}{id};}
\DoxyCodeLine{2626     on\_error(\textcolor{stringliteral}{"{}compile-\/time checks for named arguments require C++20 support"{}});}
\DoxyCodeLine{2627     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2628 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2629   \}}
\DoxyCodeLine{2630 }
\DoxyCodeLine{2631   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_replacement\_field(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keyword}{const} Char* begin) \{}
\DoxyCodeLine{2632     on\_format\_specs(\textcolor{keywordtype}{id}, begin, begin);  \textcolor{comment}{// Call parse() on empty specs.}}
\DoxyCodeLine{2633   \}}
\DoxyCodeLine{2634 }
\DoxyCodeLine{2635   FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_format\_specs(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char*)}
\DoxyCodeLine{2636       -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2637     context\_.advance\_to(begin);}
\DoxyCodeLine{2638     \textcolor{comment}{// id >= 0 check is a workaround for gcc 10 bug (\#2065).}}
\DoxyCodeLine{2639     \textcolor{keywordflow}{return} \textcolor{keywordtype}{id} >= 0 \&\& \textcolor{keywordtype}{id} < num\_args ? parse\_funcs\_[id](context\_) : begin;}
\DoxyCodeLine{2640   \}}
\DoxyCodeLine{2641 }
\DoxyCodeLine{2642   FMT\_CONSTEXPR \textcolor{keywordtype}{void} on\_error(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \{}
\DoxyCodeLine{2643     throw\_format\_error(message);}
\DoxyCodeLine{2644   \}}
\DoxyCodeLine{2645 \};}
\DoxyCodeLine{2646 }
\DoxyCodeLine{2647 \textcolor{comment}{// Reports a compile-\/time error if S is not a valid format string.}}
\DoxyCodeLine{2648 \textcolor{keyword}{template} <\textcolor{keyword}{typename}..., \textcolor{keyword}{typename} S, FMT\_ENABLE\_IF(!\mbox{\hyperlink{structdetail_1_1is__compile__string}{is\_compile\_string<S>::value}})>}
\DoxyCodeLine{2649 FMT\_INLINE \textcolor{keywordtype}{void} check\_format\_string(\textcolor{keyword}{const} S\&) \{}
\DoxyCodeLine{2650 \textcolor{preprocessor}{\#ifdef FMT\_ENFORCE\_COMPILE\_STRING}}
\DoxyCodeLine{2651   \textcolor{keyword}{static\_assert}(\mbox{\hyperlink{structdetail_1_1is__compile__string}{is\_compile\_string<S>::value}},}
\DoxyCodeLine{2652                 \textcolor{stringliteral}{"{}FMT\_ENFORCE\_COMPILE\_STRING requires all format strings to use "{}}}
\DoxyCodeLine{2653                 \textcolor{stringliteral}{"{}FMT\_STRING."{}});}
\DoxyCodeLine{2654 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2655 \}}
\DoxyCodeLine{2656 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}, \textcolor{keyword}{typename} S,}
\DoxyCodeLine{2657           FMT\_ENABLE\_IF(is\_compile\_string<S>::value)>}
\DoxyCodeLine{2658 \textcolor{keywordtype}{void} check\_format\_string(S format\_str) \{}
\DoxyCodeLine{2659   \textcolor{keyword}{using }char\_t = \textcolor{keyword}{typename} S::char\_type;}
\DoxyCodeLine{2660   FMT\_CONSTEXPR \textcolor{keyword}{auto} s = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char\_t>}}(format\_str);}
\DoxyCodeLine{2661   \textcolor{keyword}{using }checker = format\_string\_checker<char\_t, remove\_cvref\_t<Args>...>;}
\DoxyCodeLine{2662   FMT\_CONSTEXPR \textcolor{keywordtype}{bool} error = (parse\_format\_string<true>(s, checker(s)), \textcolor{keyword}{true});}
\DoxyCodeLine{2663   ignore\_unused(error);}
\DoxyCodeLine{2664 \}}
\DoxyCodeLine{2665 }
\DoxyCodeLine{2666 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1vformat__args}{vformat\_args}} \{}
\DoxyCodeLine{2667   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__args}{type}} = \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<}
\DoxyCodeLine{2668       \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<std::back\_insert\_iterator<buffer<Char>}}>, Char>>;}
\DoxyCodeLine{2669 \};}
\DoxyCodeLine{2670 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1vformat__args}{vformat\_args}}<char> \{ \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__args}{type}} = \mbox{\hyperlink{classbasic__format__args}{format\_args}}; \};}
\DoxyCodeLine{2671 }
\DoxyCodeLine{2672 \textcolor{comment}{// Use vformat\_args and avoid type\_identity to keep symbols short.}}
\DoxyCodeLine{2673 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2674 \textcolor{keywordtype}{void} vformat\_to(\mbox{\hyperlink{classdetail_1_1buffer}{buffer<Char>}}\& buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fmt,}
\DoxyCodeLine{2675                 \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__args}{vformat\_args<Char>::type}} args, \mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} loc = \{\});}
\DoxyCodeLine{2676 }
\DoxyCodeLine{2677 FMT\_API \textcolor{keywordtype}{void} vprint\_mojibake(std::FILE*, \mbox{\hyperlink{classbasic__string__view}{string\_view}}, \mbox{\hyperlink{classbasic__format__args}{format\_args}});}
\DoxyCodeLine{2678 \textcolor{preprocessor}{\#ifndef \_WIN32}}
\DoxyCodeLine{2679 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} vprint\_mojibake(std::FILE*, \mbox{\hyperlink{classbasic__string__view}{string\_view}}, \mbox{\hyperlink{classbasic__format__args}{format\_args}}) \{\}}
\DoxyCodeLine{2680 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2681 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{2682 }
\DoxyCodeLine{2683 FMT\_BEGIN\_EXPORT}
\DoxyCodeLine{2684 }
\DoxyCodeLine{2685 \textcolor{comment}{// A formatter specialization for natively supported types.}}
\DoxyCodeLine{2686 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2687 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<T, Char,}
\DoxyCodeLine{2688                  enable\_if\_t<detail::type\_constant<T, Char>::value !=}
\DoxyCodeLine{2689                              detail::type::custom\_type>> \{}
\DoxyCodeLine{2690  \textcolor{keyword}{private}:}
\DoxyCodeLine{2691   \mbox{\hyperlink{structdetail_1_1dynamic__format__specs}{detail::dynamic\_format\_specs<Char>}} specs\_;}
\DoxyCodeLine{2692 }
\DoxyCodeLine{2693  \textcolor{keyword}{public}:}
\DoxyCodeLine{2694   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{2695   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2696     \textcolor{keyword}{auto} type = \mbox{\hyperlink{structdetail_1_1type__constant}{detail::type\_constant<T, Char>::value}};}
\DoxyCodeLine{2697     \textcolor{keyword}{auto} end =}
\DoxyCodeLine{2698         detail::parse\_format\_specs(ctx.begin(), ctx.end(), specs\_, ctx, type);}
\DoxyCodeLine{2699     \textcolor{keywordflow}{if} (type == detail::type::char\_type) detail::check\_char\_specs(specs\_);}
\DoxyCodeLine{2700     \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{2701   \}}
\DoxyCodeLine{2702 }
\DoxyCodeLine{2703   template <detail::type U = detail::type\_constant<T, Char>::value,}
\DoxyCodeLine{2704             FMT\_ENABLE\_IF(U == detail::type::string\_type ||}
\DoxyCodeLine{2705                           U == detail::type::cstring\_type ||}
\DoxyCodeLine{2706                           U == detail::type::char\_type)>}
\DoxyCodeLine{2707   FMT\_CONSTEXPR \textcolor{keywordtype}{void} set\_debug\_format(\textcolor{keywordtype}{bool} set = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{2708     specs\_.type = set ? presentation\_type::debug : presentation\_type::none;}
\DoxyCodeLine{2709   \}}
\DoxyCodeLine{2710 }
\DoxyCodeLine{2711   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{2712   FMT\_CONSTEXPR \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T\& val, FormatContext\& ctx) \textcolor{keyword}{const}}
\DoxyCodeLine{2713       -\/> \textcolor{keyword}{decltype}(ctx.out());}
\DoxyCodeLine{2714 \};}
\DoxyCodeLine{2715 }
\DoxyCodeLine{2716 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}> \textcolor{keyword}{struct }\mbox{\hyperlink{structruntime__format__string}{runtime\_format\_string}} \{}
\DoxyCodeLine{2717   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str;}
\DoxyCodeLine{2718 \};}
\DoxyCodeLine{2719 }
\DoxyCodeLine{2721 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}> \textcolor{keyword}{class }\mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}} \{}
\DoxyCodeLine{2722  \textcolor{keyword}{private}:}
\DoxyCodeLine{2723   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str\_;}
\DoxyCodeLine{2724 }
\DoxyCodeLine{2725  \textcolor{keyword}{public}:}
\DoxyCodeLine{2726   \textcolor{keyword}{template} <\textcolor{keyword}{typename} S,}
\DoxyCodeLine{2727             FMT\_ENABLE\_IF(}
\DoxyCodeLine{2728                 std::is\_convertible<\textcolor{keyword}{const} S\&, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}>::value)>}
\DoxyCodeLine{2729   FMT\_CONSTEVAL FMT\_INLINE \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}}(\textcolor{keyword}{const} S\& s) : str\_(s) \{}
\DoxyCodeLine{2730     \textcolor{keyword}{static\_assert}(}
\DoxyCodeLine{2731         detail::count<}
\DoxyCodeLine{2732             (std::is\_base\_of<detail::view, remove\_reference\_t<Args>>::value \&\&}
\DoxyCodeLine{2733              std::is\_reference<Args>::value)...>() == 0,}
\DoxyCodeLine{2734         \textcolor{stringliteral}{"{}passing views as lvalues is disallowed"{}});}
\DoxyCodeLine{2735 \textcolor{preprocessor}{\#ifdef FMT\_HAS\_CONSTEVAL}}
\DoxyCodeLine{2736     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (detail::count\_named\_args<\mbox{\hyperlink{classArgs}{Args}}...>() ==}
\DoxyCodeLine{2737                   detail::count\_statically\_named\_args<Args...>()) \{}
\DoxyCodeLine{2738       \textcolor{keyword}{using }checker =}
\DoxyCodeLine{2739           \mbox{\hyperlink{classdetail_1_1format__string__checker}{detail::format\_string\_checker<Char, remove\_cvref\_t<Args>}}...>;}
\DoxyCodeLine{2740       detail::parse\_format\_string<true>(str\_, checker(s));}
\DoxyCodeLine{2741     \}}
\DoxyCodeLine{2742 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2743     detail::check\_format\_string<\mbox{\hyperlink{classArgs}{Args}}...>(s);}
\DoxyCodeLine{2744 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2745   \}}
\DoxyCodeLine{2746   \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string}}(\mbox{\hyperlink{structruntime__format__string}{runtime\_format\_string<Char>}} fmt) : str\_(fmt.str) \{\}}
\DoxyCodeLine{2747 }
\DoxyCodeLine{2748   FMT\_INLINE \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} str\_; \}}
\DoxyCodeLine{2749   FMT\_INLINE \textcolor{keyword}{auto} get() \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{ \textcolor{keywordflow}{return} str\_; \}}
\DoxyCodeLine{2750 \};}
\DoxyCodeLine{2751 }
\DoxyCodeLine{2752 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION \&\& FMT\_GCC\_VERSION < 409}}
\DoxyCodeLine{2753 \textcolor{comment}{// Workaround broken conversion on older gcc.}}
\DoxyCodeLine{2754 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__string}{format\_string}} = \mbox{\hyperlink{classbasic__string__view}{string\_view}};}
\DoxyCodeLine{2755 \textcolor{keyword}{inline} \textcolor{keyword}{auto} runtime(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s) -\/> \mbox{\hyperlink{classbasic__string__view}{string\_view}} \{ \textcolor{keywordflow}{return} s; \}}
\DoxyCodeLine{2756 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{2757 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... \mbox{\hyperlink{classArgs}{Args}}>}
\DoxyCodeLine{2758 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__string}{format\_string}} = \mbox{\hyperlink{classbasic__format__string}{basic\_format\_string<char, type\_identity\_t<Args>}}...>;}
\DoxyCodeLine{2769 \textcolor{keyword}{inline} \textcolor{keyword}{auto} runtime(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s) -\/> \mbox{\hyperlink{structruntime__format__string}{runtime\_format\_string<>}} \{ \textcolor{keywordflow}{return} \{\{s\}\}; \}}
\DoxyCodeLine{2770 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2771 }
\DoxyCodeLine{2772 FMT\_API \textcolor{keyword}{auto} vformat(\mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> std::string;}
\DoxyCodeLine{2773 }
\DoxyCodeLine{2785 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{2786 FMT\_NODISCARD FMT\_INLINE \textcolor{keyword}{auto} format(\mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{2787     -\/> std::string \{}
\DoxyCodeLine{2788   \textcolor{keywordflow}{return} vformat(fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{2789 \}}
\DoxyCodeLine{2790 }
\DoxyCodeLine{2792 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt,}
\DoxyCodeLine{2793           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__output__iterator}{detail::is\_output\_iterator<OutputIt, char>::value}})>}
\DoxyCodeLine{2794 \textcolor{keyword}{auto} vformat\_to(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> OutputIt \{}
\DoxyCodeLine{2795   \textcolor{keyword}{auto}\&\& buf = detail::get\_buffer<char>(out);}
\DoxyCodeLine{2796   detail::vformat\_to(buf, fmt, args, \{\});}
\DoxyCodeLine{2797   \textcolor{keywordflow}{return} detail::get\_iterator(buf, out);}
\DoxyCodeLine{2798 \}}
\DoxyCodeLine{2799 }
\DoxyCodeLine{2812 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{2813           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__output__iterator}{detail::is\_output\_iterator<OutputIt, char>::value}})>}
\DoxyCodeLine{2814 FMT\_INLINE \textcolor{keyword}{auto} format\_to(OutputIt out, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{2815     -\/> OutputIt \{}
\DoxyCodeLine{2816   \textcolor{keywordflow}{return} vformat\_to(out, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{2817 \}}
\DoxyCodeLine{2818 }
\DoxyCodeLine{2819 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt> \textcolor{keyword}{struct }\mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result}} \{}
\DoxyCodeLine{2821   OutputIt \mbox{\hyperlink{structformat__to__n__result_a90597c6c1d23c7301aef16e756c6263b}{out}};}
\DoxyCodeLine{2823   \textcolor{keywordtype}{size\_t} \mbox{\hyperlink{structformat__to__n__result_ab1c815078e1a78716bb07b9ed8c7023b}{size}};}
\DoxyCodeLine{2824 \};}
\DoxyCodeLine{2825 }
\DoxyCodeLine{2826 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{2827           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__output__iterator}{detail::is\_output\_iterator<OutputIt, char>::value}})>}
\DoxyCodeLine{2828 \textcolor{keyword}{auto} vformat\_to\_n(OutputIt out, \textcolor{keywordtype}{size\_t} n, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args)}
\DoxyCodeLine{2829     -\/> \mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result<OutputIt>}} \{}
\DoxyCodeLine{2830   \textcolor{keyword}{using }traits = \mbox{\hyperlink{classdetail_1_1fixed__buffer__traits}{detail::fixed\_buffer\_traits}};}
\DoxyCodeLine{2831   \textcolor{keyword}{auto} buf = \mbox{\hyperlink{classdetail_1_1iterator__buffer}{detail::iterator\_buffer<OutputIt, char, traits>}}(out, n);}
\DoxyCodeLine{2832   detail::vformat\_to(buf, fmt, args, \{\});}
\DoxyCodeLine{2833   \textcolor{keywordflow}{return} \{buf.out(), buf.count()\};}
\DoxyCodeLine{2834 \}}
\DoxyCodeLine{2835 }
\DoxyCodeLine{2844 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{2845           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__output__iterator}{detail::is\_output\_iterator<OutputIt, char>::value}})>}
\DoxyCodeLine{2846 FMT\_INLINE \textcolor{keyword}{auto} format\_to\_n(OutputIt out, \textcolor{keywordtype}{size\_t} n, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt,}
\DoxyCodeLine{2847                             T\&\&... args) -\/> \mbox{\hyperlink{structformat__to__n__result}{format\_to\_n\_result<OutputIt>}} \{}
\DoxyCodeLine{2848   \textcolor{keywordflow}{return} vformat\_to\_n(out, n, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{2849 \}}
\DoxyCodeLine{2850 }
\DoxyCodeLine{2852 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{2853 FMT\_NODISCARD FMT\_INLINE \textcolor{keyword}{auto} formatted\_size(\mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt,}
\DoxyCodeLine{2854                                              T\&\&... args) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{2855   \textcolor{keyword}{auto} buf = \mbox{\hyperlink{classdetail_1_1counting__buffer}{detail::counting\_buffer<>}}();}
\DoxyCodeLine{2856   detail::vformat\_to<char>(buf, fmt, fmt::make\_format\_args(args...), \{\});}
\DoxyCodeLine{2857   \textcolor{keywordflow}{return} buf.count();}
\DoxyCodeLine{2858 \}}
\DoxyCodeLine{2859 }
\DoxyCodeLine{2860 FMT\_API \textcolor{keywordtype}{void} vprint(\mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args);}
\DoxyCodeLine{2861 FMT\_API \textcolor{keywordtype}{void} vprint(std::FILE* f, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args);}
\DoxyCodeLine{2862 }
\DoxyCodeLine{2873 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{2874 FMT\_INLINE \textcolor{keywordtype}{void} print(\mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{2875   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& vargs = fmt::make\_format\_args(args...);}
\DoxyCodeLine{2876   \textcolor{keywordflow}{return} detail::is\_utf8() ? vprint(fmt, vargs)}
\DoxyCodeLine{2877                            : detail::vprint\_mojibake(stdout, fmt, vargs);}
\DoxyCodeLine{2878 \}}
\DoxyCodeLine{2879 }
\DoxyCodeLine{2890 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{2891 FMT\_INLINE \textcolor{keywordtype}{void} print(std::FILE* f, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{2892   \textcolor{keyword}{const} \textcolor{keyword}{auto}\& vargs = fmt::make\_format\_args(args...);}
\DoxyCodeLine{2893   \textcolor{keywordflow}{return} detail::is\_utf8() ? vprint(f, fmt, vargs)}
\DoxyCodeLine{2894                            : detail::vprint\_mojibake(f, fmt, vargs);}
\DoxyCodeLine{2895 \}}
\DoxyCodeLine{2896 }
\DoxyCodeLine{2901 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{2902 FMT\_INLINE \textcolor{keywordtype}{void} println(std::FILE* f, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{2903   \textcolor{keywordflow}{return} fmt::print(f, \textcolor{stringliteral}{"{}\{\}\(\backslash\)n"{}}, fmt::format(fmt, std::forward<T>(args)...));}
\DoxyCodeLine{2904 \}}
\DoxyCodeLine{2905 }
\DoxyCodeLine{2910 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{2911 FMT\_INLINE \textcolor{keywordtype}{void} println(\mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) \{}
\DoxyCodeLine{2912   \textcolor{keywordflow}{return} fmt::println(stdout, fmt, std::forward<T>(args)...);}
\DoxyCodeLine{2913 \}}
\DoxyCodeLine{2914 }
\DoxyCodeLine{2915 FMT\_END\_EXPORT}
\DoxyCodeLine{2916 FMT\_GCC\_PRAGMA(\textcolor{stringliteral}{"{}GCC pop\_options"{}})}
\DoxyCodeLine{2917 FMT\_END\_NAMESPACE}
\DoxyCodeLine{2918 }
\DoxyCodeLine{2919 \textcolor{preprocessor}{\#ifdef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{2920 \textcolor{preprocessor}{\#  include "{}format.h"{}}}
\DoxyCodeLine{2921 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2922 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_CORE\_H\_}}

\end{DoxyCode}
