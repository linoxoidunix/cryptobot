\hypertarget{format_8h_source}{}\doxysection{format.\+h}
\label{format_8h_source}\index{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/format.h@{/home/linoxoidunix/Programming/cplusplus/cryptobot/bybit/third\_party/fmt/format.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{  Formatting library for C++}}
\DoxyCodeLine{3 \textcolor{comment}{}}
\DoxyCodeLine{4 \textcolor{comment}{  Copyright (c) 2012 -\/ present, Victor Zverovich}}
\DoxyCodeLine{5 \textcolor{comment}{}}
\DoxyCodeLine{6 \textcolor{comment}{  Permission is hereby granted, free of charge, to any person obtaining}}
\DoxyCodeLine{7 \textcolor{comment}{  a copy of this software and associated documentation files (the}}
\DoxyCodeLine{8 \textcolor{comment}{  "{}Software"{}), to deal in the Software without restriction, including}}
\DoxyCodeLine{9 \textcolor{comment}{  without limitation the rights to use, copy, modify, merge, publish,}}
\DoxyCodeLine{10 \textcolor{comment}{  distribute, sublicense, and/or sell copies of the Software, and to}}
\DoxyCodeLine{11 \textcolor{comment}{  permit persons to whom the Software is furnished to do so, subject to}}
\DoxyCodeLine{12 \textcolor{comment}{  the following conditions:}}
\DoxyCodeLine{13 \textcolor{comment}{}}
\DoxyCodeLine{14 \textcolor{comment}{  The above copyright notice and this permission notice shall be}}
\DoxyCodeLine{15 \textcolor{comment}{  included in all copies or substantial portions of the Software.}}
\DoxyCodeLine{16 \textcolor{comment}{}}
\DoxyCodeLine{17 \textcolor{comment}{  THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND,}}
\DoxyCodeLine{18 \textcolor{comment}{  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF}}
\DoxyCodeLine{19 \textcolor{comment}{  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND}}
\DoxyCodeLine{20 \textcolor{comment}{  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE}}
\DoxyCodeLine{21 \textcolor{comment}{  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION}}
\DoxyCodeLine{22 \textcolor{comment}{  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION}}
\DoxyCodeLine{23 \textcolor{comment}{  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{24 \textcolor{comment}{}}
\DoxyCodeLine{25 \textcolor{comment}{  -\/-\/-\/ Optional exception to the license -\/-\/-\/}}
\DoxyCodeLine{26 \textcolor{comment}{}}
\DoxyCodeLine{27 \textcolor{comment}{  As an exception, if, as a result of your compiling your source code, portions}}
\DoxyCodeLine{28 \textcolor{comment}{  of this Software are embedded into a machine-\/executable object form of such}}
\DoxyCodeLine{29 \textcolor{comment}{  source code, you may redistribute such embedded portions in such object form}}
\DoxyCodeLine{30 \textcolor{comment}{  without including the above copyright and permission notices.}}
\DoxyCodeLine{31 \textcolor{comment}{ */}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{preprocessor}{\#ifndef FMT\_FORMAT\_H\_}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#define FMT\_FORMAT\_H\_}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{preprocessor}{\#include <cmath>}             \textcolor{comment}{// std::signbit}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#include <cstdint>}           \textcolor{comment}{// uint32\_t}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#include <cstring>}           \textcolor{comment}{// std::memcpy}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#include <initializer\_list>}  \textcolor{comment}{// std::initializer\_list}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#include <limits>}            \textcolor{comment}{// std::numeric\_limits}}
\DoxyCodeLine{41 \textcolor{preprocessor}{\#include <memory>}            \textcolor{comment}{// std::uninitialized\_copy}}
\DoxyCodeLine{42 \textcolor{preprocessor}{\#include <stdexcept>}         \textcolor{comment}{// std::runtime\_error}}
\DoxyCodeLine{43 \textcolor{preprocessor}{\#include <system\_error>}      \textcolor{comment}{// std::system\_error}}
\DoxyCodeLine{44 }
\DoxyCodeLine{45 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_bit\_cast}}
\DoxyCodeLine{46 \textcolor{preprocessor}{\#  include <bit>}  \textcolor{comment}{// std::bitcast}}
\DoxyCodeLine{47 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{preprocessor}{\#include "{}core.h"{}}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51 \textcolor{preprocessor}{\#if defined \_\_cpp\_inline\_variables \&\& \_\_cpp\_inline\_variables >= 201606L}}
\DoxyCodeLine{52 \textcolor{preprocessor}{\#  define FMT\_INLINE\_VARIABLE inline}}
\DoxyCodeLine{53 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{54 \textcolor{preprocessor}{\#  define FMT\_INLINE\_VARIABLE}}
\DoxyCodeLine{55 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{56 }
\DoxyCodeLine{57 \textcolor{preprocessor}{\#if FMT\_HAS\_CPP17\_ATTRIBUTE(fallthrough)}}
\DoxyCodeLine{58 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH [[fallthrough]]}}
\DoxyCodeLine{59 \textcolor{preprocessor}{\#elif defined(\_\_clang\_\_)}}
\DoxyCodeLine{60 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH [[clang::fallthrough]]}}
\DoxyCodeLine{61 \textcolor{preprocessor}{\#elif FMT\_GCC\_VERSION >= 700 \&\& \(\backslash\)}}
\DoxyCodeLine{62 \textcolor{preprocessor}{    (!defined(\_\_EDG\_VERSION\_\_) || \_\_EDG\_VERSION\_\_ >= 520)}}
\DoxyCodeLine{63 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH [[gnu::fallthrough]]}}
\DoxyCodeLine{64 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{65 \textcolor{preprocessor}{\#  define FMT\_FALLTHROUGH}}
\DoxyCodeLine{66 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{67 }
\DoxyCodeLine{68 \textcolor{preprocessor}{\#ifndef FMT\_DEPRECATED}}
\DoxyCodeLine{69 \textcolor{preprocessor}{\#  if FMT\_HAS\_CPP14\_ATTRIBUTE(deprecated) || FMT\_MSC\_VERSION >= 1900}}
\DoxyCodeLine{70 \textcolor{preprocessor}{\#    define FMT\_DEPRECATED [[deprecated]]}}
\DoxyCodeLine{71 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{72 \textcolor{preprocessor}{\#    if (defined(\_\_GNUC\_\_) \&\& !defined(\_\_LCC\_\_)) || defined(\_\_clang\_\_)}}
\DoxyCodeLine{73 \textcolor{preprocessor}{\#      define FMT\_DEPRECATED \_\_attribute\_\_((deprecated))}}
\DoxyCodeLine{74 \textcolor{preprocessor}{\#    elif FMT\_MSC\_VERSION}}
\DoxyCodeLine{75 \textcolor{preprocessor}{\#      define FMT\_DEPRECATED \_\_declspec(deprecated)}}
\DoxyCodeLine{76 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{77 \textcolor{preprocessor}{\#      define FMT\_DEPRECATED }\textcolor{comment}{/* deprecated */}\textcolor{preprocessor}{}}
\DoxyCodeLine{78 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{79 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{80 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{preprocessor}{\#ifndef FMT\_NO\_UNIQUE\_ADDRESS}}
\DoxyCodeLine{83 \textcolor{preprocessor}{\#  if FMT\_CPLUSPLUS >= 202002L}}
\DoxyCodeLine{84 \textcolor{preprocessor}{\#    if FMT\_HAS\_CPP\_ATTRIBUTE(no\_unique\_address)}}
\DoxyCodeLine{85 \textcolor{preprocessor}{\#      define FMT\_NO\_UNIQUE\_ADDRESS [[no\_unique\_address]]}}
\DoxyCodeLine{86 \textcolor{preprocessor}{\#    elif FMT\_MSC\_VERSION >= 1929  }\textcolor{comment}{// VS2019 v16.10 and later}}
\DoxyCodeLine{87 \textcolor{preprocessor}{\#      define FMT\_NO\_UNIQUE\_ADDRESS [[msvc::no\_unique\_address]]}}
\DoxyCodeLine{88 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{89 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{90 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{91 \textcolor{preprocessor}{\#ifndef FMT\_NO\_UNIQUE\_ADDRESS}}
\DoxyCodeLine{92 \textcolor{preprocessor}{\#  define FMT\_NO\_UNIQUE\_ADDRESS}}
\DoxyCodeLine{93 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION || defined(\_\_clang\_\_)}}
\DoxyCodeLine{96 \textcolor{preprocessor}{\#  define FMT\_VISIBILITY(value) \_\_attribute\_\_((visibility(value)))}}
\DoxyCodeLine{97 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{98 \textcolor{preprocessor}{\#  define FMT\_VISIBILITY(value)}}
\DoxyCodeLine{99 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{100 }
\DoxyCodeLine{101 \textcolor{preprocessor}{\#ifdef \_\_has\_builtin}}
\DoxyCodeLine{102 \textcolor{preprocessor}{\#  define FMT\_HAS\_BUILTIN(x) \_\_has\_builtin(x)}}
\DoxyCodeLine{103 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{104 \textcolor{preprocessor}{\#  define FMT\_HAS\_BUILTIN(x) 0}}
\DoxyCodeLine{105 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107 \textcolor{preprocessor}{\#if FMT\_GCC\_VERSION || FMT\_CLANG\_VERSION}}
\DoxyCodeLine{108 \textcolor{preprocessor}{\#  define FMT\_NOINLINE \_\_attribute\_\_((noinline))}}
\DoxyCodeLine{109 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{110 \textcolor{preprocessor}{\#  define FMT\_NOINLINE}}
\DoxyCodeLine{111 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{112 }
\DoxyCodeLine{113 \textcolor{preprocessor}{\#ifndef FMT\_THROW}}
\DoxyCodeLine{114 \textcolor{preprocessor}{\#  if FMT\_EXCEPTIONS}}
\DoxyCodeLine{115 \textcolor{preprocessor}{\#    if FMT\_MSC\_VERSION || defined(\_\_NVCC\_\_)}}
\DoxyCodeLine{116 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{117 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{118 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Exception> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} do\_throw(\textcolor{keyword}{const} Exception\& x) \{}
\DoxyCodeLine{119   \textcolor{comment}{// Silence unreachable code warnings in MSVC and NVCC because these}}
\DoxyCodeLine{120   \textcolor{comment}{// are nearly impossible to fix in a generic code.}}
\DoxyCodeLine{121   \textcolor{keyword}{volatile} \textcolor{keywordtype}{bool} b = \textcolor{keyword}{true};}
\DoxyCodeLine{122   \textcolor{keywordflow}{if} (b) \textcolor{keywordflow}{throw} x;}
\DoxyCodeLine{123 \}}
\DoxyCodeLine{124 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{125 FMT\_END\_NAMESPACE}
\DoxyCodeLine{126 \textcolor{preprocessor}{\#      define FMT\_THROW(x) detail::do\_throw(x)}}
\DoxyCodeLine{127 \textcolor{preprocessor}{\#    else}}
\DoxyCodeLine{128 \textcolor{preprocessor}{\#      define FMT\_THROW(x) throw x}}
\DoxyCodeLine{129 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{130 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{131 \textcolor{preprocessor}{\#    define FMT\_THROW(x) \(\backslash\)}}
\DoxyCodeLine{132 \textcolor{preprocessor}{      ::fmt::detail::assert\_fail(\_\_FILE\_\_, \_\_LINE\_\_, (x).what())}}
\DoxyCodeLine{133 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{134 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136 \textcolor{preprocessor}{\#if FMT\_EXCEPTIONS}}
\DoxyCodeLine{137 \textcolor{preprocessor}{\#  define FMT\_TRY try}}
\DoxyCodeLine{138 \textcolor{preprocessor}{\#  define FMT\_CATCH(x) catch (x)}}
\DoxyCodeLine{139 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{140 \textcolor{preprocessor}{\#  define FMT\_TRY if (true)}}
\DoxyCodeLine{141 \textcolor{preprocessor}{\#  define FMT\_CATCH(x) if (false)}}
\DoxyCodeLine{142 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{143 }
\DoxyCodeLine{144 \textcolor{preprocessor}{\#ifndef FMT\_MAYBE\_UNUSED}}
\DoxyCodeLine{145 \textcolor{preprocessor}{\#  if FMT\_HAS\_CPP17\_ATTRIBUTE(maybe\_unused)}}
\DoxyCodeLine{146 \textcolor{preprocessor}{\#    define FMT\_MAYBE\_UNUSED [[maybe\_unused]]}}
\DoxyCodeLine{147 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{148 \textcolor{preprocessor}{\#    define FMT\_MAYBE\_UNUSED}}
\DoxyCodeLine{149 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{151 }
\DoxyCodeLine{152 \textcolor{preprocessor}{\#ifndef FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{153 \textcolor{comment}{// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.}}
\DoxyCodeLine{154 \textcolor{preprocessor}{\#  if (FMT\_HAS\_FEATURE(cxx\_user\_literals) || FMT\_GCC\_VERSION >= 407 || \(\backslash\)}}
\DoxyCodeLine{155 \textcolor{preprocessor}{       FMT\_MSC\_VERSION >= 1900) \&\&                                     \(\backslash\)}}
\DoxyCodeLine{156 \textcolor{preprocessor}{      (!defined(\_\_EDG\_VERSION\_\_) || \_\_EDG\_VERSION\_\_ >= }\textcolor{comment}{/* UDL feature */}\textcolor{preprocessor}{ 480)}}
\DoxyCodeLine{157 \textcolor{preprocessor}{\#    define FMT\_USE\_USER\_DEFINED\_LITERALS 1}}
\DoxyCodeLine{158 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{159 \textcolor{preprocessor}{\#    define FMT\_USE\_USER\_DEFINED\_LITERALS 0}}
\DoxyCodeLine{160 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{161 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{162 }
\DoxyCodeLine{163 \textcolor{comment}{// Defining FMT\_REDUCE\_INT\_INSTANTIATIONS to 1, will reduce the number of}}
\DoxyCodeLine{164 \textcolor{comment}{// integer formatter template instantiations to just one by only using the}}
\DoxyCodeLine{165 \textcolor{comment}{// largest integer type. This results in a reduction in binary size but will}}
\DoxyCodeLine{166 \textcolor{comment}{// cause a decrease in integer formatting performance.}}
\DoxyCodeLine{167 \textcolor{preprocessor}{\#if !defined(FMT\_REDUCE\_INT\_INSTANTIATIONS)}}
\DoxyCodeLine{168 \textcolor{preprocessor}{\#  define FMT\_REDUCE\_INT\_INSTANTIATIONS 0}}
\DoxyCodeLine{169 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{170 }
\DoxyCodeLine{171 \textcolor{comment}{// \_\_builtin\_clz is broken in clang with Microsoft CodeGen:}}
\DoxyCodeLine{172 \textcolor{comment}{// https://github.com/fmtlib/fmt/issues/519.}}
\DoxyCodeLine{173 \textcolor{preprocessor}{\#if !FMT\_MSC\_VERSION}}
\DoxyCodeLine{174 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_clz) || FMT\_GCC\_VERSION || FMT\_ICC\_VERSION}}
\DoxyCodeLine{175 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CLZ(n) \_\_builtin\_clz(n)}}
\DoxyCodeLine{176 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{177 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_clzll) || FMT\_GCC\_VERSION || FMT\_ICC\_VERSION}}
\DoxyCodeLine{178 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CLZLL(n) \_\_builtin\_clzll(n)}}
\DoxyCodeLine{179 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{180 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{181 }
\DoxyCodeLine{182 \textcolor{comment}{// \_\_builtin\_ctz is broken in Intel Compiler Classic on Windows:}}
\DoxyCodeLine{183 \textcolor{comment}{// https://github.com/fmtlib/fmt/issues/2510.}}
\DoxyCodeLine{184 \textcolor{preprocessor}{\#ifndef \_\_ICL}}
\DoxyCodeLine{185 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_ctz) || FMT\_GCC\_VERSION || FMT\_ICC\_VERSION || \(\backslash\)}}
\DoxyCodeLine{186 \textcolor{preprocessor}{      defined(\_\_NVCOMPILER)}}
\DoxyCodeLine{187 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CTZ(n) \_\_builtin\_ctz(n)}}
\DoxyCodeLine{188 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{189 \textcolor{preprocessor}{\#  if FMT\_HAS\_BUILTIN(\_\_builtin\_ctzll) || FMT\_GCC\_VERSION || \(\backslash\)}}
\DoxyCodeLine{190 \textcolor{preprocessor}{      FMT\_ICC\_VERSION || defined(\_\_NVCOMPILER)}}
\DoxyCodeLine{191 \textcolor{preprocessor}{\#    define FMT\_BUILTIN\_CTZLL(n) \_\_builtin\_ctzll(n)}}
\DoxyCodeLine{192 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{193 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{194 }
\DoxyCodeLine{195 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION}}
\DoxyCodeLine{196 \textcolor{preprocessor}{\#  include <intrin.h>}  \textcolor{comment}{// \_BitScanReverse[64], \_BitScanForward[64], \_umul128}}
\DoxyCodeLine{197 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{198 }
\DoxyCodeLine{199 \textcolor{comment}{// Some compilers masquerade as both MSVC and GCC-\/likes or otherwise support}}
\DoxyCodeLine{200 \textcolor{comment}{// \_\_builtin\_clz and \_\_builtin\_clzll, so only define FMT\_BUILTIN\_CLZ using the}}
\DoxyCodeLine{201 \textcolor{comment}{// MSVC intrinsics if the clz and clzll builtins are not available.}}
\DoxyCodeLine{202 \textcolor{preprocessor}{\#if FMT\_MSC\_VERSION \&\& !defined(FMT\_BUILTIN\_CLZLL) \&\& \(\backslash\)}}
\DoxyCodeLine{203 \textcolor{preprocessor}{    !defined(FMT\_BUILTIN\_CTZLL)}}
\DoxyCodeLine{204 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{205 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{206 \textcolor{comment}{// Avoid Clang with Microsoft CodeGen's -\/Wunknown-\/pragmas warning.}}
\DoxyCodeLine{207 \textcolor{preprocessor}{\#  if !defined(\_\_clang\_\_)}}
\DoxyCodeLine{208 \textcolor{preprocessor}{\#    pragma intrinsic(\_BitScanForward)}}
\DoxyCodeLine{209 \textcolor{preprocessor}{\#    pragma intrinsic(\_BitScanReverse)}}
\DoxyCodeLine{210 \textcolor{preprocessor}{\#    if defined(\_WIN64)}}
\DoxyCodeLine{211 \textcolor{preprocessor}{\#      pragma intrinsic(\_BitScanForward64)}}
\DoxyCodeLine{212 \textcolor{preprocessor}{\#      pragma intrinsic(\_BitScanReverse64)}}
\DoxyCodeLine{213 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{214 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{215 }
\DoxyCodeLine{216 \textcolor{keyword}{inline} \textcolor{keyword}{auto} clz(uint32\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{217   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{218   \_BitScanReverse(\&r, x);}
\DoxyCodeLine{219   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{220   \textcolor{comment}{// Static analysis complains about using uninitialized data}}
\DoxyCodeLine{221   \textcolor{comment}{// "{}r"{}, but the only way that can happen is if "{}x"{} is 0,}}
\DoxyCodeLine{222   \textcolor{comment}{// which the callers guarantee to not happen.}}
\DoxyCodeLine{223   FMT\_MSC\_WARNING(suppress : 6102)}
\DoxyCodeLine{224   \textcolor{keywordflow}{return} 31 \string^ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{225 \}}
\DoxyCodeLine{226 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CLZ(n) detail::clz(n)}}
\DoxyCodeLine{227 }
\DoxyCodeLine{228 \textcolor{keyword}{inline} \textcolor{keyword}{auto} clzll(uint64\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{229   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{230 \textcolor{preprocessor}{\#  ifdef \_WIN64}}
\DoxyCodeLine{231   \_BitScanReverse64(\&r, x);}
\DoxyCodeLine{232 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{233   \textcolor{comment}{// Scan the high 32 bits.}}
\DoxyCodeLine{234   \textcolor{keywordflow}{if} (\_BitScanReverse(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x >> 32)))}
\DoxyCodeLine{235     \textcolor{keywordflow}{return} 63 \string^ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r + 32);}
\DoxyCodeLine{236   \textcolor{comment}{// Scan the low 32 bits.}}
\DoxyCodeLine{237   \_BitScanReverse(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x));}
\DoxyCodeLine{238 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{239   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{240   FMT\_MSC\_WARNING(suppress : 6102)  \textcolor{comment}{// Suppress a bogus static analysis warning.}}
\DoxyCodeLine{241   \textcolor{keywordflow}{return} 63 \string^ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{242 \}}
\DoxyCodeLine{243 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CLZLL(n) detail::clzll(n)}}
\DoxyCodeLine{244 }
\DoxyCodeLine{245 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ctz(uint32\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{246   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{247   \_BitScanForward(\&r, x);}
\DoxyCodeLine{248   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{249   FMT\_MSC\_WARNING(suppress : 6102)  \textcolor{comment}{// Suppress a bogus static analysis warning.}}
\DoxyCodeLine{250   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{251 \}}
\DoxyCodeLine{252 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CTZ(n) detail::ctz(n)}}
\DoxyCodeLine{253 }
\DoxyCodeLine{254 \textcolor{keyword}{inline} \textcolor{keyword}{auto} ctzll(uint64\_t x) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{255   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} r = 0;}
\DoxyCodeLine{256   FMT\_ASSERT(x != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{257   FMT\_MSC\_WARNING(suppress : 6102)  \textcolor{comment}{// Suppress a bogus static analysis warning.}}
\DoxyCodeLine{258 \textcolor{preprocessor}{\#  ifdef \_WIN64}}
\DoxyCodeLine{259   \_BitScanForward64(\&r, x);}
\DoxyCodeLine{260 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{261   \textcolor{comment}{// Scan the low 32 bits.}}
\DoxyCodeLine{262   \textcolor{keywordflow}{if} (\_BitScanForward(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x))) \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{263   \textcolor{comment}{// Scan the high 32 bits.}}
\DoxyCodeLine{264   \_BitScanForward(\&r, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(x >> 32));}
\DoxyCodeLine{265   r += 32;}
\DoxyCodeLine{266 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{267   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(r);}
\DoxyCodeLine{268 \}}
\DoxyCodeLine{269 \textcolor{preprocessor}{\#  define FMT\_BUILTIN\_CTZLL(n) detail::ctzll(n)}}
\DoxyCodeLine{270 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{271 FMT\_END\_NAMESPACE}
\DoxyCodeLine{272 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{273 }
\DoxyCodeLine{274 FMT\_BEGIN\_NAMESPACE}
\DoxyCodeLine{275 }
\DoxyCodeLine{276 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{struct }\mbox{\hyperlink{structdisjunction}{disjunction}} : std::false\_type \{\};}
\DoxyCodeLine{277 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P> \textcolor{keyword}{struct }\mbox{\hyperlink{structdisjunction_3_01P_01_4}{disjunction<P>}} : P \{\};}
\DoxyCodeLine{278 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1, \textcolor{keyword}{typename}... Pn>}
\DoxyCodeLine{279 \textcolor{keyword}{struct }\mbox{\hyperlink{structdisjunction}{disjunction}}<P1, Pn...>}
\DoxyCodeLine{280     : conditional\_t<bool(P1::value), P1, disjunction<Pn...>> \{\};}
\DoxyCodeLine{281 }
\DoxyCodeLine{282 \textcolor{keyword}{template} <\textcolor{keyword}{typename}...> \textcolor{keyword}{struct }\mbox{\hyperlink{structconjunction}{conjunction}} : std::true\_type \{\};}
\DoxyCodeLine{283 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P> \textcolor{keyword}{struct }\mbox{\hyperlink{structconjunction_3_01P_01_4}{conjunction<P>}} : P \{\};}
\DoxyCodeLine{284 \textcolor{keyword}{template} <\textcolor{keyword}{typename} P1, \textcolor{keyword}{typename}... Pn>}
\DoxyCodeLine{285 \textcolor{keyword}{struct }\mbox{\hyperlink{structconjunction}{conjunction}}<P1, Pn...>}
\DoxyCodeLine{286     : conditional\_t<bool(P1::value), conjunction<Pn...>, P1> \{\};}
\DoxyCodeLine{287 }
\DoxyCodeLine{288 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keywordtype}{void} abort\_fuzzing\_if(\textcolor{keywordtype}{bool} condition) \{}
\DoxyCodeLine{291   ignore\_unused(condition);}
\DoxyCodeLine{292 \textcolor{preprocessor}{\#ifdef FMT\_FUZZ}}
\DoxyCodeLine{293   \textcolor{keywordflow}{if} (condition) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}fuzzing limit reached"{}});}
\DoxyCodeLine{294 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{295 \}}
\DoxyCodeLine{296 }
\DoxyCodeLine{297 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharT, CharT... C> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1string__literal}{string\_literal}} \{}
\DoxyCodeLine{298   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} CharT \mbox{\hyperlink{classdetail_1_1value}{value}}[\textcolor{keyword}{sizeof}...(C)] = \{C...\};}
\DoxyCodeLine{299   \textcolor{keyword}{constexpr} \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<CharT>}}()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{300     \textcolor{keywordflow}{return} \{\mbox{\hyperlink{classdetail_1_1value}{value}}, \textcolor{keyword}{sizeof}...(C)\};}
\DoxyCodeLine{301   \}}
\DoxyCodeLine{302 \};}
\DoxyCodeLine{303 }
\DoxyCodeLine{304 \textcolor{preprocessor}{\#if FMT\_CPLUSPLUS < 201703L}}
\DoxyCodeLine{305 \textcolor{keyword}{template} <\textcolor{keyword}{typename} CharT, CharT... C>}
\DoxyCodeLine{306 \textcolor{keyword}{constexpr} CharT \mbox{\hyperlink{structdetail_1_1string__literal}{string\_literal}}<CharT, C...>::value[\textcolor{keyword}{sizeof}...(C)];}
\DoxyCodeLine{307 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{308 }
\DoxyCodeLine{309 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Streambuf> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1formatbuf}{formatbuf}} : \textcolor{keyword}{public} Streambuf \{}
\DoxyCodeLine{310  \textcolor{keyword}{private}:}
\DoxyCodeLine{311   \textcolor{keyword}{using }char\_type = \textcolor{keyword}{typename} Streambuf::char\_type;}
\DoxyCodeLine{312   \textcolor{keyword}{using }streamsize = \textcolor{keyword}{decltype}(std::declval<Streambuf>().sputn(\textcolor{keyword}{nullptr}, 0));}
\DoxyCodeLine{313   \textcolor{keyword}{using }int\_type = \textcolor{keyword}{typename} Streambuf::int\_type;}
\DoxyCodeLine{314   \textcolor{keyword}{using }traits\_type = \textcolor{keyword}{typename} Streambuf::traits\_type;}
\DoxyCodeLine{315 }
\DoxyCodeLine{316   \mbox{\hyperlink{classdetail_1_1buffer}{buffer<char\_type>}}\& buffer\_;}
\DoxyCodeLine{317 }
\DoxyCodeLine{318  \textcolor{keyword}{public}:}
\DoxyCodeLine{319   \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1formatbuf}{formatbuf}}(\mbox{\hyperlink{classdetail_1_1buffer}{buffer<char\_type>}}\& buf) : buffer\_(buf) \{\}}
\DoxyCodeLine{320 }
\DoxyCodeLine{321  \textcolor{keyword}{protected}:}
\DoxyCodeLine{322   \textcolor{comment}{// The put area is always empty. This makes the implementation simpler and has}}
\DoxyCodeLine{323   \textcolor{comment}{// the advantage that the streambuf and the buffer are always in sync and}}
\DoxyCodeLine{324   \textcolor{comment}{// sputc never writes into uninitialized memory. A disadvantage is that each}}
\DoxyCodeLine{325   \textcolor{comment}{// call to sputc always results in a (virtual) call to overflow. There is no}}
\DoxyCodeLine{326   \textcolor{comment}{// disadvantage here for sputn since this always results in a call to xsputn.}}
\DoxyCodeLine{327 }
\DoxyCodeLine{328   \textcolor{keyword}{auto} overflow(int\_type ch) -\/> int\_type \textcolor{keyword}{override} \{}
\DoxyCodeLine{329     \textcolor{keywordflow}{if} (!traits\_type::eq\_int\_type(ch, traits\_type::eof()))}
\DoxyCodeLine{330       buffer\_.push\_back(\textcolor{keyword}{static\_cast<}char\_type\textcolor{keyword}{>}(ch));}
\DoxyCodeLine{331     \textcolor{keywordflow}{return} ch;}
\DoxyCodeLine{332   \}}
\DoxyCodeLine{333 }
\DoxyCodeLine{334   \textcolor{keyword}{auto} xsputn(\textcolor{keyword}{const} char\_type* s, streamsize count) -\/> streamsize \textcolor{keyword}{override} \{}
\DoxyCodeLine{335     buffer\_.\mbox{\hyperlink{classdetail_1_1buffer_ab12c0beccf64adf0091468e357ed4b92}{append}}(s, s + count);}
\DoxyCodeLine{336     \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{337   \}}
\DoxyCodeLine{338 \};}
\DoxyCodeLine{339 }
\DoxyCodeLine{340 \textcolor{comment}{// Implementation of std::bit\_cast for pre-\/C++20.}}
\DoxyCodeLine{341 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From, FMT\_ENABLE\_IF(sizeof(To) == sizeof(From))>}
\DoxyCodeLine{342 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} bit\_cast(\textcolor{keyword}{const} From\& from) -\/> To \{}
\DoxyCodeLine{343 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_bit\_cast}}
\DoxyCodeLine{344   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \textcolor{keywordflow}{return} std::bit\_cast<To>(from);}
\DoxyCodeLine{345 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{346   \textcolor{keyword}{auto} to = To();}
\DoxyCodeLine{347   \textcolor{comment}{// The cast suppresses a bogus -\/Wclass-\/memaccess on GCC.}}
\DoxyCodeLine{348   std::memcpy(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{void}*\textcolor{keyword}{>}(\&to), \&from, \textcolor{keyword}{sizeof}(to));}
\DoxyCodeLine{349   \textcolor{keywordflow}{return} to;}
\DoxyCodeLine{350 \}}
\DoxyCodeLine{351 }
\DoxyCodeLine{352 \textcolor{keyword}{inline} \textcolor{keyword}{auto} is\_big\_endian() -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{353 \textcolor{preprocessor}{\#ifdef \_WIN32}}
\DoxyCodeLine{354   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{355 \textcolor{preprocessor}{\#elif defined(\_\_BIG\_ENDIAN\_\_)}}
\DoxyCodeLine{356   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{357 \textcolor{preprocessor}{\#elif defined(\_\_BYTE\_ORDER\_\_) \&\& defined(\_\_ORDER\_BIG\_ENDIAN\_\_)}}
\DoxyCodeLine{358   \textcolor{keywordflow}{return} \_\_BYTE\_ORDER\_\_ == \_\_ORDER\_BIG\_ENDIAN\_\_;}
\DoxyCodeLine{359 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{360   \textcolor{keyword}{struct }\mbox{\hyperlink{classbytes}{bytes}} \{}
\DoxyCodeLine{361     \textcolor{keywordtype}{char} data[\textcolor{keyword}{sizeof}(int)];}
\DoxyCodeLine{362   \};}
\DoxyCodeLine{363   \textcolor{keywordflow}{return} bit\_cast<bytes>(1).data[0] == 0;}
\DoxyCodeLine{364 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{365 \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{368  \textcolor{keyword}{private}:}
\DoxyCodeLine{369   uint64\_t lo\_, hi\_;}
\DoxyCodeLine{370 }
\DoxyCodeLine{371   \textcolor{keyword}{friend} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} umul128(uint64\_t x, uint64\_t y) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{372 }
\DoxyCodeLine{373  \textcolor{keyword}{public}:}
\DoxyCodeLine{374   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}(uint64\_t hi, uint64\_t lo) : lo\_(lo), hi\_(hi) \{\}}
\DoxyCodeLine{375   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}(uint64\_t \mbox{\hyperlink{classdetail_1_1value}{value}} = 0) : lo\_(\mbox{\hyperlink{classdetail_1_1value}{value}}), hi\_(0) \{\}}
\DoxyCodeLine{376 }
\DoxyCodeLine{377   \textcolor{keyword}{constexpr} uint64\_t high() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} hi\_; \}}
\DoxyCodeLine{378   \textcolor{keyword}{constexpr} uint64\_t low() \textcolor{keyword}{const} \textcolor{keyword}{noexcept} \{ \textcolor{keywordflow}{return} lo\_; \}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{381   \textcolor{keyword}{constexpr} \textcolor{keyword}{explicit} \textcolor{keyword}{operator} T()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{382     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}T\textcolor{keyword}{>}(lo\_);}
\DoxyCodeLine{383   \}}
\DoxyCodeLine{384 }
\DoxyCodeLine{385   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator==(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs,}
\DoxyCodeLine{386                                    \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{387     \textcolor{keywordflow}{return} lhs.hi\_ == rhs.hi\_ \&\& lhs.lo\_ == rhs.lo\_;}
\DoxyCodeLine{388   \}}
\DoxyCodeLine{389   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator!=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs,}
\DoxyCodeLine{390                                    \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{391     \textcolor{keywordflow}{return} !(lhs == rhs);}
\DoxyCodeLine{392   \}}
\DoxyCodeLine{393   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator>(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs,}
\DoxyCodeLine{394                                   \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{395     \textcolor{keywordflow}{return} lhs.hi\_ != rhs.hi\_ ? lhs.hi\_ > rhs.hi\_ : lhs.lo\_ > rhs.lo\_;}
\DoxyCodeLine{396   \}}
\DoxyCodeLine{397   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator|(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs,}
\DoxyCodeLine{398                                   \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& rhs)}
\DoxyCodeLine{399       -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{400     \textcolor{keywordflow}{return} \{lhs.hi\_ | rhs.hi\_, lhs.lo\_ | rhs.lo\_\};}
\DoxyCodeLine{401   \}}
\DoxyCodeLine{402   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator\&(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs,}
\DoxyCodeLine{403                                   \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& rhs)}
\DoxyCodeLine{404       -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{405     \textcolor{keywordflow}{return} \{lhs.hi\_ \& rhs.hi\_, lhs.lo\_ \& rhs.lo\_\};}
\DoxyCodeLine{406   \}}
\DoxyCodeLine{407   \textcolor{keyword}{friend} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} operator\string~(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& n)}
\DoxyCodeLine{408       -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{409     \textcolor{keywordflow}{return} \{\string~n.hi\_, \string~n.lo\_\};}
\DoxyCodeLine{410   \}}
\DoxyCodeLine{411   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator+(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs,}
\DoxyCodeLine{412                         \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& rhs) -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{413     \textcolor{keyword}{auto} result = \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}(lhs);}
\DoxyCodeLine{414     result += rhs;}
\DoxyCodeLine{415     \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{416   \}}
\DoxyCodeLine{417   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator*(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs, uint32\_t rhs)}
\DoxyCodeLine{418       -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{419     FMT\_ASSERT(lhs.hi\_ == 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{420     uint64\_t hi = (lhs.lo\_ >> 32) * rhs;}
\DoxyCodeLine{421     uint64\_t lo = (lhs.lo\_ \& \string~uint32\_t()) * rhs;}
\DoxyCodeLine{422     uint64\_t new\_lo = (hi << 32) + lo;}
\DoxyCodeLine{423     \textcolor{keywordflow}{return} \{(hi >> 32) + (new\_lo < lo ? 1 : 0), new\_lo\};}
\DoxyCodeLine{424   \}}
\DoxyCodeLine{425   \textcolor{keyword}{friend} \textcolor{keyword}{auto} operator-\/(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& lhs, uint64\_t rhs)}
\DoxyCodeLine{426       -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{427     \textcolor{keywordflow}{return} \{lhs.hi\_ -\/ (lhs.lo\_ < rhs ? 1 : 0), lhs.lo\_ -\/ rhs\};}
\DoxyCodeLine{428   \}}
\DoxyCodeLine{429   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator>>(\textcolor{keywordtype}{int} shift) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{430     \textcolor{keywordflow}{if} (shift == 64) \textcolor{keywordflow}{return} \{0, hi\_\};}
\DoxyCodeLine{431     \textcolor{keywordflow}{if} (shift > 64) \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}(0, hi\_) >> (shift -\/ 64);}
\DoxyCodeLine{432     \textcolor{keywordflow}{return} \{hi\_ >> shift, (hi\_ << (64 -\/ shift)) | (lo\_ >> shift)\};}
\DoxyCodeLine{433   \}}
\DoxyCodeLine{434   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator<<(\textcolor{keywordtype}{int} shift) \textcolor{keyword}{const} -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} \{}
\DoxyCodeLine{435     \textcolor{keywordflow}{if} (shift == 64) \textcolor{keywordflow}{return} \{lo\_, 0\};}
\DoxyCodeLine{436     \textcolor{keywordflow}{if} (shift > 64) \textcolor{keywordflow}{return} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}(lo\_, 0) << (shift -\/ 64);}
\DoxyCodeLine{437     \textcolor{keywordflow}{return} \{hi\_ << shift | (lo\_ >> (64 -\/ shift)), (lo\_ << shift)\};}
\DoxyCodeLine{438   \}}
\DoxyCodeLine{439   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator>>=(\textcolor{keywordtype}{int} shift) -\/> \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& \{}
\DoxyCodeLine{440     \textcolor{keywordflow}{return} *\textcolor{keyword}{this} = *\textcolor{keyword}{this} >> shift;}
\DoxyCodeLine{441   \}}
\DoxyCodeLine{442   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator+=(\mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} n) \{}
\DoxyCodeLine{443     uint64\_t new\_lo = lo\_ + n.lo\_;}
\DoxyCodeLine{444     uint64\_t new\_hi = hi\_ + n.hi\_ + (new\_lo < lo\_ ? 1 : 0);}
\DoxyCodeLine{445     FMT\_ASSERT(new\_hi >= hi\_, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{446     lo\_ = new\_lo;}
\DoxyCodeLine{447     hi\_ = new\_hi;}
\DoxyCodeLine{448   \}}
\DoxyCodeLine{449   FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator\&=(\mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} n) \{}
\DoxyCodeLine{450     lo\_ \&= n.lo\_;}
\DoxyCodeLine{451     hi\_ \&= n.hi\_;}
\DoxyCodeLine{452   \}}
\DoxyCodeLine{453 }
\DoxyCodeLine{454   FMT\_CONSTEXPR20 \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}}\& operator+=(uint64\_t n) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{455     \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{456       lo\_ += n;}
\DoxyCodeLine{457       hi\_ += (lo\_ < n ? 1 : 0);}
\DoxyCodeLine{458       \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{459     \}}
\DoxyCodeLine{460 \textcolor{preprocessor}{\#if FMT\_HAS\_BUILTIN(\_\_builtin\_addcll) \&\& !defined(\_\_ibmxl\_\_)}}
\DoxyCodeLine{461     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} carry;}
\DoxyCodeLine{462     lo\_ = \_\_builtin\_addcll(lo\_, n, 0, \&carry);}
\DoxyCodeLine{463     hi\_ += carry;}
\DoxyCodeLine{464 \textcolor{preprocessor}{\#elif FMT\_HAS\_BUILTIN(\_\_builtin\_ia32\_addcarryx\_u64) \&\& !defined(\_\_ibmxl\_\_)}}
\DoxyCodeLine{465     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} result;}
\DoxyCodeLine{466     \textcolor{keyword}{auto} carry = \_\_builtin\_ia32\_addcarryx\_u64(0, lo\_, n, \&result);}
\DoxyCodeLine{467     lo\_ = result;}
\DoxyCodeLine{468     hi\_ += carry;}
\DoxyCodeLine{469 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) \&\& defined(\_M\_X64)}}
\DoxyCodeLine{470     \textcolor{keyword}{auto} carry = \_addcarry\_u64(0, lo\_, n, \&lo\_);}
\DoxyCodeLine{471     \_addcarry\_u64(carry, hi\_, 0, \&hi\_);}
\DoxyCodeLine{472 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{473     lo\_ += n;}
\DoxyCodeLine{474     hi\_ += (lo\_ < n ? 1 : 0);}
\DoxyCodeLine{475 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{476     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{477   \}}
\DoxyCodeLine{478 \};}
\DoxyCodeLine{479 }
\DoxyCodeLine{480 \textcolor{keyword}{using }uint128\_t = conditional\_t<FMT\_USE\_INT128, uint128\_opt, uint128\_fallback>;}
\DoxyCodeLine{481 }
\DoxyCodeLine{482 \textcolor{preprocessor}{\#ifdef UINTPTR\_MAX}}
\DoxyCodeLine{483 \textcolor{keyword}{using }uintptr\_t = ::uintptr\_t;}
\DoxyCodeLine{484 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{485 \textcolor{keyword}{using }uintptr\_t = uint128\_t;}
\DoxyCodeLine{486 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{487 }
\DoxyCodeLine{488 \textcolor{comment}{// Returns the largest possible value for type T. Same as}}
\DoxyCodeLine{489 \textcolor{comment}{// std::numeric\_limits<T>::max() but shorter and not affected by the max macro.}}
\DoxyCodeLine{490 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} max\_value() -\/> T \{}
\DoxyCodeLine{491   \textcolor{keywordflow}{return} (std::numeric\_limits<T>::max)();}
\DoxyCodeLine{492 \}}
\DoxyCodeLine{493 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_bits() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{494   \textcolor{keywordflow}{return} std::numeric\_limits<T>::digits;}
\DoxyCodeLine{495 \}}
\DoxyCodeLine{496 \textcolor{comment}{// std::numeric\_limits<T>::digits may return 0 for 128-\/bit ints.}}
\DoxyCodeLine{497 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_bits<int128\_opt>() -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 128; \}}
\DoxyCodeLine{498 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_bits<uint128\_t>() -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 128; \}}
\DoxyCodeLine{499 }
\DoxyCodeLine{500 \textcolor{comment}{// A heterogeneous bit\_cast used for converting 96-\/bit long double to uint128\_t}}
\DoxyCodeLine{501 \textcolor{comment}{// and 128-\/bit pointers to uint128\_fallback.}}
\DoxyCodeLine{502 \textcolor{keyword}{template} <\textcolor{keyword}{typename} To, \textcolor{keyword}{typename} From, FMT\_ENABLE\_IF(sizeof(To) > \textcolor{keyword}{sizeof}(From))>}
\DoxyCodeLine{503 \textcolor{keyword}{inline} \textcolor{keyword}{auto} bit\_cast(\textcolor{keyword}{const} From\& from) -\/> To \{}
\DoxyCodeLine{504   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} size = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keyword}{sizeof}(From) / \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned}));}
\DoxyCodeLine{505   \textcolor{keyword}{struct }data\_t \{}
\DoxyCodeLine{506     \textcolor{keywordtype}{unsigned} value[\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(size)];}
\DoxyCodeLine{507   \} data = bit\_cast<data\_t>(from);}
\DoxyCodeLine{508   \textcolor{keyword}{auto} result = To();}
\DoxyCodeLine{509   \textcolor{keywordflow}{if} (const\_check(is\_big\_endian())) \{}
\DoxyCodeLine{510     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < size; ++i)}
\DoxyCodeLine{511       result = (result << num\_bits<unsigned>()) | data.value[i];}
\DoxyCodeLine{512   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{513     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = size -\/ 1; i >= 0; -\/-\/i)}
\DoxyCodeLine{514       result = (result << num\_bits<unsigned>()) | data.value[i];}
\DoxyCodeLine{515   \}}
\DoxyCodeLine{516   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{517 \}}
\DoxyCodeLine{518 }
\DoxyCodeLine{519 \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{520 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keyword}{auto} countl\_zero\_fallback(UInt n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{521   \textcolor{keywordtype}{int} lz = 0;}
\DoxyCodeLine{522   \textcolor{keyword}{constexpr} UInt msb\_mask = \textcolor{keyword}{static\_cast<}UInt\textcolor{keyword}{>}(1) << (num\_bits<UInt>() -\/ 1);}
\DoxyCodeLine{523   \textcolor{keywordflow}{for} (; (n \& msb\_mask) == 0; n <<= 1) lz++;}
\DoxyCodeLine{524   \textcolor{keywordflow}{return} lz;}
\DoxyCodeLine{525 \}}
\DoxyCodeLine{526 }
\DoxyCodeLine{527 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keyword}{auto} countl\_zero(uint32\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{528 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{529   \textcolor{keywordflow}{if} (!is\_constant\_evaluated()) \textcolor{keywordflow}{return} FMT\_BUILTIN\_CLZ(n);}
\DoxyCodeLine{530 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{531   \textcolor{keywordflow}{return} countl\_zero\_fallback(n);}
\DoxyCodeLine{532 \}}
\DoxyCodeLine{533 }
\DoxyCodeLine{534 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keyword}{auto} countl\_zero(uint64\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{535 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZLL}}
\DoxyCodeLine{536   \textcolor{keywordflow}{if} (!is\_constant\_evaluated()) \textcolor{keywordflow}{return} FMT\_BUILTIN\_CLZLL(n);}
\DoxyCodeLine{537 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{538   \textcolor{keywordflow}{return} countl\_zero\_fallback(n);}
\DoxyCodeLine{539 \}}
\DoxyCodeLine{540 }
\DoxyCodeLine{541 FMT\_INLINE \textcolor{keywordtype}{void} assume(\textcolor{keywordtype}{bool} condition) \{}
\DoxyCodeLine{542   (void)condition;}
\DoxyCodeLine{543 \textcolor{preprocessor}{\#if FMT\_HAS\_BUILTIN(\_\_builtin\_assume) \&\& !FMT\_ICC\_VERSION}}
\DoxyCodeLine{544   \_\_builtin\_assume(condition);}
\DoxyCodeLine{545 \textcolor{preprocessor}{\#elif FMT\_GCC\_VERSION}}
\DoxyCodeLine{546   \textcolor{keywordflow}{if} (!condition) \_\_builtin\_unreachable();}
\DoxyCodeLine{547 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{548 \}}
\DoxyCodeLine{549 }
\DoxyCodeLine{550 \textcolor{comment}{// An approximation of iterator\_t for pre-\/C++20 systems.}}
\DoxyCodeLine{551 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{552 \textcolor{keyword}{using }iterator\_t = \textcolor{keyword}{decltype}(std::begin(std::declval<T\&>()));}
\DoxyCodeLine{553 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }sentinel\_t = \textcolor{keyword}{decltype}(std::end(std::declval<T\&>()));}
\DoxyCodeLine{554 }
\DoxyCodeLine{555 \textcolor{comment}{// A workaround for std::string not having mutable data() until C++17.}}
\DoxyCodeLine{556 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{557 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_data(std::basic\_string<Char>\& s) -\/> Char* \{}
\DoxyCodeLine{558   \textcolor{keywordflow}{return} \&s[0];}
\DoxyCodeLine{559 \}}
\DoxyCodeLine{560 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container>}
\DoxyCodeLine{561 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_data(Container\& c) -\/> \textcolor{keyword}{typename} Container::value\_type* \{}
\DoxyCodeLine{562   \textcolor{keywordflow}{return} c.data();}
\DoxyCodeLine{563 \}}
\DoxyCodeLine{564 }
\DoxyCodeLine{565 \textcolor{comment}{// Attempts to reserve space for n extra characters in the output range.}}
\DoxyCodeLine{566 \textcolor{comment}{// Returns a pointer to the reserved range or a reference to it.}}
\DoxyCodeLine{567 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container, FMT\_ENABLE\_IF(is\_contiguous<Container>::value)>}
\DoxyCodeLine{568 \textcolor{preprocessor}{\#if FMT\_CLANG\_VERSION >= 307 \&\& !FMT\_ICC\_VERSION}}
\DoxyCodeLine{569 \_\_attribute\_\_((no\_sanitize(\textcolor{stringliteral}{"{}undefined"{}})))}
\DoxyCodeLine{570 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{571 \textcolor{keyword}{inline} \textcolor{keyword}{auto}}
\DoxyCodeLine{572 reserve(std::back\_insert\_iterator<Container> it, \textcolor{keywordtype}{size\_t} n) -\/>}
\DoxyCodeLine{573     \textcolor{keyword}{typename} Container::value\_type* \{}
\DoxyCodeLine{574   Container\& c = get\_container(it);}
\DoxyCodeLine{575   \textcolor{keywordtype}{size\_t} size = c.size();}
\DoxyCodeLine{576   c.resize(size + n);}
\DoxyCodeLine{577   \textcolor{keywordflow}{return} get\_data(c) + size;}
\DoxyCodeLine{578 \}}
\DoxyCodeLine{579 }
\DoxyCodeLine{580 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{581 \textcolor{keyword}{inline} \textcolor{keyword}{auto} reserve(buffer\_appender<T> it, \textcolor{keywordtype}{size\_t} n) -\/> buffer\_appender<T> \{}
\DoxyCodeLine{582   buffer<T>\& buf = get\_container(it);}
\DoxyCodeLine{583   buf.try\_reserve(buf.size() + n);}
\DoxyCodeLine{584   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{585 \}}
\DoxyCodeLine{586 }
\DoxyCodeLine{587 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{588 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} reserve(Iterator\& it, \textcolor{keywordtype}{size\_t}) -\/> Iterator\& \{}
\DoxyCodeLine{589   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{590 \}}
\DoxyCodeLine{591 }
\DoxyCodeLine{592 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{593 \textcolor{keyword}{using }reserve\_iterator =}
\DoxyCodeLine{594     remove\_reference\_t<decltype(reserve(std::declval<OutputIt\&>(), 0))>;}
\DoxyCodeLine{595 }
\DoxyCodeLine{596 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{597 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} to\_pointer(OutputIt, \textcolor{keywordtype}{size\_t}) -\/> T* \{}
\DoxyCodeLine{598   \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{599 \}}
\DoxyCodeLine{600 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} to\_pointer(buffer\_appender<T> it, \textcolor{keywordtype}{size\_t} n) -\/> T* \{}
\DoxyCodeLine{601   buffer<T>\& buf = get\_container(it);}
\DoxyCodeLine{602   \textcolor{keyword}{auto} size = buf.size();}
\DoxyCodeLine{603   \textcolor{keywordflow}{if} (buf.capacity() < size + n) \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};}
\DoxyCodeLine{604   buf.try\_resize(size + n);}
\DoxyCodeLine{605   \textcolor{keywordflow}{return} buf.data() + size;}
\DoxyCodeLine{606 \}}
\DoxyCodeLine{607 }
\DoxyCodeLine{608 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Container, FMT\_ENABLE\_IF(is\_contiguous<Container>::value)>}
\DoxyCodeLine{609 \textcolor{keyword}{inline} \textcolor{keyword}{auto} base\_iterator(std::back\_insert\_iterator<Container> it,}
\DoxyCodeLine{610                           \textcolor{keyword}{typename} Container::value\_type*)}
\DoxyCodeLine{611     -\/> std::back\_insert\_iterator<Container> \{}
\DoxyCodeLine{612   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{613 \}}
\DoxyCodeLine{614 }
\DoxyCodeLine{615 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{616 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} base\_iterator(Iterator, Iterator it) -\/> Iterator \{}
\DoxyCodeLine{617   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{618 \}}
\DoxyCodeLine{619 }
\DoxyCodeLine{620 \textcolor{comment}{// <algorithm> is spectacularly slow to compile in C++20 so use a simple fill\_n}}
\DoxyCodeLine{621 \textcolor{comment}{// instead (\#1998).}}
\DoxyCodeLine{622 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Size, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{623 FMT\_CONSTEXPR \textcolor{keyword}{auto} fill\_n(OutputIt out, Size count, \textcolor{keyword}{const} T\& value)}
\DoxyCodeLine{624     -\/> OutputIt \{}
\DoxyCodeLine{625   \textcolor{keywordflow}{for} (Size i = 0; i < count; ++i) *out++ = value;}
\DoxyCodeLine{626   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{627 \}}
\DoxyCodeLine{628 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Size>}
\DoxyCodeLine{629 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} fill\_n(T* out, Size count, \textcolor{keywordtype}{char} value) -\/> T* \{}
\DoxyCodeLine{630   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{631     \textcolor{keywordflow}{return} fill\_n<T*, Size, T>(out, count, value);}
\DoxyCodeLine{632   \}}
\DoxyCodeLine{633   std::memset(out, value, to\_unsigned(count));}
\DoxyCodeLine{634   \textcolor{keywordflow}{return} out + count;}
\DoxyCodeLine{635 \}}
\DoxyCodeLine{636 }
\DoxyCodeLine{637 \textcolor{preprocessor}{\#ifdef \_\_cpp\_char8\_t}}
\DoxyCodeLine{638 \textcolor{keyword}{using }char8\_type = char8\_t;}
\DoxyCodeLine{639 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{640 \textcolor{keyword}{enum} char8\_type : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{\};}
\DoxyCodeLine{641 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{642 }
\DoxyCodeLine{643 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutChar, \textcolor{keyword}{typename} InputIt, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{644 FMT\_CONSTEXPR FMT\_NOINLINE \textcolor{keyword}{auto} copy\_str\_noinline(InputIt begin, InputIt end,}
\DoxyCodeLine{645                                                   OutputIt out) -\/> OutputIt \{}
\DoxyCodeLine{646   \textcolor{keywordflow}{return} copy\_str<OutChar>(begin, end, out);}
\DoxyCodeLine{647 \}}
\DoxyCodeLine{648 }
\DoxyCodeLine{649 \textcolor{comment}{// A public domain branchless UTF-\/8 decoder by Christopher Wellons:}}
\DoxyCodeLine{650 \textcolor{comment}{// https://github.com/skeeto/branchless-\/utf8}}
\DoxyCodeLine{651 \textcolor{comment}{/* Decode the next character, c, from s, reporting errors in e.}}
\DoxyCodeLine{652 \textcolor{comment}{ *}}
\DoxyCodeLine{653 \textcolor{comment}{ * Since this is a branchless decoder, four bytes will be read from the}}
\DoxyCodeLine{654 \textcolor{comment}{ * buffer regardless of the actual length of the next character. This}}
\DoxyCodeLine{655 \textcolor{comment}{ * means the buffer \_must\_ have at least three bytes of zero padding}}
\DoxyCodeLine{656 \textcolor{comment}{ * following the end of the data stream.}}
\DoxyCodeLine{657 \textcolor{comment}{ *}}
\DoxyCodeLine{658 \textcolor{comment}{ * Errors are reported in e, which will be non-\/zero if the parsed}}
\DoxyCodeLine{659 \textcolor{comment}{ * character was somehow invalid: invalid byte sequence, non-\/canonical}}
\DoxyCodeLine{660 \textcolor{comment}{ * encoding, or a surrogate half.}}
\DoxyCodeLine{661 \textcolor{comment}{ *}}
\DoxyCodeLine{662 \textcolor{comment}{ * The function returns a pointer to the next character. When an error}}
\DoxyCodeLine{663 \textcolor{comment}{ * occurs, this pointer will be a guess that depends on the particular}}
\DoxyCodeLine{664 \textcolor{comment}{ * error, but it will always advance at least one byte.}}
\DoxyCodeLine{665 \textcolor{comment}{ */}}
\DoxyCodeLine{666 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} utf8\_decode(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, uint32\_t* c, \textcolor{keywordtype}{int}* e)}
\DoxyCodeLine{667     -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{668   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} masks[] = \{0x00, 0x7f, 0x1f, 0x0f, 0x07\};}
\DoxyCodeLine{669   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} uint32\_t mins[] = \{4194304, 0, 128, 2048, 65536\};}
\DoxyCodeLine{670   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shiftc[] = \{0, 18, 12, 6, 0\};}
\DoxyCodeLine{671   \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shifte[] = \{0, 6, 4, 2, 0\};}
\DoxyCodeLine{672 }
\DoxyCodeLine{673   \textcolor{keywordtype}{int} len = \textcolor{stringliteral}{"{}\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)1\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)0\(\backslash\)2\(\backslash\)2\(\backslash\)2\(\backslash\)2\(\backslash\)3\(\backslash\)3\(\backslash\)4"{}}}
\DoxyCodeLine{674       [\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(*s) >> 3];}
\DoxyCodeLine{675   \textcolor{comment}{// Compute the pointer to the next character early so that the next}}
\DoxyCodeLine{676   \textcolor{comment}{// iteration can start working on the next character. Neither Clang}}
\DoxyCodeLine{677   \textcolor{comment}{// nor GCC figure out this reordering on their own.}}
\DoxyCodeLine{678   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* next = s + len + !len;}
\DoxyCodeLine{679 }
\DoxyCodeLine{680   \textcolor{keyword}{using }uchar = \textcolor{keywordtype}{unsigned} char;}
\DoxyCodeLine{681 }
\DoxyCodeLine{682   \textcolor{comment}{// Assume a four-\/byte character and load four bytes. Unused bits are}}
\DoxyCodeLine{683   \textcolor{comment}{// shifted out.}}
\DoxyCodeLine{684   *c = uint32\_t(uchar(s[0]) \& masks[len]) << 18;}
\DoxyCodeLine{685   *c |= uint32\_t(uchar(s[1]) \& 0x3f) << 12;}
\DoxyCodeLine{686   *c |= uint32\_t(uchar(s[2]) \& 0x3f) << 6;}
\DoxyCodeLine{687   *c |= uint32\_t(uchar(s[3]) \& 0x3f) << 0;}
\DoxyCodeLine{688   *c >>= shiftc[len];}
\DoxyCodeLine{689 }
\DoxyCodeLine{690   \textcolor{comment}{// Accumulate the various error conditions.}}
\DoxyCodeLine{691   *e = (*c < mins[len]) << 6;       \textcolor{comment}{// non-\/canonical encoding}}
\DoxyCodeLine{692   *e |= ((*c >> 11) == 0x1b) << 7;  \textcolor{comment}{// surrogate half?}}
\DoxyCodeLine{693   *e |= (*c > 0x10FFFF) << 8;       \textcolor{comment}{// out of range?}}
\DoxyCodeLine{694   *e |= (uchar(s[1]) \& 0xc0) >> 2;}
\DoxyCodeLine{695   *e |= (uchar(s[2]) \& 0xc0) >> 4;}
\DoxyCodeLine{696   *e |= uchar(s[3]) >> 6;}
\DoxyCodeLine{697   *e \string^= 0x2a;  \textcolor{comment}{// top two bits of each tail byte correct?}}
\DoxyCodeLine{698   *e >>= shifte[len];}
\DoxyCodeLine{699 }
\DoxyCodeLine{700   \textcolor{keywordflow}{return} next;}
\DoxyCodeLine{701 \}}
\DoxyCodeLine{702 }
\DoxyCodeLine{703 \textcolor{keyword}{constexpr} FMT\_INLINE\_VARIABLE uint32\_t invalid\_code\_point = \string~uint32\_t();}
\DoxyCodeLine{704 }
\DoxyCodeLine{705 \textcolor{comment}{// Invokes f(cp, sv) for every code point cp in s with sv being the string view}}
\DoxyCodeLine{706 \textcolor{comment}{// corresponding to the code point. cp is invalid\_code\_point on error.}}
\DoxyCodeLine{707 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F>}
\DoxyCodeLine{708 FMT\_CONSTEXPR \textcolor{keywordtype}{void} for\_each\_codepoint(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s, F f) \{}
\DoxyCodeLine{709   \textcolor{keyword}{auto} decode = [f](\textcolor{keyword}{const} \textcolor{keywordtype}{char}* buf\_ptr, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* ptr) \{}
\DoxyCodeLine{710     \textcolor{keyword}{auto} cp = uint32\_t();}
\DoxyCodeLine{711     \textcolor{keyword}{auto} error = 0;}
\DoxyCodeLine{712     \textcolor{keyword}{auto} end = utf8\_decode(buf\_ptr, \&cp, \&error);}
\DoxyCodeLine{713     \textcolor{keywordtype}{bool} result = f(error ? invalid\_code\_point : cp,}
\DoxyCodeLine{714                     \mbox{\hyperlink{classbasic__string__view}{string\_view}}(ptr, error ? 1 : to\_unsigned(end -\/ buf\_ptr)));}
\DoxyCodeLine{715     \textcolor{keywordflow}{return} result ? (error ? buf\_ptr + 1 : end) : \textcolor{keyword}{nullptr};}
\DoxyCodeLine{716   \};}
\DoxyCodeLine{717   \textcolor{keyword}{auto} p = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{718   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} block\_size = 4;  \textcolor{comment}{// utf8\_decode always reads blocks of 4 chars.}}
\DoxyCodeLine{719   \textcolor{keywordflow}{if} (s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() >= block\_size) \{}
\DoxyCodeLine{720     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} end = p + s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() -\/ block\_size + 1; p < end;) \{}
\DoxyCodeLine{721       p = decode(p, p);}
\DoxyCodeLine{722       \textcolor{keywordflow}{if} (!p) \textcolor{keywordflow}{return};}
\DoxyCodeLine{723     \}}
\DoxyCodeLine{724   \}}
\DoxyCodeLine{725   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} num\_chars\_left = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}() + s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() -\/ p) \{}
\DoxyCodeLine{726     \textcolor{keywordtype}{char} buf[2 * block\_size -\/ 1] = \{\};}
\DoxyCodeLine{727     copy\_str<char>(p, p + num\_chars\_left, buf);}
\DoxyCodeLine{728     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* buf\_ptr = buf;}
\DoxyCodeLine{729     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{730       \textcolor{keyword}{auto} end = decode(buf\_ptr, p);}
\DoxyCodeLine{731       \textcolor{keywordflow}{if} (!end) \textcolor{keywordflow}{return};}
\DoxyCodeLine{732       p += end -\/ buf\_ptr;}
\DoxyCodeLine{733       buf\_ptr = end;}
\DoxyCodeLine{734     \} \textcolor{keywordflow}{while} (buf\_ptr -\/ buf < num\_chars\_left);}
\DoxyCodeLine{735   \}}
\DoxyCodeLine{736 \}}
\DoxyCodeLine{737 }
\DoxyCodeLine{738 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{739 \textcolor{keyword}{inline} \textcolor{keyword}{auto} compute\_width(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{740   \textcolor{keywordflow}{return} s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{741 \}}
\DoxyCodeLine{742 }
\DoxyCodeLine{743 \textcolor{comment}{// Computes approximate display width of a UTF-\/8 string.}}
\DoxyCodeLine{744 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keywordtype}{size\_t} compute\_width(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s) \{}
\DoxyCodeLine{745   \textcolor{keywordtype}{size\_t} num\_code\_points = 0;}
\DoxyCodeLine{746   \textcolor{comment}{// It is not a lambda for compatibility with C++14.}}
\DoxyCodeLine{747   \textcolor{keyword}{struct }count\_code\_points \{}
\DoxyCodeLine{748     \textcolor{keywordtype}{size\_t}* count;}
\DoxyCodeLine{749     FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(uint32\_t cp, \mbox{\hyperlink{classbasic__string__view}{string\_view}}) \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{750       *count += detail::to\_unsigned(}
\DoxyCodeLine{751           1 +}
\DoxyCodeLine{752           (cp >= 0x1100 \&\&}
\DoxyCodeLine{753            (cp <= 0x115f ||  \textcolor{comment}{// Hangul Jamo init. consonants}}
\DoxyCodeLine{754             cp == 0x2329 ||  \textcolor{comment}{// LEFT-\/POINTING ANGLE BRACKET}}
\DoxyCodeLine{755             cp == 0x232a ||  \textcolor{comment}{// RIGHT-\/POINTING ANGLE BRACKET}}
\DoxyCodeLine{756             \textcolor{comment}{// CJK ... Yi except IDEOGRAPHIC HALF FILL SPACE:}}
\DoxyCodeLine{757             (cp >= 0x2e80 \&\& cp <= 0xa4cf \&\& cp != 0x303f) ||}
\DoxyCodeLine{758             (cp >= 0xac00 \&\& cp <= 0xd7a3) ||    \textcolor{comment}{// Hangul Syllables}}
\DoxyCodeLine{759             (cp >= 0xf900 \&\& cp <= 0xfaff) ||    \textcolor{comment}{// CJK Compatibility Ideographs}}
\DoxyCodeLine{760             (cp >= 0xfe10 \&\& cp <= 0xfe19) ||    \textcolor{comment}{// Vertical Forms}}
\DoxyCodeLine{761             (cp >= 0xfe30 \&\& cp <= 0xfe6f) ||    \textcolor{comment}{// CJK Compatibility Forms}}
\DoxyCodeLine{762             (cp >= 0xff00 \&\& cp <= 0xff60) ||    \textcolor{comment}{// Fullwidth Forms}}
\DoxyCodeLine{763             (cp >= 0xffe0 \&\& cp <= 0xffe6) ||    \textcolor{comment}{// Fullwidth Forms}}
\DoxyCodeLine{764             (cp >= 0x20000 \&\& cp <= 0x2fffd) ||  \textcolor{comment}{// CJK}}
\DoxyCodeLine{765             (cp >= 0x30000 \&\& cp <= 0x3fffd) ||}
\DoxyCodeLine{766             \textcolor{comment}{// Miscellaneous Symbols and Pictographs + Emoticons:}}
\DoxyCodeLine{767             (cp >= 0x1f300 \&\& cp <= 0x1f64f) ||}
\DoxyCodeLine{768             \textcolor{comment}{// Supplemental Symbols and Pictographs:}}
\DoxyCodeLine{769             (cp >= 0x1f900 \&\& cp <= 0x1f9ff))));}
\DoxyCodeLine{770       \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{771     \}}
\DoxyCodeLine{772   \};}
\DoxyCodeLine{773   \textcolor{comment}{// We could avoid branches by using utf8\_decode directly.}}
\DoxyCodeLine{774   for\_each\_codepoint(s, count\_code\_points\{\&num\_code\_points\});}
\DoxyCodeLine{775   \textcolor{keywordflow}{return} num\_code\_points;}
\DoxyCodeLine{776 \}}
\DoxyCodeLine{777 }
\DoxyCodeLine{778 \textcolor{keyword}{inline} \textcolor{keyword}{auto} compute\_width(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char8\_type>}} s) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{779   \textcolor{keywordflow}{return} compute\_width(}
\DoxyCodeLine{780       \mbox{\hyperlink{classbasic__string__view}{string\_view}}(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}()), s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}()));}
\DoxyCodeLine{781 \}}
\DoxyCodeLine{782 }
\DoxyCodeLine{783 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{784 \textcolor{keyword}{inline} \textcolor{keyword}{auto} code\_point\_index(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s, \textcolor{keywordtype}{size\_t} n) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{785   \textcolor{keywordtype}{size\_t} size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{786   \textcolor{keywordflow}{return} n < size ? n : size;}
\DoxyCodeLine{787 \}}
\DoxyCodeLine{788 }
\DoxyCodeLine{789 \textcolor{comment}{// Calculates the index of the nth code point in a UTF-\/8 string.}}
\DoxyCodeLine{790 \textcolor{keyword}{inline} \textcolor{keyword}{auto} code\_point\_index(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s, \textcolor{keywordtype}{size\_t} n) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{791   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* data = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{792   \textcolor{keywordtype}{size\_t} num\_code\_points = 0;}
\DoxyCodeLine{793   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}(); i != size; ++i) \{}
\DoxyCodeLine{794     \textcolor{keywordflow}{if} ((data[i] \& 0xc0) != 0x80 \&\& ++num\_code\_points > n) \textcolor{keywordflow}{return} i;}
\DoxyCodeLine{795   \}}
\DoxyCodeLine{796   \textcolor{keywordflow}{return} s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{797 \}}
\DoxyCodeLine{798 }
\DoxyCodeLine{799 \textcolor{keyword}{inline} \textcolor{keyword}{auto} code\_point\_index(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<char8\_type>}} s, \textcolor{keywordtype}{size\_t} n)}
\DoxyCodeLine{800     -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{801   \textcolor{keywordflow}{return} code\_point\_index(}
\DoxyCodeLine{802       \mbox{\hyperlink{classbasic__string__view}{string\_view}}(\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}()), s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}()), n);}
\DoxyCodeLine{803 \}}
\DoxyCodeLine{804 }
\DoxyCodeLine{805 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__integral}{is\_integral}} : std::is\_integral<T> \{\};}
\DoxyCodeLine{806 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__integral}{is\_integral}}<int128\_opt> : std::true\_type \{\};}
\DoxyCodeLine{807 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1is__integral}{is\_integral}}<uint128\_t> : std::true\_type \{\};}
\DoxyCodeLine{808 }
\DoxyCodeLine{809 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{810 \textcolor{keyword}{using }is\_signed =}
\DoxyCodeLine{811     std::integral\_constant<bool, std::numeric\_limits<T>::is\_signed ||}
\DoxyCodeLine{812                                      std::is\_same<T, int128\_opt>::value>;}
\DoxyCodeLine{813 }
\DoxyCodeLine{814 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{815 \textcolor{keyword}{using }is\_integer =}
\DoxyCodeLine{816     bool\_constant<is\_integral<T>::value \&\& !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{817                   !std::is\_same<T, char>::value \&\&}
\DoxyCodeLine{818                   !std::is\_same<T, wchar\_t>::value>;}
\DoxyCodeLine{819 }
\DoxyCodeLine{820 \textcolor{preprocessor}{\#ifndef FMT\_USE\_FLOAT}}
\DoxyCodeLine{821 \textcolor{preprocessor}{\#  define FMT\_USE\_FLOAT 1}}
\DoxyCodeLine{822 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{823 \textcolor{preprocessor}{\#ifndef FMT\_USE\_DOUBLE}}
\DoxyCodeLine{824 \textcolor{preprocessor}{\#  define FMT\_USE\_DOUBLE 1}}
\DoxyCodeLine{825 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{826 \textcolor{preprocessor}{\#ifndef FMT\_USE\_LONG\_DOUBLE}}
\DoxyCodeLine{827 \textcolor{preprocessor}{\#  define FMT\_USE\_LONG\_DOUBLE 1}}
\DoxyCodeLine{828 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{829 }
\DoxyCodeLine{830 \textcolor{preprocessor}{\#ifndef FMT\_USE\_FLOAT128}}
\DoxyCodeLine{831 \textcolor{preprocessor}{\#  ifdef \_\_clang\_\_}}
\DoxyCodeLine{832 \textcolor{comment}{// Clang emulates GCC, so it has to appear early.}}
\DoxyCodeLine{833 \textcolor{preprocessor}{\#    if FMT\_HAS\_INCLUDE(<quadmath.h>)}}
\DoxyCodeLine{834 \textcolor{preprocessor}{\#      define FMT\_USE\_FLOAT128 1}}
\DoxyCodeLine{835 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{836 \textcolor{preprocessor}{\#  elif defined(\_\_GNUC\_\_)}}
\DoxyCodeLine{837 \textcolor{comment}{// GNU C++:}}
\DoxyCodeLine{838 \textcolor{preprocessor}{\#    if defined(\_GLIBCXX\_USE\_FLOAT128) \&\& !defined(\_\_STRICT\_ANSI\_\_)}}
\DoxyCodeLine{839 \textcolor{preprocessor}{\#      define FMT\_USE\_FLOAT128 1}}
\DoxyCodeLine{840 \textcolor{preprocessor}{\#    endif}}
\DoxyCodeLine{841 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{842 \textcolor{preprocessor}{\#  ifndef FMT\_USE\_FLOAT128}}
\DoxyCodeLine{843 \textcolor{preprocessor}{\#    define FMT\_USE\_FLOAT128 0}}
\DoxyCodeLine{844 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{845 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{846 }
\DoxyCodeLine{847 \textcolor{preprocessor}{\#if FMT\_USE\_FLOAT128}}
\DoxyCodeLine{848 \textcolor{keyword}{using }float128 = \_\_float128;}
\DoxyCodeLine{849 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{850 \textcolor{keyword}{using }float128 = void;}
\DoxyCodeLine{851 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{852 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{using }is\_float128 = std::is\_same<T, float128>;}
\DoxyCodeLine{853 }
\DoxyCodeLine{854 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{855 \textcolor{keyword}{using }is\_floating\_point =}
\DoxyCodeLine{856     bool\_constant<std::is\_floating\_point<T>::value || is\_float128<T>::value>;}
\DoxyCodeLine{857 }
\DoxyCodeLine{858 template <typename T, bool = std::is\_floating\_point<T>::value>}
\DoxyCodeLine{859 \textcolor{keyword}{struct }is\_fast\_float : bool\_constant<std::numeric\_limits<T>::is\_iec559 \&\&}
\DoxyCodeLine{860                                      sizeof(T) <= sizeof(double)> \{\};}
\DoxyCodeLine{861 template <typename T> struct is\_fast\_float<T, false> : std::false\_type \{\};}
\DoxyCodeLine{862 }
\DoxyCodeLine{863 template <typename T>}
\DoxyCodeLine{864 using is\_double\_double = bool\_constant<std::numeric\_limits<T>::digits == 106>;}
\DoxyCodeLine{865 }
\DoxyCodeLine{866 \#ifndef FMT\_USE\_FULL\_CACHE\_DRAGONBOX}
\DoxyCodeLine{867 \#  define FMT\_USE\_FULL\_CACHE\_DRAGONBOX 0}
\DoxyCodeLine{868 \#endif}
\DoxyCodeLine{869 }
\DoxyCodeLine{870 template <typename T>}
\DoxyCodeLine{871 template <typename U>}
\DoxyCodeLine{872 void buffer<T>::append(const U* begin, const U* end) \{}
\DoxyCodeLine{873   while (begin != end) \{}
\DoxyCodeLine{874     auto count = to\_unsigned(end -\/ begin);}
\DoxyCodeLine{875     try\_reserve(size\_ + count);}
\DoxyCodeLine{876     auto free\_cap = capacity\_ -\/ size\_;}
\DoxyCodeLine{877     if (free\_cap < count) count = free\_cap;}
\DoxyCodeLine{878     std::uninitialized\_copy\_n(begin, count, ptr\_ + size\_);}
\DoxyCodeLine{879     size\_ += count;}
\DoxyCodeLine{880     begin += count;}
\DoxyCodeLine{881   \}}
\DoxyCodeLine{882 \}}
\DoxyCodeLine{883 }
\DoxyCodeLine{884 template <typename T, typename Enable = void>}
\DoxyCodeLine{885 struct is\_locale : std::false\_type \{\};}
\DoxyCodeLine{886 template <typename T>}
\DoxyCodeLine{887 struct is\_locale<T, void\_t<decltype(T::classic())>> : std::true\_type \{\};}
\DoxyCodeLine{888 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{889 }
\DoxyCodeLine{890 FMT\_BEGIN\_EXPORT}
\DoxyCodeLine{891 }
\DoxyCodeLine{892 \textcolor{comment}{// The number of characters to store in the basic\_memory\_buffer object itself}}
\DoxyCodeLine{893 \textcolor{comment}{// to avoid dynamic memory allocation.}}
\DoxyCodeLine{894 enum \{ inline\_buffer\_size = 500 \};}
\DoxyCodeLine{895 }
\DoxyCodeLine{917 template <typename T, size\_t SIZE = inline\_buffer\_size,}
\DoxyCodeLine{918           typename Allocator = std::allocator<T>>}
\DoxyCodeLine{919 class basic\_memory\_buffer final : public detail::buffer<T> \{}
\DoxyCodeLine{920  private:}
\DoxyCodeLine{921   T store\_[SIZE];}
\DoxyCodeLine{922 }
\DoxyCodeLine{923   \textcolor{comment}{// Don't inherit from Allocator avoid generating type\_info for it.}}
\DoxyCodeLine{924   FMT\_NO\_UNIQUE\_ADDRESS Allocator alloc\_;}
\DoxyCodeLine{925 }
\DoxyCodeLine{926   \textcolor{comment}{// Deallocate memory allocated by the buffer.}}
\DoxyCodeLine{927   FMT\_CONSTEXPR20 void deallocate() \{}
\DoxyCodeLine{928     T* data = this-\/>data();}
\DoxyCodeLine{929     if (data != store\_) alloc\_.deallocate(data, this-\/>capacity());}
\DoxyCodeLine{930   \}}
\DoxyCodeLine{931 }
\DoxyCodeLine{932  \textcolor{keyword}{protected}:}
\DoxyCodeLine{933   FMT\_CONSTEXPR20 void grow(size\_t size) override \{}
\DoxyCodeLine{934     detail::abort\_fuzzing\_if(size > 5000);}
\DoxyCodeLine{935     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_size = std::allocator\_traits<Allocator>::max\_size(alloc\_);}
\DoxyCodeLine{936     \textcolor{keywordtype}{size\_t} old\_capacity = this-\/>capacity();}
\DoxyCodeLine{937     \textcolor{keywordtype}{size\_t} new\_capacity = old\_capacity + old\_capacity / 2;}
\DoxyCodeLine{938     \textcolor{keywordflow}{if} (size > new\_capacity)}
\DoxyCodeLine{939       new\_capacity = size;}
\DoxyCodeLine{940     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (new\_capacity > max\_size)}
\DoxyCodeLine{941       new\_capacity = size > max\_size ? size : max\_size;}
\DoxyCodeLine{942     T* old\_data = this-\/>data();}
\DoxyCodeLine{943     T* new\_data =}
\DoxyCodeLine{944         std::allocator\_traits<Allocator>::allocate(alloc\_, new\_capacity);}
\DoxyCodeLine{945     \textcolor{comment}{// Suppress a bogus -\/Wstringop-\/overflow in gcc 13.1 (\#3481).}}
\DoxyCodeLine{946     detail::assume(this-\/>size() <= new\_capacity);}
\DoxyCodeLine{947     \textcolor{comment}{// The following code doesn't throw, so the raw pointer above doesn't leak.}}
\DoxyCodeLine{948     std::uninitialized\_copy\_n(old\_data, this-\/>size(), new\_data);}
\DoxyCodeLine{949     this-\/>set(new\_data, new\_capacity);}
\DoxyCodeLine{950     \textcolor{comment}{// deallocate must not throw according to the standard, but even if it does,}}
\DoxyCodeLine{951     \textcolor{comment}{// the buffer already uses the new storage and will deallocate it in}}
\DoxyCodeLine{952     \textcolor{comment}{// destructor.}}
\DoxyCodeLine{953     \textcolor{keywordflow}{if} (old\_data != store\_) alloc\_.deallocate(old\_data, old\_capacity);}
\DoxyCodeLine{954   \}}
\DoxyCodeLine{955 }
\DoxyCodeLine{956  \textcolor{keyword}{public}:}
\DoxyCodeLine{957   \textcolor{keyword}{using }value\_type = T;}
\DoxyCodeLine{958   \textcolor{keyword}{using }const\_reference = \textcolor{keyword}{const} T\&;}
\DoxyCodeLine{959 }
\DoxyCodeLine{960   FMT\_CONSTEXPR20 \textcolor{keyword}{explicit} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}(}
\DoxyCodeLine{961       \textcolor{keyword}{const} Allocator\& alloc = Allocator())}
\DoxyCodeLine{962       : alloc\_(alloc) \{}
\DoxyCodeLine{963     this-\/>set(store\_, SIZE);}
\DoxyCodeLine{964     \textcolor{keywordflow}{if} (detail::is\_constant\_evaluated()) detail::fill\_n(store\_, SIZE, T());}
\DoxyCodeLine{965   \}}
\DoxyCodeLine{966   FMT\_CONSTEXPR20 \mbox{\hyperlink{classbasic__memory__buffer}{\string~basic\_memory\_buffer}}() \{ deallocate(); \}}
\DoxyCodeLine{967 }
\DoxyCodeLine{968  \textcolor{keyword}{private}:}
\DoxyCodeLine{969   \textcolor{comment}{// Move data from other to this buffer.}}
\DoxyCodeLine{970   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} move(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\& other) \{}
\DoxyCodeLine{971     alloc\_ = std::move(other.alloc\_);}
\DoxyCodeLine{972     T* data = other.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}();}
\DoxyCodeLine{973     \textcolor{keywordtype}{size\_t} size = other.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}(), capacity = other.\mbox{\hyperlink{classdetail_1_1buffer_ac7ff14268d6b32d3d878291445ff4dd3}{capacity}}();}
\DoxyCodeLine{974     \textcolor{keywordflow}{if} (data == other.store\_) \{}
\DoxyCodeLine{975       this-\/>set(store\_, capacity);}
\DoxyCodeLine{976       detail::copy\_str<T>(other.store\_, other.store\_ + size, store\_);}
\DoxyCodeLine{977     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{978       this-\/>set(data, capacity);}
\DoxyCodeLine{979       \textcolor{comment}{// Set pointer to the inline array so that delete is not called}}
\DoxyCodeLine{980       \textcolor{comment}{// when deallocating.}}
\DoxyCodeLine{981       other.\mbox{\hyperlink{classdetail_1_1buffer_a5c82aec716b07079ac88194eb9aa7feb}{set}}(other.store\_, 0);}
\DoxyCodeLine{982       other.\mbox{\hyperlink{classdetail_1_1buffer_a8174757a0d86698229670044730dc59b}{clear}}();}
\DoxyCodeLine{983     \}}
\DoxyCodeLine{984     this-\/>resize(size);}
\DoxyCodeLine{985   \}}
\DoxyCodeLine{986 }
\DoxyCodeLine{987  \textcolor{keyword}{public}:}
\DoxyCodeLine{994   FMT\_CONSTEXPR20 \mbox{\hyperlink{classbasic__memory__buffer_ade18cff12fc914085665a07af2e8fb7b}{basic\_memory\_buffer}}(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\&\& other) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{995     move(other);}
\DoxyCodeLine{996   \}}
\DoxyCodeLine{997 }
\DoxyCodeLine{1003   \textcolor{keyword}{auto} \mbox{\hyperlink{classbasic__memory__buffer_a20c8cea076154a579ab0a04afb6c1f84}{operator=}}(\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\&\& other) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}\& \{}
\DoxyCodeLine{1004     FMT\_ASSERT(\textcolor{keyword}{this} != \&other, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1005     deallocate();}
\DoxyCodeLine{1006     move(other);}
\DoxyCodeLine{1007     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{1008   \}}
\DoxyCodeLine{1009 }
\DoxyCodeLine{1010   \textcolor{comment}{// Returns a copy of the allocator associated with this buffer.}}
\DoxyCodeLine{1011   \textcolor{keyword}{auto} get\_allocator() const -\/> Allocator \{ \textcolor{keywordflow}{return} alloc\_; \}}
\DoxyCodeLine{1012 }
\DoxyCodeLine{1017   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(\textcolor{keywordtype}{size\_t} count) \{ this-\/>try\_resize(count); \}}
\DoxyCodeLine{1018 }
\DoxyCodeLine{1020   \textcolor{keywordtype}{void} \mbox{\hyperlink{classbasic__memory__buffer_a27f096451ed4e6738d3a33161fda3e90}{reserve}}(\textcolor{keywordtype}{size\_t} new\_capacity) \{ this-\/>try\_reserve(new\_capacity); \}}
\DoxyCodeLine{1021 }
\DoxyCodeLine{1022   \textcolor{comment}{// Directly append data into the buffer}}
\DoxyCodeLine{1023   \textcolor{keyword}{using }\mbox{\hyperlink{classdetail_1_1buffer}{detail::buffer}}<T>::append;}
\DoxyCodeLine{1024   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ContiguousRange>}
\DoxyCodeLine{1025   \textcolor{keywordtype}{void} append(\textcolor{keyword}{const} ContiguousRange\& range) \{}
\DoxyCodeLine{1026     append(range.data(), range.data() + range.size());}
\DoxyCodeLine{1027   \}}
\DoxyCodeLine{1028 \};}
\DoxyCodeLine{1029 }
\DoxyCodeLine{1030 \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<char>}};}
\DoxyCodeLine{1031 }
\DoxyCodeLine{1032 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keywordtype}{size\_t} SIZE, \textcolor{keyword}{typename} Allocator>}
\DoxyCodeLine{1033 \textcolor{keyword}{struct }\mbox{\hyperlink{structis__contiguous}{is\_contiguous}}<\mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer}}<T, SIZE, Allocator>> : std::true\_type \{}
\DoxyCodeLine{1034 \};}
\DoxyCodeLine{1035 }
\DoxyCodeLine{1036 FMT\_END\_EXPORT}
\DoxyCodeLine{1037 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{1038 FMT\_API \textcolor{keywordtype}{bool} write\_console(std::FILE* f, \mbox{\hyperlink{classbasic__string__view}{string\_view}} text);}
\DoxyCodeLine{1039 FMT\_API \textcolor{keywordtype}{void} print(std::FILE*, \mbox{\hyperlink{classbasic__string__view}{string\_view}});}
\DoxyCodeLine{1040 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{1041 FMT\_BEGIN\_EXPORT}
\DoxyCodeLine{1042 }
\DoxyCodeLine{1043 \textcolor{comment}{// Suppress a misleading warning in older versions of clang.}}
\DoxyCodeLine{1044 \textcolor{preprocessor}{\#if FMT\_CLANG\_VERSION}}
\DoxyCodeLine{1045 \textcolor{preprocessor}{\#  pragma clang diagnostic ignored "{}-\/Wweak-\/vtables"{}}}
\DoxyCodeLine{1046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1047 }
\DoxyCodeLine{1049 \textcolor{keyword}{class }FMT\_VISIBILITY("{}default"{}) format\_error : \textcolor{keyword}{public} std::runtime\_error \{}
\DoxyCodeLine{1050  \textcolor{keyword}{public}:}
\DoxyCodeLine{1051   \textcolor{keyword}{using }std::runtime\_error::runtime\_error;}
\DoxyCodeLine{1052 \};}
\DoxyCodeLine{1053 }
\DoxyCodeLine{1054 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacedetail__exported}{detail\_exported}} \{}
\DoxyCodeLine{1055 \textcolor{preprocessor}{\#if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{1056 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N> \textcolor{keyword}{struct }fixed\_string \{}
\DoxyCodeLine{1057   \textcolor{keyword}{constexpr} fixed\_string(\textcolor{keyword}{const} Char (\&str)[N]) \{}
\DoxyCodeLine{1058     detail::copy\_str<Char, const Char*, Char*>(\textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }Char*\textcolor{keyword}{>}(str),}
\DoxyCodeLine{1059                                                str + N, data);}
\DoxyCodeLine{1060   \}}
\DoxyCodeLine{1061   Char data[N] = \{\};}
\DoxyCodeLine{1062 \};}
\DoxyCodeLine{1063 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1064 }
\DoxyCodeLine{1065 \textcolor{comment}{// Converts a compile-\/time string to basic\_string\_view.}}
\DoxyCodeLine{1066 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{1067 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_string\_to\_view(\textcolor{keyword}{const} Char (\&s)[N])}
\DoxyCodeLine{1068     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{1069   \textcolor{comment}{// Remove trailing NUL character if needed. Won't be present if this is used}}
\DoxyCodeLine{1070   \textcolor{comment}{// with a raw character array (i.e. not defined as a string).}}
\DoxyCodeLine{1071   \textcolor{keywordflow}{return} \{s, N -\/ (std::char\_traits<Char>::to\_int\_type(s[N -\/ 1]) == 0 ? 1 : 0)\};}
\DoxyCodeLine{1072 \}}
\DoxyCodeLine{1073 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1074 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} compile\_string\_to\_view(\mbox{\hyperlink{structdetail_1_1std__string__view}{detail::std\_string\_view<Char>}} s)}
\DoxyCodeLine{1075     -\/> \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \{}
\DoxyCodeLine{1076   \textcolor{keywordflow}{return} \{s.data(), s.size()\};}
\DoxyCodeLine{1077 \}}
\DoxyCodeLine{1078 \}  \textcolor{comment}{// namespace detail\_exported}}
\DoxyCodeLine{1079 }
\DoxyCodeLine{1080 \textcolor{keyword}{class }\mbox{\hyperlink{classloc__value}{loc\_value}} \{}
\DoxyCodeLine{1081  \textcolor{keyword}{private}:}
\DoxyCodeLine{1082   \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg<format\_context>}} value\_;}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084  \textcolor{keyword}{public}:}
\DoxyCodeLine{1085   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!detail::is\_\textcolor{keywordtype}{float}128<T>::value)>}
\DoxyCodeLine{1086   \mbox{\hyperlink{classloc__value}{loc\_value}}(T value) : value\_(detail::make\_arg<format\_context>(value)) \{\}}
\DoxyCodeLine{1087 }
\DoxyCodeLine{1088   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(detail::is\_\textcolor{keywordtype}{float}128<T>::value)>}
\DoxyCodeLine{1089   \mbox{\hyperlink{classloc__value}{loc\_value}}(T) \{\}}
\DoxyCodeLine{1090 }
\DoxyCodeLine{1091   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Visitor> \textcolor{keyword}{auto} visit(Visitor\&\& vis) -\/> \textcolor{keyword}{decltype}(vis(0)) \{}
\DoxyCodeLine{1092     \textcolor{keywordflow}{return} visit\_format\_arg(vis, value\_);}
\DoxyCodeLine{1093   \}}
\DoxyCodeLine{1094 \};}
\DoxyCodeLine{1095 }
\DoxyCodeLine{1096 \textcolor{comment}{// A locale facet that formats values in UTF-\/8.}}
\DoxyCodeLine{1097 \textcolor{comment}{// It is parameterized on the locale to avoid the heavy <locale> include.}}
\DoxyCodeLine{1098 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale> \textcolor{keyword}{class }\mbox{\hyperlink{classformat__facet}{format\_facet}} : \textcolor{keyword}{public} Locale::facet \{}
\DoxyCodeLine{1099  \textcolor{keyword}{private}:}
\DoxyCodeLine{1100   std::string separator\_;}
\DoxyCodeLine{1101   std::string grouping\_;}
\DoxyCodeLine{1102   std::string decimal\_point\_;}
\DoxyCodeLine{1103 }
\DoxyCodeLine{1104  \textcolor{keyword}{protected}:}
\DoxyCodeLine{1105   \textcolor{keyword}{virtual} \textcolor{keyword}{auto} do\_put(\mbox{\hyperlink{classappender}{appender}} out, \mbox{\hyperlink{classloc__value}{loc\_value}} val,}
\DoxyCodeLine{1106                       \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<>}}\& specs) \textcolor{keyword}{const} -\/> bool;}
\DoxyCodeLine{1107 }
\DoxyCodeLine{1108  \textcolor{keyword}{public}:}
\DoxyCodeLine{1109   \textcolor{keyword}{static} FMT\_API \textcolor{keyword}{typename} Locale::id id;}
\DoxyCodeLine{1110 }
\DoxyCodeLine{1111   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__facet}{format\_facet}}(Locale\& loc);}
\DoxyCodeLine{1112   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__facet}{format\_facet}}(\mbox{\hyperlink{classbasic__string__view}{string\_view}} sep = \textcolor{stringliteral}{"{}"{}},}
\DoxyCodeLine{1113                         std::initializer\_list<unsigned char> g = \{3\},}
\DoxyCodeLine{1114                         std::string decimal\_point = \textcolor{stringliteral}{"{}."{}})}
\DoxyCodeLine{1115       : separator\_(sep.data(), sep.size()),}
\DoxyCodeLine{1116         grouping\_(g.begin(), g.end()),}
\DoxyCodeLine{1117         decimal\_point\_(decimal\_point) \{\}}
\DoxyCodeLine{1118 }
\DoxyCodeLine{1119   \textcolor{keyword}{auto} put(\mbox{\hyperlink{classappender}{appender}} out, \mbox{\hyperlink{classloc__value}{loc\_value}} val, \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<>}}\& specs) \textcolor{keyword}{const}}
\DoxyCodeLine{1120       -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1121     \textcolor{keywordflow}{return} do\_put(out, val, specs);}
\DoxyCodeLine{1122   \}}
\DoxyCodeLine{1123 \};}
\DoxyCodeLine{1124 }
\DoxyCodeLine{1125 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{1126 }
\DoxyCodeLine{1127 \textcolor{comment}{// Returns true if value is negative, false otherwise.}}
\DoxyCodeLine{1128 \textcolor{comment}{// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.}}
\DoxyCodeLine{1129 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{signed}<T>::value)>}
\DoxyCodeLine{1130 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_negative(T value) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1131   \textcolor{keywordflow}{return} value < 0;}
\DoxyCodeLine{1132 \}}
\DoxyCodeLine{1133 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{signed}<T>::value)>}
\DoxyCodeLine{1134 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} is\_negative(T) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1135   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1136 \}}
\DoxyCodeLine{1137 }
\DoxyCodeLine{1138 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1139 FMT\_CONSTEXPR \textcolor{keyword}{auto} is\_supported\_floating\_point(T) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1140   \textcolor{keywordflow}{if} (std::is\_same<T, float>()) \textcolor{keywordflow}{return} FMT\_USE\_FLOAT;}
\DoxyCodeLine{1141   \textcolor{keywordflow}{if} (std::is\_same<T, double>()) \textcolor{keywordflow}{return} FMT\_USE\_DOUBLE;}
\DoxyCodeLine{1142   \textcolor{keywordflow}{if} (std::is\_same<T, long double>()) \textcolor{keywordflow}{return} FMT\_USE\_LONG\_DOUBLE;}
\DoxyCodeLine{1143   \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1144 \}}
\DoxyCodeLine{1145 }
\DoxyCodeLine{1146 \textcolor{comment}{// Smallest of uint32\_t, uint64\_t, uint128\_t that is large enough to}}
\DoxyCodeLine{1147 \textcolor{comment}{// represent all values of an integral type T.}}
\DoxyCodeLine{1148 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1149 \textcolor{keyword}{using }uint32\_or\_64\_or\_128\_t =}
\DoxyCodeLine{1150     conditional\_t<num\_bits<T>() <= 32 \&\& !FMT\_REDUCE\_INT\_INSTANTIATIONS,}
\DoxyCodeLine{1151                   uint32\_t,}
\DoxyCodeLine{1152                   conditional\_t<num\_bits<T>() <= 64, uint64\_t, uint128\_t>>;}
\DoxyCodeLine{1153 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1154 \textcolor{keyword}{using }uint64\_or\_128\_t = conditional\_t<num\_bits<T>() <= 64, uint64\_t, uint128\_t>;}
\DoxyCodeLine{1155 }
\DoxyCodeLine{1156 \textcolor{preprocessor}{\#define FMT\_POWERS\_OF\_10(factor)                                             \(\backslash\)}}
\DoxyCodeLine{1157 \textcolor{preprocessor}{  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \(\backslash\)}}
\DoxyCodeLine{1158 \textcolor{preprocessor}{      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \(\backslash\)}}
\DoxyCodeLine{1159 \textcolor{preprocessor}{      (factor)*1000000000}}
\DoxyCodeLine{1160 }
\DoxyCodeLine{1161 \textcolor{comment}{// Converts value in the range [0, 100) to a string.}}
\DoxyCodeLine{1162 \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{char}* digits2(\textcolor{keywordtype}{size\_t} value) \{}
\DoxyCodeLine{1163   \textcolor{comment}{// GCC generates slightly better code when value is pointer-\/size.}}
\DoxyCodeLine{1164   \textcolor{keywordflow}{return} \&\textcolor{stringliteral}{"{}0001020304050607080910111213141516171819"{}}}
\DoxyCodeLine{1165          \textcolor{stringliteral}{"{}2021222324252627282930313233343536373839"{}}}
\DoxyCodeLine{1166          \textcolor{stringliteral}{"{}4041424344454647484950515253545556575859"{}}}
\DoxyCodeLine{1167          \textcolor{stringliteral}{"{}6061626364656667686970717273747576777879"{}}}
\DoxyCodeLine{1168          \textcolor{stringliteral}{"{}8081828384858687888990919293949596979899"{}}[value * 2];}
\DoxyCodeLine{1169 \}}
\DoxyCodeLine{1170 }
\DoxyCodeLine{1171 \textcolor{comment}{// Sign is a template parameter to workaround a bug in gcc 4.8.}}
\DoxyCodeLine{1172 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} Sign> \textcolor{keyword}{constexpr} Char sign(Sign s) \{}
\DoxyCodeLine{1173 \textcolor{preprocessor}{\#if !FMT\_GCC\_VERSION || FMT\_GCC\_VERSION >= 604}}
\DoxyCodeLine{1174   \textcolor{keyword}{static\_assert}(std::is\_same<Sign, sign\_t>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1175 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1176   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{stringliteral}{"{}\(\backslash\)0-\/+ "{}}[s]);}
\DoxyCodeLine{1177 \}}
\DoxyCodeLine{1178 }
\DoxyCodeLine{1179 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_CONSTEXPR \textcolor{keyword}{auto} count\_digits\_fallback(T n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1180   \textcolor{keywordtype}{int} count = 1;}
\DoxyCodeLine{1181   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{1182     \textcolor{comment}{// Integer division is slow so do it for a group of four digits instead}}
\DoxyCodeLine{1183     \textcolor{comment}{// of for every digit. The idea comes from the talk by Alexandrescu}}
\DoxyCodeLine{1184     \textcolor{comment}{// "{}Three Optimization Tips for C++"{}. See speed-\/test for a comparison.}}
\DoxyCodeLine{1185     \textcolor{keywordflow}{if} (n < 10) \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{1186     \textcolor{keywordflow}{if} (n < 100) \textcolor{keywordflow}{return} count + 1;}
\DoxyCodeLine{1187     \textcolor{keywordflow}{if} (n < 1000) \textcolor{keywordflow}{return} count + 2;}
\DoxyCodeLine{1188     \textcolor{keywordflow}{if} (n < 10000) \textcolor{keywordflow}{return} count + 3;}
\DoxyCodeLine{1189     n /= 10000u;}
\DoxyCodeLine{1190     count += 4;}
\DoxyCodeLine{1191   \}}
\DoxyCodeLine{1192 \}}
\DoxyCodeLine{1193 \textcolor{preprocessor}{\#if FMT\_USE\_INT128}}
\DoxyCodeLine{1194 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} count\_digits(uint128\_opt n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1195   \textcolor{keywordflow}{return} count\_digits\_fallback(n);}
\DoxyCodeLine{1196 \}}
\DoxyCodeLine{1197 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1198 }
\DoxyCodeLine{1199 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZLL}}
\DoxyCodeLine{1200 \textcolor{comment}{// It is a separate function rather than a part of count\_digits to workaround}}
\DoxyCodeLine{1201 \textcolor{comment}{// the lack of static constexpr in constexpr functions.}}
\DoxyCodeLine{1202 \textcolor{keyword}{inline} \textcolor{keyword}{auto} do\_count\_digits(uint64\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1203   \textcolor{comment}{// This has comparable performance to the version by Kendall Willets}}
\DoxyCodeLine{1204   \textcolor{comment}{// (https://github.com/fmtlib/format-\/benchmark/blob/master/digits10)}}
\DoxyCodeLine{1205   \textcolor{comment}{// but uses smaller tables.}}
\DoxyCodeLine{1206   \textcolor{comment}{// Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) -\/ 1)).}}
\DoxyCodeLine{1207   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uint8\_t bsr2log10[] = \{}
\DoxyCodeLine{1208       1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,}
\DoxyCodeLine{1209       6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,}
\DoxyCodeLine{1210       10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,}
\DoxyCodeLine{1211       15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20\};}
\DoxyCodeLine{1212   \textcolor{keyword}{auto} t = bsr2log10[FMT\_BUILTIN\_CLZLL(n | 1) \string^ 63];}
\DoxyCodeLine{1213   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} uint64\_t zero\_or\_powers\_of\_10[] = \{}
\DoxyCodeLine{1214       0, 0, FMT\_POWERS\_OF\_10(1U), FMT\_POWERS\_OF\_10(1000000000ULL),}
\DoxyCodeLine{1215       10000000000000000000ULL\};}
\DoxyCodeLine{1216   \textcolor{keywordflow}{return} t -\/ (n < zero\_or\_powers\_of\_10[t]);}
\DoxyCodeLine{1217 \}}
\DoxyCodeLine{1218 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{comment}{// Returns the number of decimal digits in n. Leading zeros are not counted}}
\DoxyCodeLine{1221 \textcolor{comment}{// except for n == 0 in which case count\_digits returns 1.}}
\DoxyCodeLine{1222 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keyword}{auto} count\_digits(uint64\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1223 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZLL}}
\DoxyCodeLine{1224   \textcolor{keywordflow}{if} (!is\_constant\_evaluated()) \{}
\DoxyCodeLine{1225     \textcolor{keywordflow}{return} do\_count\_digits(n);}
\DoxyCodeLine{1226   \}}
\DoxyCodeLine{1227 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1228   \textcolor{keywordflow}{return} count\_digits\_fallback(n);}
\DoxyCodeLine{1229 \}}
\DoxyCodeLine{1230 }
\DoxyCodeLine{1231 \textcolor{comment}{// Counts the number of digits in n. BITS = log2(radix).}}
\DoxyCodeLine{1232 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} BITS, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1233 FMT\_CONSTEXPR \textcolor{keyword}{auto} count\_digits(UInt n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1234 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{1235   \textcolor{keywordflow}{if} (!is\_constant\_evaluated() \&\& num\_bits<UInt>() == 32)}
\DoxyCodeLine{1236     \textcolor{keywordflow}{return} (FMT\_BUILTIN\_CLZ(\textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(n) | 1) \string^ 31) / BITS + 1;}
\DoxyCodeLine{1237 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1238   \textcolor{comment}{// Lambda avoids unreachable code warnings from NVHPC.}}
\DoxyCodeLine{1239   \textcolor{keywordflow}{return} [](UInt m) \{}
\DoxyCodeLine{1240     \textcolor{keywordtype}{int} num\_digits = 0;}
\DoxyCodeLine{1241     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1242       ++num\_digits;}
\DoxyCodeLine{1243     \} \textcolor{keywordflow}{while} ((m >>= BITS) != 0);}
\DoxyCodeLine{1244     \textcolor{keywordflow}{return} num\_digits;}
\DoxyCodeLine{1245   \}(n);}
\DoxyCodeLine{1246 \}}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{1249 \textcolor{comment}{// It is a separate function rather than a part of count\_digits to workaround}}
\DoxyCodeLine{1250 \textcolor{comment}{// the lack of static constexpr in constexpr functions.}}
\DoxyCodeLine{1251 FMT\_INLINE \textcolor{keyword}{auto} do\_count\_digits(uint32\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1252 \textcolor{comment}{// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.}}
\DoxyCodeLine{1253 \textcolor{comment}{// This increments the upper 32 bits (log10(T) -\/ 1) when >= T is added.}}
\DoxyCodeLine{1254 \textcolor{preprocessor}{\#  define FMT\_INC(T) (((sizeof(\#T) -\/ 1ull) << 32) -\/ T)}}
\DoxyCodeLine{1255   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uint64\_t table[] = \{}
\DoxyCodeLine{1256       FMT\_INC(0),          FMT\_INC(0),          FMT\_INC(0),           \textcolor{comment}{// 8}}
\DoxyCodeLine{1257       FMT\_INC(10),         FMT\_INC(10),         FMT\_INC(10),          \textcolor{comment}{// 64}}
\DoxyCodeLine{1258       FMT\_INC(100),        FMT\_INC(100),        FMT\_INC(100),         \textcolor{comment}{// 512}}
\DoxyCodeLine{1259       FMT\_INC(1000),       FMT\_INC(1000),       FMT\_INC(1000),        \textcolor{comment}{// 4096}}
\DoxyCodeLine{1260       FMT\_INC(10000),      FMT\_INC(10000),      FMT\_INC(10000),       \textcolor{comment}{// 32k}}
\DoxyCodeLine{1261       FMT\_INC(100000),     FMT\_INC(100000),     FMT\_INC(100000),      \textcolor{comment}{// 256k}}
\DoxyCodeLine{1262       FMT\_INC(1000000),    FMT\_INC(1000000),    FMT\_INC(1000000),     \textcolor{comment}{// 2048k}}
\DoxyCodeLine{1263       FMT\_INC(10000000),   FMT\_INC(10000000),   FMT\_INC(10000000),    \textcolor{comment}{// 16M}}
\DoxyCodeLine{1264       FMT\_INC(100000000),  FMT\_INC(100000000),  FMT\_INC(100000000),   \textcolor{comment}{// 128M}}
\DoxyCodeLine{1265       FMT\_INC(1000000000), FMT\_INC(1000000000), FMT\_INC(1000000000),  \textcolor{comment}{// 1024M}}
\DoxyCodeLine{1266       FMT\_INC(1000000000), FMT\_INC(1000000000)                        \textcolor{comment}{// 4B}}
\DoxyCodeLine{1267   \};}
\DoxyCodeLine{1268   \textcolor{keyword}{auto} inc = table[FMT\_BUILTIN\_CLZ(n | 1) \string^ 31];}
\DoxyCodeLine{1269   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((n + inc) >> 32);}
\DoxyCodeLine{1270 \}}
\DoxyCodeLine{1271 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1272 }
\DoxyCodeLine{1273 \textcolor{comment}{// Optional version of count\_digits for better performance on 32-\/bit platforms.}}
\DoxyCodeLine{1274 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keyword}{auto} count\_digits(uint32\_t n) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1275 \textcolor{preprocessor}{\#ifdef FMT\_BUILTIN\_CLZ}}
\DoxyCodeLine{1276   \textcolor{keywordflow}{if} (!is\_constant\_evaluated()) \{}
\DoxyCodeLine{1277     \textcolor{keywordflow}{return} do\_count\_digits(n);}
\DoxyCodeLine{1278   \}}
\DoxyCodeLine{1279 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1280   \textcolor{keywordflow}{return} count\_digits\_fallback(n);}
\DoxyCodeLine{1281 \}}
\DoxyCodeLine{1282 }
\DoxyCodeLine{1283 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} digits10() noexcept -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1284   \textcolor{keywordflow}{return} std::numeric\_limits<Int>::digits10;}
\DoxyCodeLine{1285 \}}
\DoxyCodeLine{1286 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} digits10<int128\_opt>() noexcept -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 38; \}}
\DoxyCodeLine{1287 \textcolor{keyword}{template} <> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} digits10<uint128\_t>() noexcept -\/> \textcolor{keywordtype}{int} \{ \textcolor{keywordflow}{return} 38; \}}
\DoxyCodeLine{1288 }
\DoxyCodeLine{1289 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1thousands__sep__result}{thousands\_sep\_result}} \{}
\DoxyCodeLine{1290   std::string grouping;}
\DoxyCodeLine{1291   Char thousands\_sep;}
\DoxyCodeLine{1292 \};}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1295 FMT\_API \textcolor{keyword}{auto} thousands\_sep\_impl(\mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} loc) -\/> \mbox{\hyperlink{structdetail_1_1thousands__sep__result}{thousands\_sep\_result<Char>}};}
\DoxyCodeLine{1296 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1297 \textcolor{keyword}{inline} \textcolor{keyword}{auto} thousands\_sep(\mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} loc) -\/> \mbox{\hyperlink{structdetail_1_1thousands__sep__result}{thousands\_sep\_result<Char>}} \{}
\DoxyCodeLine{1298   \textcolor{keyword}{auto} result = thousands\_sep\_impl<char>(loc);}
\DoxyCodeLine{1299   \textcolor{keywordflow}{return} \{result.grouping, Char(result.thousands\_sep)\};}
\DoxyCodeLine{1300 \}}
\DoxyCodeLine{1301 \textcolor{keyword}{template} <>}
\DoxyCodeLine{1302 \textcolor{keyword}{inline} \textcolor{keyword}{auto} thousands\_sep(locale\_ref loc) -\/> thousands\_sep\_result<wchar\_t> \{}
\DoxyCodeLine{1303   \textcolor{keywordflow}{return} thousands\_sep\_impl<wchar\_t>(loc);}
\DoxyCodeLine{1304 \}}
\DoxyCodeLine{1305 }
\DoxyCodeLine{1306 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1307 FMT\_API \textcolor{keyword}{auto} decimal\_point\_impl(locale\_ref loc) -\/> Char;}
\DoxyCodeLine{1308 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{inline} \textcolor{keyword}{auto} decimal\_point(locale\_ref loc) -\/> Char \{}
\DoxyCodeLine{1309   \textcolor{keywordflow}{return} Char(decimal\_point\_impl<char>(loc));}
\DoxyCodeLine{1310 \}}
\DoxyCodeLine{1311 \textcolor{keyword}{template} <> \textcolor{keyword}{inline} \textcolor{keyword}{auto} decimal\_point(locale\_ref loc) -\/> \textcolor{keywordtype}{wchar\_t} \{}
\DoxyCodeLine{1312   \textcolor{keywordflow}{return} decimal\_point\_impl<wchar\_t>(loc);}
\DoxyCodeLine{1313 \}}
\DoxyCodeLine{1314 }
\DoxyCodeLine{1315 \textcolor{comment}{// Compares two characters for equality.}}
\DoxyCodeLine{1316 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{auto} equal2(\textcolor{keyword}{const} Char* lhs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1317   \textcolor{keywordflow}{return} lhs[0] == Char(rhs[0]) \&\& lhs[1] == Char(rhs[1]);}
\DoxyCodeLine{1318 \}}
\DoxyCodeLine{1319 \textcolor{keyword}{inline} \textcolor{keyword}{auto} equal2(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* lhs, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* rhs) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1320   \textcolor{keywordflow}{return} memcmp(lhs, rhs, 2) == 0;}
\DoxyCodeLine{1321 \}}
\DoxyCodeLine{1322 }
\DoxyCodeLine{1323 \textcolor{comment}{// Copies two characters from src to dst.}}
\DoxyCodeLine{1324 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1325 FMT\_CONSTEXPR20 FMT\_INLINE \textcolor{keywordtype}{void} copy2(Char* dst, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* src) \{}
\DoxyCodeLine{1326   \textcolor{keywordflow}{if} (!is\_constant\_evaluated() \&\& \textcolor{keyword}{sizeof}(Char) == \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})) \{}
\DoxyCodeLine{1327     memcpy(dst, src, 2);}
\DoxyCodeLine{1328     \textcolor{keywordflow}{return};}
\DoxyCodeLine{1329   \}}
\DoxyCodeLine{1330   *dst++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(*src++);}
\DoxyCodeLine{1331   *dst = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(*src);}
\DoxyCodeLine{1332 \}}
\DoxyCodeLine{1333 }
\DoxyCodeLine{1334 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Iterator> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1format__decimal__result}{format\_decimal\_result}} \{}
\DoxyCodeLine{1335   Iterator begin;}
\DoxyCodeLine{1336   Iterator end;}
\DoxyCodeLine{1337 \};}
\DoxyCodeLine{1338 }
\DoxyCodeLine{1339 \textcolor{comment}{// Formats a decimal unsigned integer value writing into out pointing to a}}
\DoxyCodeLine{1340 \textcolor{comment}{// buffer of specified size. The caller must ensure that the buffer is large}}
\DoxyCodeLine{1341 \textcolor{comment}{// enough.}}
\DoxyCodeLine{1342 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1343 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} format\_decimal(Char* out, UInt \mbox{\hyperlink{classdetail_1_1value}{value}}, \textcolor{keywordtype}{int} size)}
\DoxyCodeLine{1344     -\/> \mbox{\hyperlink{structdetail_1_1format__decimal__result}{format\_decimal\_result<Char*>}} \{}
\DoxyCodeLine{1345   FMT\_ASSERT(size >= count\_digits(\mbox{\hyperlink{classdetail_1_1value}{value}}), \textcolor{stringliteral}{"{}invalid digit count"{}});}
\DoxyCodeLine{1346   out += size;}
\DoxyCodeLine{1347   Char* end = out;}
\DoxyCodeLine{1348   \textcolor{keywordflow}{while} (\mbox{\hyperlink{classdetail_1_1value}{value}} >= 100) \{}
\DoxyCodeLine{1349     \textcolor{comment}{// Integer division is slow so do it for a group of two digits instead}}
\DoxyCodeLine{1350     \textcolor{comment}{// of for every digit. The idea comes from the talk by Alexandrescu}}
\DoxyCodeLine{1351     \textcolor{comment}{// "{}Three Optimization Tips for C++"{}. See speed-\/test for a comparison.}}
\DoxyCodeLine{1352     out -\/= 2;}
\DoxyCodeLine{1353     copy2(out, digits2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(\mbox{\hyperlink{classdetail_1_1value}{value}} \% 100)));}
\DoxyCodeLine{1354     \mbox{\hyperlink{classdetail_1_1value}{value}} /= 100;}
\DoxyCodeLine{1355   \}}
\DoxyCodeLine{1356   \textcolor{keywordflow}{if} (value < 10) \{}
\DoxyCodeLine{1357     *-\/-\/out = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + value);}
\DoxyCodeLine{1358     \textcolor{keywordflow}{return} \{out, end\};}
\DoxyCodeLine{1359   \}}
\DoxyCodeLine{1360   out -\/= 2;}
\DoxyCodeLine{1361   copy2(out, digits2(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(value)));}
\DoxyCodeLine{1362   \textcolor{keywordflow}{return} \{out, end\};}
\DoxyCodeLine{1363 \}}
\DoxyCodeLine{1364 }
\DoxyCodeLine{1365 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Iterator,}
\DoxyCodeLine{1366           FMT\_ENABLE\_IF(!std::is\_pointer<remove\_cvref\_t<Iterator>>::value)>}
\DoxyCodeLine{1367 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keyword}{auto} format\_decimal(Iterator out, UInt value, \textcolor{keywordtype}{int} size)}
\DoxyCodeLine{1368     -\/> format\_decimal\_result<Iterator> \{}
\DoxyCodeLine{1369   \textcolor{comment}{// Buffer is large enough to hold all digits (digits10 + 1).}}
\DoxyCodeLine{1370   Char buffer[digits10<UInt>() + 1] = \{\};}
\DoxyCodeLine{1371   \textcolor{keyword}{auto} end = format\_decimal(buffer, value, size).end;}
\DoxyCodeLine{1372   \textcolor{keywordflow}{return} \{out, detail::copy\_str\_noinline<Char>(buffer, end, out)\};}
\DoxyCodeLine{1373 \}}
\DoxyCodeLine{1374 }
\DoxyCodeLine{1375 \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} BASE\_BITS, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1376 FMT\_CONSTEXPR \textcolor{keyword}{auto} format\_uint(Char* buffer, UInt value, \textcolor{keywordtype}{int} num\_digits,}
\DoxyCodeLine{1377                                \textcolor{keywordtype}{bool} upper = \textcolor{keyword}{false}) -\/> Char* \{}
\DoxyCodeLine{1378   buffer += num\_digits;}
\DoxyCodeLine{1379   Char* end = buffer;}
\DoxyCodeLine{1380   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1381     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* digits = upper ? \textcolor{stringliteral}{"{}0123456789ABCDEF"{}} : \textcolor{stringliteral}{"{}0123456789abcdef"{}};}
\DoxyCodeLine{1382     \textcolor{keywordtype}{unsigned} digit = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(value \& ((1 << BASE\_BITS) -\/ 1));}
\DoxyCodeLine{1383     *-\/-\/buffer = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(BASE\_BITS < 4 ? static\_cast<char>(\textcolor{charliteral}{'0'} + digit)}
\DoxyCodeLine{1384                                                 : digits[digit]);}
\DoxyCodeLine{1385   \} \textcolor{keywordflow}{while} ((value >>= BASE\_BITS) != 0);}
\DoxyCodeLine{1386   \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{1387 \}}
\DoxyCodeLine{1388 }
\DoxyCodeLine{1389 \textcolor{keyword}{template} <\textcolor{keywordtype}{unsigned} BASE\_BITS, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} It, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{1390 \textcolor{keyword}{inline} \textcolor{keyword}{auto} format\_uint(It out, UInt value, \textcolor{keywordtype}{int} num\_digits, \textcolor{keywordtype}{bool} upper = \textcolor{keyword}{false})}
\DoxyCodeLine{1391     -\/> It \{}
\DoxyCodeLine{1392   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} ptr = to\_pointer<Char>(out, to\_unsigned(num\_digits))) \{}
\DoxyCodeLine{1393     format\_uint<BASE\_BITS>(ptr, value, num\_digits, upper);}
\DoxyCodeLine{1394     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1395   \}}
\DoxyCodeLine{1396   \textcolor{comment}{// Buffer should be large enough to hold all digits (digits / BASE\_BITS + 1).}}
\DoxyCodeLine{1397   \textcolor{keywordtype}{char} buffer[num\_bits<UInt>() / BASE\_BITS + 1];}
\DoxyCodeLine{1398   format\_uint<BASE\_BITS>(buffer, value, num\_digits, upper);}
\DoxyCodeLine{1399   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(buffer, buffer + num\_digits, out);}
\DoxyCodeLine{1400 \}}
\DoxyCodeLine{1401 }
\DoxyCodeLine{1402 \textcolor{comment}{// A converter from UTF-\/8 to UTF-\/16.}}
\DoxyCodeLine{1403 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1utf8__to__utf16}{utf8\_to\_utf16}} \{}
\DoxyCodeLine{1404  \textcolor{keyword}{private}:}
\DoxyCodeLine{1405   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<wchar\_t>}} buffer\_;}
\DoxyCodeLine{1406 }
\DoxyCodeLine{1407  \textcolor{keyword}{public}:}
\DoxyCodeLine{1408   FMT\_API \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1utf8__to__utf16}{utf8\_to\_utf16}}(\mbox{\hyperlink{classbasic__string__view}{string\_view}} s);}
\DoxyCodeLine{1409   \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<wchar\_t>}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{\&buffer\_[0], size()\}; \}}
\DoxyCodeLine{1410   \textcolor{keyword}{auto} size() \textcolor{keyword}{const} -\/> \textcolor{keywordtype}{size\_t} \{ \textcolor{keywordflow}{return} buffer\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}() -\/ 1; \}}
\DoxyCodeLine{1411   \textcolor{keyword}{auto} c\_str() \textcolor{keyword}{const} -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{wchar\_t}* \{ \textcolor{keywordflow}{return} \&buffer\_[0]; \}}
\DoxyCodeLine{1412   \textcolor{keyword}{auto} str() \textcolor{keyword}{const} -\/> std::wstring \{ \textcolor{keywordflow}{return} \{\&buffer\_[0], size()\}; \}}
\DoxyCodeLine{1413 \};}
\DoxyCodeLine{1414 }
\DoxyCodeLine{1415 \textcolor{keyword}{enum class} to\_utf8\_error\_policy \{ abort, replace \};}
\DoxyCodeLine{1416 }
\DoxyCodeLine{1417 \textcolor{comment}{// A converter from UTF-\/16/UTF-\/32 (host endian) to UTF-\/8.}}
\DoxyCodeLine{1418 \textcolor{keyword}{template} <\textcolor{keyword}{typename} WChar, \textcolor{keyword}{typename} Buffer = memory\_buffer> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1to__utf8}{to\_utf8}} \{}
\DoxyCodeLine{1419  \textcolor{keyword}{private}:}
\DoxyCodeLine{1420   Buffer buffer\_;}
\DoxyCodeLine{1421 }
\DoxyCodeLine{1422  \textcolor{keyword}{public}:}
\DoxyCodeLine{1423   \mbox{\hyperlink{classdetail_1_1to__utf8}{to\_utf8}}() \{\}}
\DoxyCodeLine{1424   \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1to__utf8}{to\_utf8}}(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<WChar>}} s,}
\DoxyCodeLine{1425                    to\_utf8\_error\_policy policy = to\_utf8\_error\_policy::abort) \{}
\DoxyCodeLine{1426     \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(WChar) == 2 || \textcolor{keyword}{sizeof}(WChar) == 4,}
\DoxyCodeLine{1427                   \textcolor{stringliteral}{"{}Expect utf16 or utf32"{}});}
\DoxyCodeLine{1428     \textcolor{keywordflow}{if} (!convert(s, policy))}
\DoxyCodeLine{1429       FMT\_THROW(std::runtime\_error(\textcolor{keyword}{sizeof}(WChar) == 2 ? \textcolor{stringliteral}{"{}invalid utf16"{}}}
\DoxyCodeLine{1430                                                       : \textcolor{stringliteral}{"{}invalid utf32"{}}));}
\DoxyCodeLine{1431   \}}
\DoxyCodeLine{1432   \textcolor{keyword}{operator} \mbox{\hyperlink{classbasic__string__view}{string\_view}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classbasic__string__view}{string\_view}}(\&buffer\_[0], size()); \}}
\DoxyCodeLine{1433   \textcolor{keywordtype}{size\_t} size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} buffer\_.size() -\/ 1; \}}
\DoxyCodeLine{1434   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* c\_str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \&buffer\_[0]; \}}
\DoxyCodeLine{1435   std::string str()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::string(\&buffer\_[0], size()); \}}
\DoxyCodeLine{1436 }
\DoxyCodeLine{1437   \textcolor{comment}{// Performs conversion returning a bool instead of throwing exception on}}
\DoxyCodeLine{1438   \textcolor{comment}{// conversion error. This method may still throw in case of memory allocation}}
\DoxyCodeLine{1439   \textcolor{comment}{// error.}}
\DoxyCodeLine{1440   \textcolor{keywordtype}{bool} convert(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<WChar>}} s,}
\DoxyCodeLine{1441                to\_utf8\_error\_policy policy = to\_utf8\_error\_policy::abort) \{}
\DoxyCodeLine{1442     \textcolor{keywordflow}{if} (!convert(buffer\_, s, policy)) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1443     buffer\_.push\_back(0);}
\DoxyCodeLine{1444     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1445   \}}
\DoxyCodeLine{1446   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} convert(}
\DoxyCodeLine{1447       Buffer\& buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<WChar>}} s,}
\DoxyCodeLine{1448       to\_utf8\_error\_policy policy = to\_utf8\_error\_policy::abort) \{}
\DoxyCodeLine{1449     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p = s.begin(); p != s.end(); ++p) \{}
\DoxyCodeLine{1450       uint32\_t c = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(*p);}
\DoxyCodeLine{1451       \textcolor{keywordflow}{if} (\textcolor{keyword}{sizeof}(WChar) == 2 \&\& c >= 0xd800 \&\& c <= 0xdfff) \{}
\DoxyCodeLine{1452         \textcolor{comment}{// Handle a surrogate pair.}}
\DoxyCodeLine{1453         ++p;}
\DoxyCodeLine{1454         \textcolor{keywordflow}{if} (p == s.end() || (c \& 0xfc00) != 0xd800 || (*p \& 0xfc00) != 0xdc00) \{}
\DoxyCodeLine{1455           \textcolor{keywordflow}{if} (policy == to\_utf8\_error\_policy::abort) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1456           buf.append(\mbox{\hyperlink{classbasic__string__view}{string\_view}}(\textcolor{stringliteral}{"{}{\ucr}"{}}));}
\DoxyCodeLine{1457           -\/-\/p;}
\DoxyCodeLine{1458         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1459           c = (c << 10) + static\_cast<uint32\_t>(*p) -\/ 0x35fdc00;}
\DoxyCodeLine{1460         \}}
\DoxyCodeLine{1461       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c < 0x80) \{}
\DoxyCodeLine{1462         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(c));}
\DoxyCodeLine{1463       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c < 0x800) \{}
\DoxyCodeLine{1464         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0xc0 | (c >> 6)));}
\DoxyCodeLine{1465         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | (c \& 0x3f)));}
\DoxyCodeLine{1466       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((c >= 0x800 \&\& c <= 0xd7ff) || (c >= 0xe000 \&\& c <= 0xffff)) \{}
\DoxyCodeLine{1467         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0xe0 | (c >> 12)));}
\DoxyCodeLine{1468         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | ((c \& 0xfff) >> 6)));}
\DoxyCodeLine{1469         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | (c \& 0x3f)));}
\DoxyCodeLine{1470       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (c >= 0x10000 \&\& c <= 0x10ffff) \{}
\DoxyCodeLine{1471         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0xf0 | (c >> 18)));}
\DoxyCodeLine{1472         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | ((c \& 0x3ffff) >> 12)));}
\DoxyCodeLine{1473         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | ((c \& 0xfff) >> 6)));}
\DoxyCodeLine{1474         buf.push\_back(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(0x80 | (c \& 0x3f)));}
\DoxyCodeLine{1475       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1476         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1477       \}}
\DoxyCodeLine{1478     \}}
\DoxyCodeLine{1479     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1480   \}}
\DoxyCodeLine{1481 \};}
\DoxyCodeLine{1482 }
\DoxyCodeLine{1483 \textcolor{comment}{// Computes 128-\/bit result of multiplication of two 64-\/bit unsigned integers.}}
\DoxyCodeLine{1484 \textcolor{keyword}{inline} \mbox{\hyperlink{classdetail_1_1uint128__fallback}{uint128\_fallback}} umul128(uint64\_t x, uint64\_t y) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{1485 \textcolor{preprocessor}{\#if FMT\_USE\_INT128}}
\DoxyCodeLine{1486   \textcolor{keyword}{auto} p = \textcolor{keyword}{static\_cast<}uint128\_opt\textcolor{keyword}{>}(x) * \textcolor{keyword}{static\_cast<}uint128\_opt\textcolor{keyword}{>}(y);}
\DoxyCodeLine{1487   \textcolor{keywordflow}{return} \{\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(p >> 64), \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(p)\};}
\DoxyCodeLine{1488 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) \&\& defined(\_M\_X64)}}
\DoxyCodeLine{1489   \textcolor{keyword}{auto} result = uint128\_fallback();}
\DoxyCodeLine{1490   result.lo\_ = \_umul128(x, y, \&result.hi\_);}
\DoxyCodeLine{1491   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1492 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1493   \textcolor{keyword}{const} uint64\_t mask = \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(max\_value<uint32\_t>());}
\DoxyCodeLine{1494 }
\DoxyCodeLine{1495   uint64\_t a = x >> 32;}
\DoxyCodeLine{1496   uint64\_t b = x \& mask;}
\DoxyCodeLine{1497   uint64\_t c = y >> 32;}
\DoxyCodeLine{1498   uint64\_t d = y \& mask;}
\DoxyCodeLine{1499 }
\DoxyCodeLine{1500   uint64\_t ac = a * c;}
\DoxyCodeLine{1501   uint64\_t bc = b * c;}
\DoxyCodeLine{1502   uint64\_t ad = a * d;}
\DoxyCodeLine{1503   uint64\_t bd = b * d;}
\DoxyCodeLine{1504 }
\DoxyCodeLine{1505   uint64\_t intermediate = (bd >> 32) + (ad \& mask) + (bc \& mask);}
\DoxyCodeLine{1506 }
\DoxyCodeLine{1507   \textcolor{keywordflow}{return} \{ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),}
\DoxyCodeLine{1508           (intermediate << 32) + (bd \& mask)\};}
\DoxyCodeLine{1509 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1510 \}}
\DoxyCodeLine{1511 }
\DoxyCodeLine{1512 \textcolor{keyword}{namespace }dragonbox \{}
\DoxyCodeLine{1513 \textcolor{comment}{// Computes floor(log10(pow(2, e))) for e in [-\/2620, 2620] using the method from}}
\DoxyCodeLine{1514 \textcolor{comment}{// https://fmt.dev/papers/Dragonbox.pdf\#page=28, section 6.1.}}
\DoxyCodeLine{1515 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} floor\_log10\_pow2(\textcolor{keywordtype}{int} e) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{1516   FMT\_ASSERT(e <= 2620 \&\& e >= -\/2620, \textcolor{stringliteral}{"{}too large exponent"{}});}
\DoxyCodeLine{1517   \textcolor{keyword}{static\_assert}((-\/1 >> 1) == -\/1, \textcolor{stringliteral}{"{}right shift is not arithmetic"{}});}
\DoxyCodeLine{1518   \textcolor{keywordflow}{return} (e * 315653) >> 20;}
\DoxyCodeLine{1519 \}}
\DoxyCodeLine{1520 }
\DoxyCodeLine{1521 \textcolor{keyword}{inline} \textcolor{keywordtype}{int} floor\_log2\_pow10(\textcolor{keywordtype}{int} e) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{1522   FMT\_ASSERT(e <= 1233 \&\& e >= -\/1233, \textcolor{stringliteral}{"{}too large exponent"{}});}
\DoxyCodeLine{1523   \textcolor{keywordflow}{return} (e * 1741647) >> 19;}
\DoxyCodeLine{1524 \}}
\DoxyCodeLine{1525 }
\DoxyCodeLine{1526 \textcolor{comment}{// Computes upper 64 bits of multiplication of two 64-\/bit unsigned integers.}}
\DoxyCodeLine{1527 \textcolor{keyword}{inline} uint64\_t umul128\_upper64(uint64\_t x, uint64\_t y) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{1528 \textcolor{preprocessor}{\#if FMT\_USE\_INT128}}
\DoxyCodeLine{1529   \textcolor{keyword}{auto} p = \textcolor{keyword}{static\_cast<}uint128\_opt\textcolor{keyword}{>}(x) * \textcolor{keyword}{static\_cast<}uint128\_opt\textcolor{keyword}{>}(y);}
\DoxyCodeLine{1530   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(p >> 64);}
\DoxyCodeLine{1531 \textcolor{preprocessor}{\#elif defined(\_MSC\_VER) \&\& defined(\_M\_X64)}}
\DoxyCodeLine{1532   \textcolor{keywordflow}{return} \_\_umulh(x, y);}
\DoxyCodeLine{1533 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1534   \textcolor{keywordflow}{return} umul128(x, y).high();}
\DoxyCodeLine{1535 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1536 \}}
\DoxyCodeLine{1537 }
\DoxyCodeLine{1538 \textcolor{comment}{// Computes upper 128 bits of multiplication of a 64-\/bit unsigned integer and a}}
\DoxyCodeLine{1539 \textcolor{comment}{// 128-\/bit unsigned integer.}}
\DoxyCodeLine{1540 \textcolor{keyword}{inline} uint128\_fallback umul192\_upper128(uint64\_t x,}
\DoxyCodeLine{1541                                          uint128\_fallback y) \textcolor{keyword}{noexcept} \{}
\DoxyCodeLine{1542   uint128\_fallback r = umul128(x, y.high());}
\DoxyCodeLine{1543   r += umul128\_upper64(x, y.low());}
\DoxyCodeLine{1544   \textcolor{keywordflow}{return} r;}
\DoxyCodeLine{1545 \}}
\DoxyCodeLine{1546 }
\DoxyCodeLine{1547 FMT\_API uint128\_fallback get\_cached\_power(\textcolor{keywordtype}{int} k) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549 \textcolor{comment}{// Type-\/specific information that Dragonbox uses.}}
\DoxyCodeLine{1550 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dragonbox_1_1float__info}{float\_info}};}
\DoxyCodeLine{1551 }
\DoxyCodeLine{1552 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dragonbox_1_1float__info}{float\_info}}<float> \{}
\DoxyCodeLine{1553   \textcolor{keyword}{using }carrier\_uint = uint32\_t;}
\DoxyCodeLine{1554   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_bits = 8;}
\DoxyCodeLine{1555   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} kappa = 1;}
\DoxyCodeLine{1556   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} big\_divisor = 100;}
\DoxyCodeLine{1557   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} small\_divisor = 10;}
\DoxyCodeLine{1558   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_k = -\/31;}
\DoxyCodeLine{1559   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_k = 46;}
\DoxyCodeLine{1560   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_lower\_threshold = -\/35;}
\DoxyCodeLine{1561   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_upper\_threshold = -\/35;}
\DoxyCodeLine{1562 \};}
\DoxyCodeLine{1563 }
\DoxyCodeLine{1564 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dragonbox_1_1float__info}{float\_info}}<double> \{}
\DoxyCodeLine{1565   \textcolor{keyword}{using }carrier\_uint = uint64\_t;}
\DoxyCodeLine{1566   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_bits = 11;}
\DoxyCodeLine{1567   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} kappa = 2;}
\DoxyCodeLine{1568   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} big\_divisor = 1000;}
\DoxyCodeLine{1569   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} small\_divisor = 100;}
\DoxyCodeLine{1570   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} min\_k = -\/292;}
\DoxyCodeLine{1571   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_k = 341;}
\DoxyCodeLine{1572   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_lower\_threshold = -\/77;}
\DoxyCodeLine{1573   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} shorter\_interval\_tie\_upper\_threshold = -\/77;}
\DoxyCodeLine{1574 \};}
\DoxyCodeLine{1575 }
\DoxyCodeLine{1576 \textcolor{comment}{// An 80-\/ or 128-\/bit floating point number.}}
\DoxyCodeLine{1577 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1578 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dragonbox_1_1float__info}{float\_info}}<T, enable\_if\_t<std::numeric\_limits<T>::digits == 64 ||}
\DoxyCodeLine{1579                                  std::numeric\_limits<T>::digits == 113 ||}
\DoxyCodeLine{1580                                  is\_float128<T>::value>> \{}
\DoxyCodeLine{1581   \textcolor{keyword}{using }carrier\_uint = detail::uint128\_t;}
\DoxyCodeLine{1582   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{int} exponent\_bits = 15;}
\DoxyCodeLine{1583 \};}
\DoxyCodeLine{1584 }
\DoxyCodeLine{1585 \textcolor{comment}{// A double-\/double floating point number.}}
\DoxyCodeLine{1586 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1587 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dragonbox_1_1float__info}{float\_info}}<T, enable\_if\_t<is\_double\_double<T>::\mbox{\hyperlink{classdetail_1_1value}{value}}>> \{}
\DoxyCodeLine{1588   \textcolor{keyword}{using }carrier\_uint = detail::uint128\_t;}
\DoxyCodeLine{1589 \};}
\DoxyCodeLine{1590 }
\DoxyCodeLine{1591 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1dragonbox_1_1decimal__fp}{decimal\_fp}} \{}
\DoxyCodeLine{1592   \textcolor{keyword}{using }significand\_type = \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1dragonbox_1_1float__info}{float\_info<T>::carrier\_uint}};}
\DoxyCodeLine{1593   significand\_type significand;}
\DoxyCodeLine{1594   \textcolor{keywordtype}{int} exponent;}
\DoxyCodeLine{1595 \};}
\DoxyCodeLine{1596 }
\DoxyCodeLine{1597 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_API \textcolor{keyword}{auto} to\_decimal(T x) \textcolor{keyword}{noexcept} -\/> \mbox{\hyperlink{structdetail_1_1dragonbox_1_1decimal__fp}{decimal\_fp<T>}};}
\DoxyCodeLine{1598 \}  \textcolor{comment}{// namespace dragonbox}}
\DoxyCodeLine{1599 }
\DoxyCodeLine{1600 \textcolor{comment}{// Returns true iff Float has the implicit bit which is not stored.}}
\DoxyCodeLine{1601 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} has\_implicit\_bit() \{}
\DoxyCodeLine{1602   \textcolor{comment}{// An 80-\/bit FP number has a 64-\/bit significand an no implicit bit.}}
\DoxyCodeLine{1603   \textcolor{keywordflow}{return} std::numeric\_limits<Float>::digits != 64;}
\DoxyCodeLine{1604 \}}
\DoxyCodeLine{1605 }
\DoxyCodeLine{1606 \textcolor{comment}{// Returns the number of significand bits stored in Float. The implicit bit is}}
\DoxyCodeLine{1607 \textcolor{comment}{// not counted since it is not stored.}}
\DoxyCodeLine{1608 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} num\_significand\_bits() \{}
\DoxyCodeLine{1609   \textcolor{comment}{// std::numeric\_limits may not support \_\_float128.}}
\DoxyCodeLine{1610   \textcolor{keywordflow}{return} is\_float128<Float>() ? 112}
\DoxyCodeLine{1611                               : (std::numeric\_limits<Float>::digits -\/}
\DoxyCodeLine{1612                                  (has\_implicit\_bit<Float>() ? 1 : 0));}
\DoxyCodeLine{1613 \}}
\DoxyCodeLine{1614 }
\DoxyCodeLine{1615 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float>}
\DoxyCodeLine{1616 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} exponent\_mask() -\/>}
\DoxyCodeLine{1617     \textcolor{keyword}{typename} dragonbox::float\_info<Float>::carrier\_uint \{}
\DoxyCodeLine{1618   \textcolor{keyword}{using }float\_uint = \textcolor{keyword}{typename} dragonbox::float\_info<Float>::carrier\_uint;}
\DoxyCodeLine{1619   \textcolor{keywordflow}{return} ((float\_uint(1) << dragonbox::float\_info<Float>::exponent\_bits) -\/ 1)}
\DoxyCodeLine{1620          << num\_significand\_bits<Float>();}
\DoxyCodeLine{1621 \}}
\DoxyCodeLine{1622 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} exponent\_bias() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{1623   \textcolor{comment}{// std::numeric\_limits may not support \_\_float128.}}
\DoxyCodeLine{1624   \textcolor{keywordflow}{return} is\_float128<Float>() ? 16383}
\DoxyCodeLine{1625                               : std::numeric\_limits<Float>::max\_exponent -\/ 1;}
\DoxyCodeLine{1626 \}}
\DoxyCodeLine{1627 }
\DoxyCodeLine{1628 \textcolor{comment}{// Writes the exponent exp in the form "{}[+-\/]d\{2,3\}"{} to buffer.}}
\DoxyCodeLine{1629 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} It>}
\DoxyCodeLine{1630 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_exponent(\textcolor{keywordtype}{int} exp, It it) -\/> It \{}
\DoxyCodeLine{1631   FMT\_ASSERT(-\/10000 < exp \&\& exp < 10000, \textcolor{stringliteral}{"{}exponent out of range"{}});}
\DoxyCodeLine{1632   \textcolor{keywordflow}{if} (exp < 0) \{}
\DoxyCodeLine{1633     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{1634     exp = -\/exp;}
\DoxyCodeLine{1635   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1636     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'+'});}
\DoxyCodeLine{1637   \}}
\DoxyCodeLine{1638   \textcolor{keywordflow}{if} (exp >= 100) \{}
\DoxyCodeLine{1639     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* top = digits2(to\_unsigned(exp / 100));}
\DoxyCodeLine{1640     \textcolor{keywordflow}{if} (exp >= 1000) *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(top[0]);}
\DoxyCodeLine{1641     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(top[1]);}
\DoxyCodeLine{1642     exp \%= 100;}
\DoxyCodeLine{1643   \}}
\DoxyCodeLine{1644   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* d = digits2(to\_unsigned(exp));}
\DoxyCodeLine{1645   *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(d[0]);}
\DoxyCodeLine{1646   *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(d[1]);}
\DoxyCodeLine{1647   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1648 \}}
\DoxyCodeLine{1649 }
\DoxyCodeLine{1650 \textcolor{comment}{// A floating-\/point number f * pow(2, e) where F is an unsigned type.}}
\DoxyCodeLine{1651 \textcolor{keyword}{template} <\textcolor{keyword}{typename} F> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1basic__fp}{basic\_fp}} \{}
\DoxyCodeLine{1652   F f;}
\DoxyCodeLine{1653   \textcolor{keywordtype}{int} e;}
\DoxyCodeLine{1654 }
\DoxyCodeLine{1655   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} num\_significand\_bits =}
\DoxyCodeLine{1656       \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\textcolor{keyword}{sizeof}(F) * num\_bits<unsigned char>());}
\DoxyCodeLine{1657 }
\DoxyCodeLine{1658   \textcolor{keyword}{constexpr} \mbox{\hyperlink{structdetail_1_1basic__fp}{basic\_fp}}() : f(0), e(0) \{\}}
\DoxyCodeLine{1659   \textcolor{keyword}{constexpr} \mbox{\hyperlink{structdetail_1_1basic__fp}{basic\_fp}}(uint64\_t f\_val, \textcolor{keywordtype}{int} e\_val) : f(f\_val), e(e\_val) \{\}}
\DoxyCodeLine{1660 }
\DoxyCodeLine{1661   \textcolor{comment}{// Constructs fp from an IEEE754 floating-\/point number.}}
\DoxyCodeLine{1662   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float> FMT\_CONSTEXPR \mbox{\hyperlink{structdetail_1_1basic__fp}{basic\_fp}}(Float n) \{ assign(n); \}}
\DoxyCodeLine{1663 }
\DoxyCodeLine{1664   \textcolor{comment}{// Assigns n to this and return true iff predecessor is closer than successor.}}
\DoxyCodeLine{1665   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{double}\_\textcolor{keywordtype}{double}<Float>::value)>}
\DoxyCodeLine{1666   FMT\_CONSTEXPR \textcolor{keyword}{auto} assign(Float n) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1667     \textcolor{keyword}{static\_assert}(std::numeric\_limits<Float>::digits <= 113, \textcolor{stringliteral}{"{}unsupported FP"{}});}
\DoxyCodeLine{1668     \textcolor{comment}{// Assume Float is in the format [sign][exponent][significand].}}
\DoxyCodeLine{1669     \textcolor{keyword}{using }carrier\_uint = \textcolor{keyword}{typename} \mbox{\hyperlink{structdetail_1_1dragonbox_1_1float__info}{dragonbox::float\_info<Float>::carrier\_uint}};}
\DoxyCodeLine{1670     \textcolor{keyword}{const} \textcolor{keyword}{auto} num\_float\_significand\_bits =}
\DoxyCodeLine{1671         detail::num\_significand\_bits<Float>();}
\DoxyCodeLine{1672     \textcolor{keyword}{const} \textcolor{keyword}{auto} implicit\_bit = carrier\_uint(1) << num\_float\_significand\_bits;}
\DoxyCodeLine{1673     \textcolor{keyword}{const} \textcolor{keyword}{auto} significand\_mask = implicit\_bit -\/ 1;}
\DoxyCodeLine{1674     \textcolor{keyword}{auto} u = bit\_cast<carrier\_uint>(n);}
\DoxyCodeLine{1675     f = \textcolor{keyword}{static\_cast<}F\textcolor{keyword}{>}(u \& significand\_mask);}
\DoxyCodeLine{1676     \textcolor{keyword}{auto} biased\_e = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((u \& exponent\_mask<Float>()) >>}
\DoxyCodeLine{1677                                      num\_float\_significand\_bits);}
\DoxyCodeLine{1678     \textcolor{comment}{// The predecessor is closer if n is a normalized power of 2 (f == 0)}}
\DoxyCodeLine{1679     \textcolor{comment}{// other than the smallest normalized number (biased\_e > 1).}}
\DoxyCodeLine{1680     \textcolor{keyword}{auto} is\_predecessor\_closer = f == 0 \&\& biased\_e > 1;}
\DoxyCodeLine{1681     \textcolor{keywordflow}{if} (biased\_e == 0)}
\DoxyCodeLine{1682       biased\_e = 1;  \textcolor{comment}{// Subnormals use biased exponent 1 (min exponent).}}
\DoxyCodeLine{1683     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (has\_implicit\_bit<Float>())}
\DoxyCodeLine{1684       f += \textcolor{keyword}{static\_cast<}F\textcolor{keyword}{>}(implicit\_bit);}
\DoxyCodeLine{1685     e = biased\_e -\/ exponent\_bias<Float>() -\/ num\_float\_significand\_bits;}
\DoxyCodeLine{1686     \textcolor{keywordflow}{if} (!has\_implicit\_bit<Float>()) ++e;}
\DoxyCodeLine{1687     \textcolor{keywordflow}{return} is\_predecessor\_closer;}
\DoxyCodeLine{1688   \}}
\DoxyCodeLine{1689 }
\DoxyCodeLine{1690   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{double}\_\textcolor{keywordtype}{double}<Float>::value)>}
\DoxyCodeLine{1691   FMT\_CONSTEXPR \textcolor{keyword}{auto} assign(Float n) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1692     \textcolor{keyword}{static\_assert}(std::numeric\_limits<double>::is\_iec559, \textcolor{stringliteral}{"{}unsupported FP"{}});}
\DoxyCodeLine{1693     \textcolor{keywordflow}{return} assign(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(n));}
\DoxyCodeLine{1694   \}}
\DoxyCodeLine{1695 \};}
\DoxyCodeLine{1696 }
\DoxyCodeLine{1697 \textcolor{keyword}{using }\mbox{\hyperlink{structdetail_1_1basic__fp}{fp}} = \mbox{\hyperlink{structdetail_1_1basic__fp}{basic\_fp<unsigned long long>}};}
\DoxyCodeLine{1698 }
\DoxyCodeLine{1699 \textcolor{comment}{// Normalizes the value converted from double and multiplied by (1 << SHIFT).}}
\DoxyCodeLine{1700 \textcolor{keyword}{template} <\textcolor{keywordtype}{int} SHIFT = 0, \textcolor{keyword}{typename} F>}
\DoxyCodeLine{1701 FMT\_CONSTEXPR \mbox{\hyperlink{structdetail_1_1basic__fp}{basic\_fp<F>}} normalize(\mbox{\hyperlink{structdetail_1_1basic__fp}{basic\_fp<F>}} \mbox{\hyperlink{classdetail_1_1value}{value}}) \{}
\DoxyCodeLine{1702   \textcolor{comment}{// Handle subnormals.}}
\DoxyCodeLine{1703   \textcolor{keyword}{const} \textcolor{keyword}{auto} implicit\_bit = F(1) << num\_significand\_bits<double>();}
\DoxyCodeLine{1704   \textcolor{keyword}{const} \textcolor{keyword}{auto} shifted\_implicit\_bit = implicit\_bit << SHIFT;}
\DoxyCodeLine{1705   \textcolor{keywordflow}{while} ((\mbox{\hyperlink{classdetail_1_1value}{value}}.f \& shifted\_implicit\_bit) == 0) \{}
\DoxyCodeLine{1706     \mbox{\hyperlink{classdetail_1_1value}{value}}.f <<= 1;}
\DoxyCodeLine{1707     -\/-\/\mbox{\hyperlink{classdetail_1_1value}{value}}.e;}
\DoxyCodeLine{1708   \}}
\DoxyCodeLine{1709   \textcolor{comment}{// Subtract 1 to account for hidden bit.}}
\DoxyCodeLine{1710   \textcolor{keyword}{const} \textcolor{keyword}{auto} offset = basic\_fp<F>::num\_significand\_bits -\/}
\DoxyCodeLine{1711                       num\_significand\_bits<double>() -\/ SHIFT -\/ 1;}
\DoxyCodeLine{1712   value.f <<= offset;}
\DoxyCodeLine{1713   value.e -\/= offset;}
\DoxyCodeLine{1714   \textcolor{keywordflow}{return} value;}
\DoxyCodeLine{1715 \}}
\DoxyCodeLine{1716 }
\DoxyCodeLine{1717 \textcolor{comment}{// Computes lhs * rhs / pow(2, 64) rounded to nearest with half-\/up tie breaking.}}
\DoxyCodeLine{1718 FMT\_CONSTEXPR \textcolor{keyword}{inline} uint64\_t multiply(uint64\_t lhs, uint64\_t rhs) \{}
\DoxyCodeLine{1719 \textcolor{preprocessor}{\#if FMT\_USE\_INT128}}
\DoxyCodeLine{1720   \textcolor{keyword}{auto} product = \textcolor{keyword}{static\_cast<}\_\_uint128\_t\textcolor{keyword}{>}(lhs) * rhs;}
\DoxyCodeLine{1721   \textcolor{keyword}{auto} f = \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(product >> 64);}
\DoxyCodeLine{1722   \textcolor{keywordflow}{return} (\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(product) \& (1ULL << 63)) != 0 ? f + 1 : f;}
\DoxyCodeLine{1723 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{1724   \textcolor{comment}{// Multiply 32-\/bit parts of significands.}}
\DoxyCodeLine{1725   uint64\_t mask = (1ULL << 32) -\/ 1;}
\DoxyCodeLine{1726   uint64\_t a = lhs >> 32, b = lhs \& mask;}
\DoxyCodeLine{1727   uint64\_t c = rhs >> 32, d = rhs \& mask;}
\DoxyCodeLine{1728   uint64\_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;}
\DoxyCodeLine{1729   \textcolor{comment}{// Compute mid 64-\/bit of result and round.}}
\DoxyCodeLine{1730   uint64\_t mid = (bd >> 32) + (ad \& mask) + (bc \& mask) + (1U << 31);}
\DoxyCodeLine{1731   \textcolor{keywordflow}{return} ac + (ad >> 32) + (bc >> 32) + (mid >> 32);}
\DoxyCodeLine{1732 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1733 \}}
\DoxyCodeLine{1734 }
\DoxyCodeLine{1735 FMT\_CONSTEXPR \textcolor{keyword}{inline} fp operator*(fp x, fp y) \{}
\DoxyCodeLine{1736   \textcolor{keywordflow}{return} \{multiply(x.f, y.f), x.e + y.e + 64\};}
\DoxyCodeLine{1737 \}}
\DoxyCodeLine{1738 }
\DoxyCodeLine{1739 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T = \textcolor{keywordtype}{void}> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1basic__data}{basic\_data}} \{}
\DoxyCodeLine{1740   \textcolor{comment}{// For checking rounding thresholds.}}
\DoxyCodeLine{1741   \textcolor{comment}{// The kth entry is chosen to be the smallest integer such that the}}
\DoxyCodeLine{1742   \textcolor{comment}{// upper 32-\/bits of 10\string^(k+1) times it is strictly bigger than 5 * 10\string^k.}}
\DoxyCodeLine{1743   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} uint32\_t fractional\_part\_rounding\_thresholds[8] = \{}
\DoxyCodeLine{1744       2576980378U,  \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^1)}}
\DoxyCodeLine{1745       2190433321U,  \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^2)}}
\DoxyCodeLine{1746       2151778616U,  \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^3)}}
\DoxyCodeLine{1747       2147913145U,  \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^4)}}
\DoxyCodeLine{1748       2147526598U,  \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^5)}}
\DoxyCodeLine{1749       2147487943U,  \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^6)}}
\DoxyCodeLine{1750       2147484078U,  \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^7)}}
\DoxyCodeLine{1751       2147483691U   \textcolor{comment}{// ceil(2\string^31 + 2\string^32/10\string^8)}}
\DoxyCodeLine{1752   \};}
\DoxyCodeLine{1753 \};}
\DoxyCodeLine{1754 \textcolor{comment}{// This is a struct rather than an alias to avoid shadowing warnings in gcc.}}
\DoxyCodeLine{1755 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1data}{data}} : \mbox{\hyperlink{structdetail_1_1basic__data}{basic\_data}}<> \{\};}
\DoxyCodeLine{1756 }
\DoxyCodeLine{1757 \textcolor{preprocessor}{\#if FMT\_CPLUSPLUS < 201703L}}
\DoxyCodeLine{1758 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1759 \textcolor{keyword}{constexpr} uint32\_t \mbox{\hyperlink{structdetail_1_1basic__data}{basic\_data<T>::fractional\_part\_rounding\_thresholds}}[];}
\DoxyCodeLine{1760 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1761 }
\DoxyCodeLine{1762 template <typename T, bool doublish = num\_bits<T>() == num\_bits<double>()>}
\DoxyCodeLine{1763 \textcolor{keyword}{using }convert\_float\_result =}
\DoxyCodeLine{1764     conditional\_t<std::is\_same<T, float>::value || doublish, double, T>;}
\DoxyCodeLine{1765 }
\DoxyCodeLine{1766 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{1767 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} convert\_float(T \mbox{\hyperlink{classdetail_1_1value}{value}}) -\/> convert\_float\_result<T> \{}
\DoxyCodeLine{1768   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}convert\_float\_result<T>\textcolor{keyword}{>}(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{1769 \}}
\DoxyCodeLine{1770 }
\DoxyCodeLine{1771 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1772 FMT\_NOINLINE FMT\_CONSTEXPR \textcolor{keyword}{auto} fill(OutputIt it, \textcolor{keywordtype}{size\_t} n,}
\DoxyCodeLine{1773                                      \textcolor{keyword}{const} fill\_t<Char>\& fill) -\/> OutputIt \{}
\DoxyCodeLine{1774   \textcolor{keyword}{auto} fill\_size = fill.size();}
\DoxyCodeLine{1775   \textcolor{keywordflow}{if} (fill\_size == 1) \textcolor{keywordflow}{return} detail::fill\_n(it, n, fill[0]);}
\DoxyCodeLine{1776   \textcolor{keyword}{auto} data = fill.data();}
\DoxyCodeLine{1777   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < n; ++i)}
\DoxyCodeLine{1778     it = copy\_str<Char>(data, data + fill\_size, it);}
\DoxyCodeLine{1779   \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{1780 \}}
\DoxyCodeLine{1781 }
\DoxyCodeLine{1782 \textcolor{comment}{// Writes the output of f, padded according to format specifications in specs.}}
\DoxyCodeLine{1783 \textcolor{comment}{// size: output size in code units.}}
\DoxyCodeLine{1784 \textcolor{comment}{// width: output display width in (terminal) column positions.}}
\DoxyCodeLine{1785 \textcolor{keyword}{template} <align::type align = align::left, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{1786           \textcolor{keyword}{typename} F>}
\DoxyCodeLine{1787 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_padded(OutputIt out, \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{1788                                 \textcolor{keywordtype}{size\_t} size, \textcolor{keywordtype}{size\_t} width, F\&\& f) -\/> OutputIt \{}
\DoxyCodeLine{1789   \textcolor{keyword}{static\_assert}(align == align::left || align == align::right, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1790   \textcolor{keywordtype}{unsigned} spec\_width = to\_unsigned(specs.width);}
\DoxyCodeLine{1791   \textcolor{keywordtype}{size\_t} padding = spec\_width > width ? spec\_width -\/ width : 0;}
\DoxyCodeLine{1792   \textcolor{comment}{// Shifts are encoded as string literals because static constexpr is not}}
\DoxyCodeLine{1793   \textcolor{comment}{// supported in constexpr functions.}}
\DoxyCodeLine{1794   \textcolor{keyword}{auto}* shifts = align == align::left ? \textcolor{stringliteral}{"{}\(\backslash\)x1f\(\backslash\)x1f\(\backslash\)x00\(\backslash\)x01"{}} : \textcolor{stringliteral}{"{}\(\backslash\)x00\(\backslash\)x1f\(\backslash\)x00\(\backslash\)x01"{}};}
\DoxyCodeLine{1795   \textcolor{keywordtype}{size\_t} left\_padding = padding >> shifts[specs.align];}
\DoxyCodeLine{1796   \textcolor{keywordtype}{size\_t} right\_padding = padding -\/ left\_padding;}
\DoxyCodeLine{1797   \textcolor{keyword}{auto} it = reserve(out, size + padding * specs.fill.size());}
\DoxyCodeLine{1798   \textcolor{keywordflow}{if} (left\_padding != 0) it = fill(it, left\_padding, specs.fill);}
\DoxyCodeLine{1799   it = f(it);}
\DoxyCodeLine{1800   \textcolor{keywordflow}{if} (right\_padding != 0) it = fill(it, right\_padding, specs.fill);}
\DoxyCodeLine{1801   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{1802 \}}
\DoxyCodeLine{1803 }
\DoxyCodeLine{1804 \textcolor{keyword}{template} <align::type align = align::left, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{1805           \textcolor{keyword}{typename} F>}
\DoxyCodeLine{1806 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} write\_padded(OutputIt out, \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{1807                             \textcolor{keywordtype}{size\_t} size, F\&\& f) -\/> OutputIt \{}
\DoxyCodeLine{1808   \textcolor{keywordflow}{return} write\_padded<align>(out, specs, size, size, f);}
\DoxyCodeLine{1809 \}}
\DoxyCodeLine{1810 }
\DoxyCodeLine{1811 \textcolor{keyword}{template} <align::type align = align::left, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1812 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_bytes(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{string\_view}} \mbox{\hyperlink{classbytes}{bytes}},}
\DoxyCodeLine{1813                                \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs) -\/> OutputIt \{}
\DoxyCodeLine{1814   \textcolor{keywordflow}{return} write\_padded<align>(}
\DoxyCodeLine{1815       out, specs, \mbox{\hyperlink{classbytes}{bytes}}.size(), [\mbox{\hyperlink{classbytes}{bytes}}](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1816         const char* data = bytes.data();}
\DoxyCodeLine{1817         return copy\_str<Char>(data, data + bytes.size(), it);}
\DoxyCodeLine{1818       \});}
\DoxyCodeLine{1819 \}}
\DoxyCodeLine{1820 }
\DoxyCodeLine{1821 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UIntPtr>}
\DoxyCodeLine{1822 \textcolor{keyword}{auto} write\_ptr(OutputIt out, UIntPtr value, \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}* specs)}
\DoxyCodeLine{1823     -\/> OutputIt \{}
\DoxyCodeLine{1824   \textcolor{keywordtype}{int} num\_digits = count\_digits<4>(value);}
\DoxyCodeLine{1825   \textcolor{keyword}{auto} size = to\_unsigned(num\_digits) + size\_t(2);}
\DoxyCodeLine{1826   \textcolor{keyword}{auto} write = [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1827     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{1828     *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'x'});}
\DoxyCodeLine{1829     \textcolor{keywordflow}{return} format\_uint<4, Char>(it, value, num\_digits);}
\DoxyCodeLine{1830   \};}
\DoxyCodeLine{1831   \textcolor{keywordflow}{return} specs ? write\_padded<align::right>(out, *specs, size, write)}
\DoxyCodeLine{1832                : base\_iterator(out, write(reserve(out, size)));}
\DoxyCodeLine{1833 \}}
\DoxyCodeLine{1834 }
\DoxyCodeLine{1835 \textcolor{comment}{// Returns true iff the code point cp is printable.}}
\DoxyCodeLine{1836 FMT\_API \textcolor{keyword}{auto} is\_printable(uint32\_t cp) -\/> bool;}
\DoxyCodeLine{1837 }
\DoxyCodeLine{1838 \textcolor{keyword}{inline} \textcolor{keyword}{auto} needs\_escape(uint32\_t cp) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{1839   \textcolor{keywordflow}{return} cp < 0x20 || cp == 0x7f || cp == \textcolor{charliteral}{'"{}'} || cp == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} ||}
\DoxyCodeLine{1840          !is\_printable(cp);}
\DoxyCodeLine{1841 \}}
\DoxyCodeLine{1842 }
\DoxyCodeLine{1843 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1find__escape__result}{find\_escape\_result}} \{}
\DoxyCodeLine{1844   \textcolor{keyword}{const} Char* begin;}
\DoxyCodeLine{1845   \textcolor{keyword}{const} Char* end;}
\DoxyCodeLine{1846   uint32\_t cp;}
\DoxyCodeLine{1847 \};}
\DoxyCodeLine{1848 }
\DoxyCodeLine{1849 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1850 \textcolor{keyword}{using }make\_unsigned\_char =}
\DoxyCodeLine{1851     \textcolor{keyword}{typename} conditional\_t<std::is\_integral<Char>::value,}
\DoxyCodeLine{1852                            std::make\_unsigned<Char>,}
\DoxyCodeLine{1853                            \mbox{\hyperlink{structtype__identity}{type\_identity<uint32\_t>}}>::type;}
\DoxyCodeLine{1854 }
\DoxyCodeLine{1855 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1856 \textcolor{keyword}{auto} find\_escape(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end)}
\DoxyCodeLine{1857     -\/> \mbox{\hyperlink{structdetail_1_1find__escape__result}{find\_escape\_result<Char>}} \{}
\DoxyCodeLine{1858   \textcolor{keywordflow}{for} (; begin != end; ++begin) \{}
\DoxyCodeLine{1859     uint32\_t cp = \textcolor{keyword}{static\_cast<}make\_unsigned\_char<Char>\textcolor{keyword}{>}(*begin);}
\DoxyCodeLine{1860     \textcolor{keywordflow}{if} (const\_check(\textcolor{keyword}{sizeof}(Char) == 1) \&\& cp >= 0x80) \textcolor{keywordflow}{continue};}
\DoxyCodeLine{1861     \textcolor{keywordflow}{if} (needs\_escape(cp)) \textcolor{keywordflow}{return} \{begin, begin + 1, cp\};}
\DoxyCodeLine{1862   \}}
\DoxyCodeLine{1863   \textcolor{keywordflow}{return} \{begin, \textcolor{keyword}{nullptr}, 0\};}
\DoxyCodeLine{1864 \}}
\DoxyCodeLine{1865 }
\DoxyCodeLine{1866 \textcolor{keyword}{inline} \textcolor{keyword}{auto} find\_escape(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* begin, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* end)}
\DoxyCodeLine{1867     -\/> find\_escape\_result<char> \{}
\DoxyCodeLine{1868   \textcolor{keywordflow}{if} (!is\_utf8()) \textcolor{keywordflow}{return} find\_escape<char>(begin, end);}
\DoxyCodeLine{1869   \textcolor{keyword}{auto} result = find\_escape\_result<char>\{end, \textcolor{keyword}{nullptr}, 0\};}
\DoxyCodeLine{1870   for\_each\_codepoint(\mbox{\hyperlink{classbasic__string__view}{string\_view}}(begin, to\_unsigned(end -\/ begin)),}
\DoxyCodeLine{1871                      [\&](uint32\_t cp, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sv) \{}
\DoxyCodeLine{1872                        \textcolor{keywordflow}{if} (needs\_escape(cp)) \{}
\DoxyCodeLine{1873                          result = \{sv.begin(), sv.end(), cp\};}
\DoxyCodeLine{1874                          \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1875                        \}}
\DoxyCodeLine{1876                        \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1877                      \});}
\DoxyCodeLine{1878   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{1879 \}}
\DoxyCodeLine{1880 }
\DoxyCodeLine{1881 \textcolor{preprocessor}{\#define FMT\_STRING\_IMPL(s, base, explicit)                                    \(\backslash\)}}
\DoxyCodeLine{1882 \textcolor{preprocessor}{  [] \{                                                                        \(\backslash\)}}
\DoxyCodeLine{1883 \textcolor{preprocessor}{    }\textcolor{comment}{/* Use the hidden visibility as a workaround for a GCC bug (\#1973). */}\textcolor{preprocessor}{    \(\backslash\)}}
\DoxyCodeLine{1884 \textcolor{preprocessor}{    }\textcolor{comment}{/* Use a macro-\/like name to avoid shadowing warnings. */}\textcolor{preprocessor}{                  \(\backslash\)}}
\DoxyCodeLine{1885 \textcolor{preprocessor}{    struct FMT\_VISIBILITY("{}hidden"{}}) FMT\_COMPILE\_STRING : base \{               \(\backslash\)}
\DoxyCodeLine{1886       using char\_type FMT\_MAYBE\_UNUSED = fmt::remove\_cvref\_t<decltype(s[0])>; \(\backslash\)}
\DoxyCodeLine{1887       FMT\_MAYBE\_UNUSED FMT\_CONSTEXPR explicit                                 \(\backslash\)}
\DoxyCodeLine{1888       operator fmt::basic\_string\_view<char\_type>() const \{                    \(\backslash\)}
\DoxyCodeLine{1889         return fmt::detail\_exported::compile\_string\_to\_view<char\_type>(s);    \(\backslash\)}
\DoxyCodeLine{1890       \}                                                                       \(\backslash\)}
\DoxyCodeLine{1891     \};                                                                        \(\backslash\)}
\DoxyCodeLine{1892     return FMT\_COMPILE\_STRING();                                              \(\backslash\)}
\DoxyCodeLine{1893   \}()}
\DoxyCodeLine{1894 }
\DoxyCodeLine{1905 \textcolor{preprocessor}{\#define FMT\_STRING(s) FMT\_STRING\_IMPL(s, fmt::detail::compile\_string, )}}
\DoxyCodeLine{1906 }
\DoxyCodeLine{1907 \textcolor{keyword}{template} <\textcolor{keywordtype}{size\_t} w\textcolor{keywordtype}{id}th, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1908 \textcolor{keyword}{auto} write\_codepoint(OutputIt out, \textcolor{keywordtype}{char} prefix, uint32\_t cp) -\/> OutputIt \{}
\DoxyCodeLine{1909   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1910   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(prefix);}
\DoxyCodeLine{1911   Char buf[width];}
\DoxyCodeLine{1912   fill\_n(buf, width, \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'}));}
\DoxyCodeLine{1913   format\_uint<4>(buf, cp, width);}
\DoxyCodeLine{1914   \textcolor{keywordflow}{return} copy\_str<Char>(buf, buf + width, out);}
\DoxyCodeLine{1915 \}}
\DoxyCodeLine{1916 }
\DoxyCodeLine{1917 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{1918 \textcolor{keyword}{auto} write\_escaped\_cp(OutputIt out, \textcolor{keyword}{const} find\_escape\_result<Char>\& escape)}
\DoxyCodeLine{1919     -\/> OutputIt \{}
\DoxyCodeLine{1920   \textcolor{keyword}{auto} c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(escape.cp);}
\DoxyCodeLine{1921   \textcolor{keywordflow}{switch} (escape.cp) \{}
\DoxyCodeLine{1922   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}:}
\DoxyCodeLine{1923     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1924     c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'n'});}
\DoxyCodeLine{1925     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1926   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)r'}:}
\DoxyCodeLine{1927     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1928     c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'r'});}
\DoxyCodeLine{1929     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1930   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}:}
\DoxyCodeLine{1931     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1932     c = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'t'});}
\DoxyCodeLine{1933     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1934   \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'}:}
\DoxyCodeLine{1935     FMT\_FALLTHROUGH;}
\DoxyCodeLine{1936   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)''}:}
\DoxyCodeLine{1937     FMT\_FALLTHROUGH;}
\DoxyCodeLine{1938   \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}:}
\DoxyCodeLine{1939     *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)\(\backslash\)'});}
\DoxyCodeLine{1940     \textcolor{keywordflow}{break};}
\DoxyCodeLine{1941   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1942     \textcolor{keywordflow}{if} (escape.cp < 0x100) \{}
\DoxyCodeLine{1943       \textcolor{keywordflow}{return} write\_codepoint<2, Char>(out, \textcolor{charliteral}{'x'}, escape.cp);}
\DoxyCodeLine{1944     \}}
\DoxyCodeLine{1945     \textcolor{keywordflow}{if} (escape.cp < 0x10000) \{}
\DoxyCodeLine{1946       \textcolor{keywordflow}{return} write\_codepoint<4, Char>(out, \textcolor{charliteral}{'u'}, escape.cp);}
\DoxyCodeLine{1947     \}}
\DoxyCodeLine{1948     \textcolor{keywordflow}{if} (escape.cp < 0x110000) \{}
\DoxyCodeLine{1949       \textcolor{keywordflow}{return} write\_codepoint<8, Char>(out, \textcolor{charliteral}{'U'}, escape.cp);}
\DoxyCodeLine{1950     \}}
\DoxyCodeLine{1951     \textcolor{keywordflow}{for} (Char escape\_char : \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(}
\DoxyCodeLine{1952              escape.begin, to\_unsigned(escape.end -\/ escape.begin))) \{}
\DoxyCodeLine{1953       out = write\_codepoint<2, Char>(out, \textcolor{charliteral}{'x'},}
\DoxyCodeLine{1954                                      \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(escape\_char) \& 0xFF);}
\DoxyCodeLine{1955     \}}
\DoxyCodeLine{1956     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1957   \}}
\DoxyCodeLine{1958   *out++ = c;}
\DoxyCodeLine{1959   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1960 \}}
\DoxyCodeLine{1961 }
\DoxyCodeLine{1962 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1963 \textcolor{keyword}{auto} write\_escaped\_string(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str)}
\DoxyCodeLine{1964     -\/> OutputIt \{}
\DoxyCodeLine{1965   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'"{}'});}
\DoxyCodeLine{1966   \textcolor{keyword}{auto} begin = str.begin(), end = str.end();}
\DoxyCodeLine{1967   \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{1968     \textcolor{keyword}{auto} escape = find\_escape(begin, end);}
\DoxyCodeLine{1969     out = copy\_str<Char>(begin, escape.begin, out);}
\DoxyCodeLine{1970     begin = escape.end;}
\DoxyCodeLine{1971     \textcolor{keywordflow}{if} (!begin) \textcolor{keywordflow}{break};}
\DoxyCodeLine{1972     out = write\_escaped\_cp<OutputIt, Char>(out, escape);}
\DoxyCodeLine{1973   \} \textcolor{keywordflow}{while} (begin != end);}
\DoxyCodeLine{1974   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'"{}'});}
\DoxyCodeLine{1975   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1976 \}}
\DoxyCodeLine{1977 }
\DoxyCodeLine{1978 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1979 \textcolor{keyword}{auto} write\_escaped\_char(OutputIt out, Char v) -\/> OutputIt \{}
\DoxyCodeLine{1980   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)''});}
\DoxyCodeLine{1981   \textcolor{keywordflow}{if} ((needs\_escape(\textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(v)) \&\& v != \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'"{}'})) ||}
\DoxyCodeLine{1982       v == \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)''})) \{}
\DoxyCodeLine{1983     out = write\_escaped\_cp(}
\DoxyCodeLine{1984         out, find\_escape\_result<Char>\{\&v, \&v + 1, \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(v)\});}
\DoxyCodeLine{1985   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1986     *out++ = v;}
\DoxyCodeLine{1987   \}}
\DoxyCodeLine{1988   *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'\(\backslash\)''});}
\DoxyCodeLine{1989   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{1990 \}}
\DoxyCodeLine{1991 }
\DoxyCodeLine{1992 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{1993 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_char(OutputIt out, Char value,}
\DoxyCodeLine{1994                               \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs) -\/> OutputIt \{}
\DoxyCodeLine{1995   \textcolor{keywordtype}{bool} is\_debug = specs.type == presentation\_type::debug;}
\DoxyCodeLine{1996   \textcolor{keywordflow}{return} write\_padded(out, specs, 1, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{1997     \textcolor{keywordflow}{if} (is\_debug) \textcolor{keywordflow}{return} write\_escaped\_char(it, value);}
\DoxyCodeLine{1998     *it++ = value;}
\DoxyCodeLine{1999     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2000   \});}
\DoxyCodeLine{2001 \}}
\DoxyCodeLine{2002 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2003 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, Char value,}
\DoxyCodeLine{2004                          \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs, locale\_ref loc = \{\})}
\DoxyCodeLine{2005     -\/> OutputIt \{}
\DoxyCodeLine{2006   \textcolor{comment}{// char is formatted as unsigned char for consistency across platforms.}}
\DoxyCodeLine{2007   \textcolor{keyword}{using }unsigned\_type =}
\DoxyCodeLine{2008       conditional\_t<std::is\_same<Char, char>::value, \textcolor{keywordtype}{unsigned} char, \textcolor{keywordtype}{unsigned}>;}
\DoxyCodeLine{2009   \textcolor{keywordflow}{return} check\_char\_specs(specs)}
\DoxyCodeLine{2010              ? write\_char(out, value, specs)}
\DoxyCodeLine{2011              : write(out, static\_cast<unsigned\_type>(value), specs, loc);}
\DoxyCodeLine{2012 \}}
\DoxyCodeLine{2013 }
\DoxyCodeLine{2014 \textcolor{comment}{// Data for write\_int that doesn't depend on output iterator type. It is used to}}
\DoxyCodeLine{2015 \textcolor{comment}{// avoid template code bloat.}}
\DoxyCodeLine{2016 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1write__int__data}{write\_int\_data}} \{}
\DoxyCodeLine{2017   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{2018   \textcolor{keywordtype}{size\_t} padding;}
\DoxyCodeLine{2019 }
\DoxyCodeLine{2020   FMT\_CONSTEXPR \mbox{\hyperlink{structdetail_1_1write__int__data}{write\_int\_data}}(\textcolor{keywordtype}{int} num\_digits, \textcolor{keywordtype}{unsigned} prefix,}
\DoxyCodeLine{2021                                \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs)}
\DoxyCodeLine{2022       : size((prefix >> 24) + to\_unsigned(num\_digits)), padding(0) \{}
\DoxyCodeLine{2023     \textcolor{keywordflow}{if} (specs.align == align::numeric) \{}
\DoxyCodeLine{2024       \textcolor{keyword}{auto} width = to\_unsigned(specs.width);}
\DoxyCodeLine{2025       \textcolor{keywordflow}{if} (width > size) \{}
\DoxyCodeLine{2026         padding = width -\/ size;}
\DoxyCodeLine{2027         size = width;}
\DoxyCodeLine{2028       \}}
\DoxyCodeLine{2029     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (specs.precision > num\_digits) \{}
\DoxyCodeLine{2030       size = (prefix >> 24) + to\_unsigned(specs.precision);}
\DoxyCodeLine{2031       padding = to\_unsigned(specs.precision -\/ num\_digits);}
\DoxyCodeLine{2032     \}}
\DoxyCodeLine{2033   \}}
\DoxyCodeLine{2034 \};}
\DoxyCodeLine{2035 }
\DoxyCodeLine{2036 \textcolor{comment}{// Writes an integer in the format}}
\DoxyCodeLine{2037 \textcolor{comment}{//   <left-\/padding><prefix><numeric-\/padding><digits><right-\/padding>}}
\DoxyCodeLine{2038 \textcolor{comment}{// where <digits> are written by write\_digits(it).}}
\DoxyCodeLine{2039 \textcolor{comment}{// prefix contains chars in three lower bytes and the size in the fourth byte.}}
\DoxyCodeLine{2040 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} W>}
\DoxyCodeLine{2041 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write\_int(OutputIt out, \textcolor{keywordtype}{int} num\_digits,}
\DoxyCodeLine{2042                                         \textcolor{keywordtype}{unsigned} prefix,}
\DoxyCodeLine{2043                                         \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2044                                         W write\_digits) -\/> OutputIt \{}
\DoxyCodeLine{2045   \textcolor{comment}{// Slightly faster check for specs.width == 0 \&\& specs.precision == -\/1.}}
\DoxyCodeLine{2046   \textcolor{keywordflow}{if} ((specs.width | (specs.precision + 1)) == 0) \{}
\DoxyCodeLine{2047     \textcolor{keyword}{auto} it = reserve(out, to\_unsigned(num\_digits) + (prefix >> 24));}
\DoxyCodeLine{2048     \textcolor{keywordflow}{if} (prefix != 0) \{}
\DoxyCodeLine{2049       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} p = prefix \& 0xffffff; p != 0; p >>= 8)}
\DoxyCodeLine{2050         *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(p \& 0xff);}
\DoxyCodeLine{2051     \}}
\DoxyCodeLine{2052     \textcolor{keywordflow}{return} base\_iterator(out, write\_digits(it));}
\DoxyCodeLine{2053   \}}
\DoxyCodeLine{2054   \textcolor{keyword}{auto} data = write\_int\_data<Char>(num\_digits, prefix, specs);}
\DoxyCodeLine{2055   \textcolor{keywordflow}{return} write\_padded<align::right>(}
\DoxyCodeLine{2056       out, specs, data.size, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2057         for (unsigned p = prefix \& 0xffffff; p != 0; p >>= 8)}
\DoxyCodeLine{2058           *it++ = static\_cast<Char>(p \& 0xff);}
\DoxyCodeLine{2059         it = detail::fill\_n(it, data.padding, static\_cast<Char>(\textcolor{stringliteral}{'0'}));}
\DoxyCodeLine{2060         return write\_digits(it);}
\DoxyCodeLine{2061       \});}
\DoxyCodeLine{2062 \}}
\DoxyCodeLine{2063 }
\DoxyCodeLine{2064 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1digit__grouping}{digit\_grouping}} \{}
\DoxyCodeLine{2065  \textcolor{keyword}{private}:}
\DoxyCodeLine{2066   std::string grouping\_;}
\DoxyCodeLine{2067   std::basic\_string<Char> thousands\_sep\_;}
\DoxyCodeLine{2068 }
\DoxyCodeLine{2069   \textcolor{keyword}{struct }next\_state \{}
\DoxyCodeLine{2070     std::string::const\_iterator group;}
\DoxyCodeLine{2071     \textcolor{keywordtype}{int} pos;}
\DoxyCodeLine{2072   \};}
\DoxyCodeLine{2073   next\_state initial\_state()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{grouping\_.begin(), 0\}; \}}
\DoxyCodeLine{2074 }
\DoxyCodeLine{2075   \textcolor{comment}{// Returns the next digit group separator position.}}
\DoxyCodeLine{2076   \textcolor{keywordtype}{int} next(next\_state\& state)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2077     \textcolor{keywordflow}{if} (thousands\_sep\_.empty()) \textcolor{keywordflow}{return} max\_value<int>();}
\DoxyCodeLine{2078     \textcolor{keywordflow}{if} (state.group == grouping\_.end()) \textcolor{keywordflow}{return} state.pos += grouping\_.back();}
\DoxyCodeLine{2079     \textcolor{keywordflow}{if} (*state.group <= 0 || *state.group == max\_value<char>())}
\DoxyCodeLine{2080       \textcolor{keywordflow}{return} max\_value<int>();}
\DoxyCodeLine{2081     state.pos += *state.group++;}
\DoxyCodeLine{2082     \textcolor{keywordflow}{return} state.pos;}
\DoxyCodeLine{2083   \}}
\DoxyCodeLine{2084 }
\DoxyCodeLine{2085  \textcolor{keyword}{public}:}
\DoxyCodeLine{2086   \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1digit__grouping}{digit\_grouping}}(\mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} loc, \textcolor{keywordtype}{bool} localized = \textcolor{keyword}{true}) \{}
\DoxyCodeLine{2087     \textcolor{keywordflow}{if} (!localized) \textcolor{keywordflow}{return};}
\DoxyCodeLine{2088     \textcolor{keyword}{auto} sep = thousands\_sep<Char>(loc);}
\DoxyCodeLine{2089     grouping\_ = sep.grouping;}
\DoxyCodeLine{2090     \textcolor{keywordflow}{if} (sep.thousands\_sep) thousands\_sep\_.assign(1, sep.thousands\_sep);}
\DoxyCodeLine{2091   \}}
\DoxyCodeLine{2092   \mbox{\hyperlink{classdetail_1_1digit__grouping}{digit\_grouping}}(std::string grouping, std::basic\_string<Char> sep)}
\DoxyCodeLine{2093       : grouping\_(std::move(grouping)), thousands\_sep\_(std::move(sep)) \{\}}
\DoxyCodeLine{2094 }
\DoxyCodeLine{2095   \textcolor{keywordtype}{bool} has\_separator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} !thousands\_sep\_.empty(); \}}
\DoxyCodeLine{2096 }
\DoxyCodeLine{2097   \textcolor{keywordtype}{int} count\_separators(\textcolor{keywordtype}{int} num\_digits)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2098     \textcolor{keywordtype}{int} count = 0;}
\DoxyCodeLine{2099     \textcolor{keyword}{auto} state = initial\_state();}
\DoxyCodeLine{2100     \textcolor{keywordflow}{while} (num\_digits > next(state)) ++count;}
\DoxyCodeLine{2101     \textcolor{keywordflow}{return} count;}
\DoxyCodeLine{2102   \}}
\DoxyCodeLine{2103 }
\DoxyCodeLine{2104   \textcolor{comment}{// Applies grouping to digits and write the output to out.}}
\DoxyCodeLine{2105   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Out, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{2106   Out apply(Out out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<C>}} digits)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2107     \textcolor{keyword}{auto} num\_digits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(digits.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}());}
\DoxyCodeLine{2108     \textcolor{keyword}{auto} separators = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<int>}}();}
\DoxyCodeLine{2109     separators.push\_back(0);}
\DoxyCodeLine{2110     \textcolor{keyword}{auto} state = initial\_state();}
\DoxyCodeLine{2111     \textcolor{keywordflow}{while} (\textcolor{keywordtype}{int} i = next(state)) \{}
\DoxyCodeLine{2112       \textcolor{keywordflow}{if} (i >= num\_digits) \textcolor{keywordflow}{break};}
\DoxyCodeLine{2113       separators.push\_back(i);}
\DoxyCodeLine{2114     \}}
\DoxyCodeLine{2115     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0, sep\_index = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(separators.size() -\/ 1);}
\DoxyCodeLine{2116          i < num\_digits; ++i) \{}
\DoxyCodeLine{2117       \textcolor{keywordflow}{if} (num\_digits -\/ i == separators[sep\_index]) \{}
\DoxyCodeLine{2118         out =}
\DoxyCodeLine{2119             copy\_str<Char>(thousands\_sep\_.data(),}
\DoxyCodeLine{2120                            thousands\_sep\_.data() + thousands\_sep\_.size(), out);}
\DoxyCodeLine{2121         -\/-\/sep\_index;}
\DoxyCodeLine{2122       \}}
\DoxyCodeLine{2123       *out++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(digits[to\_unsigned(i)]);}
\DoxyCodeLine{2124     \}}
\DoxyCodeLine{2125     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2126   \}}
\DoxyCodeLine{2127 \};}
\DoxyCodeLine{2128 }
\DoxyCodeLine{2129 \textcolor{comment}{// Writes a decimal integer with digit grouping.}}
\DoxyCodeLine{2130 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2131 \textcolor{keyword}{auto} write\_int(OutputIt out, UInt \mbox{\hyperlink{classdetail_1_1value}{value}}, \textcolor{keywordtype}{unsigned} prefix,}
\DoxyCodeLine{2132                \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2133                \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1digit__grouping}{digit\_grouping<Char>}}\& grouping) -\/> OutputIt \{}
\DoxyCodeLine{2134   \textcolor{keyword}{static\_assert}(std::is\_same<uint64\_or\_128\_t<UInt>, UInt>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2135   \textcolor{keywordtype}{int} num\_digits = count\_digits(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{2136   \textcolor{keywordtype}{char} digits[40];}
\DoxyCodeLine{2137   format\_decimal(digits, \mbox{\hyperlink{classdetail_1_1value}{value}}, num\_digits);}
\DoxyCodeLine{2138   \textcolor{keywordtype}{unsigned} size = to\_unsigned((prefix != 0 ? 1 : 0) + num\_digits +}
\DoxyCodeLine{2139                               grouping.count\_separators(num\_digits));}
\DoxyCodeLine{2140   \textcolor{keywordflow}{return} write\_padded<align::right>(}
\DoxyCodeLine{2141       out, specs, size, size, [\&](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2142         \textcolor{keywordflow}{if} (prefix != 0) \{}
\DoxyCodeLine{2143           \textcolor{keywordtype}{char} sign = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(prefix);}
\DoxyCodeLine{2144           *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(sign);}
\DoxyCodeLine{2145         \}}
\DoxyCodeLine{2146         \textcolor{keywordflow}{return} grouping.apply(it, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(digits, to\_unsigned(num\_digits)));}
\DoxyCodeLine{2147       \});}
\DoxyCodeLine{2148 \}}
\DoxyCodeLine{2149 }
\DoxyCodeLine{2150 \textcolor{comment}{// Writes a localized value.}}
\DoxyCodeLine{2151 FMT\_API \textcolor{keyword}{auto} write\_loc(\mbox{\hyperlink{classappender}{appender}} out, \mbox{\hyperlink{classloc__value}{loc\_value}} value,}
\DoxyCodeLine{2152                        \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<>}}\& specs, locale\_ref loc) -\/> bool;}
\DoxyCodeLine{2153 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2154 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_loc(OutputIt, \mbox{\hyperlink{classloc__value}{loc\_value}}, \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\&,}
\DoxyCodeLine{2155                       locale\_ref) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2156   \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2157 \}}
\DoxyCodeLine{2158 }
\DoxyCodeLine{2159 FMT\_CONSTEXPR \textcolor{keyword}{inline} \textcolor{keywordtype}{void} prefix\_append(\textcolor{keywordtype}{unsigned}\& prefix, \textcolor{keywordtype}{unsigned} value) \{}
\DoxyCodeLine{2160   prefix |= prefix != 0 ? value << 8 : value;}
\DoxyCodeLine{2161   prefix += (1u + (value > 0xff ? 1 : 0)) << 24;}
\DoxyCodeLine{2162 \}}
\DoxyCodeLine{2163 }
\DoxyCodeLine{2164 \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1write__int__arg}{write\_int\_arg}} \{}
\DoxyCodeLine{2165   UInt abs\_value;}
\DoxyCodeLine{2166   \textcolor{keywordtype}{unsigned} prefix;}
\DoxyCodeLine{2167 \};}
\DoxyCodeLine{2168 }
\DoxyCodeLine{2169 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2170 FMT\_CONSTEXPR \textcolor{keyword}{auto} make\_write\_int\_arg(T \mbox{\hyperlink{classdetail_1_1value}{value}}, sign\_t sign)}
\DoxyCodeLine{2171     -\/> \mbox{\hyperlink{structdetail_1_1write__int__arg}{write\_int\_arg<uint32\_or\_64\_or\_128\_t<T>}}> \{}
\DoxyCodeLine{2172   \textcolor{keyword}{auto} prefix = 0u;}
\DoxyCodeLine{2173   \textcolor{keyword}{auto} abs\_value = \textcolor{keyword}{static\_cast<}uint32\_or\_64\_or\_128\_t<T>\textcolor{keyword}{>}(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{2174   \textcolor{keywordflow}{if} (is\_negative(\mbox{\hyperlink{classdetail_1_1value}{value}})) \{}
\DoxyCodeLine{2175     prefix = 0x01000000 | \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{2176     abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{2177   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2178     \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} prefixes[4] = \{0, 0, 0x1000000u | \textcolor{charliteral}{'+'},}
\DoxyCodeLine{2179                                             0x1000000u | \textcolor{charliteral}{' '}\};}
\DoxyCodeLine{2180     prefix = prefixes[sign];}
\DoxyCodeLine{2181   \}}
\DoxyCodeLine{2182   \textcolor{keywordflow}{return} \{abs\_value, prefix\};}
\DoxyCodeLine{2183 \}}
\DoxyCodeLine{2184 }
\DoxyCodeLine{2185 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1loc__writer}{loc\_writer}} \{}
\DoxyCodeLine{2186   buffer\_appender<Char> out;}
\DoxyCodeLine{2187   \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs;}
\DoxyCodeLine{2188   std::basic\_string<Char> sep;}
\DoxyCodeLine{2189   std::string grouping;}
\DoxyCodeLine{2190   std::basic\_string<Char> decimal\_point;}
\DoxyCodeLine{2191 }
\DoxyCodeLine{2192   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{2193   \textcolor{keyword}{auto} operator()(T \mbox{\hyperlink{classdetail_1_1value}{value}}) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2194     \textcolor{keyword}{auto} arg = make\_write\_int\_arg(\mbox{\hyperlink{classdetail_1_1value}{value}}, specs.sign);}
\DoxyCodeLine{2195     write\_int(out, \textcolor{keyword}{static\_cast<}uint64\_or\_128\_t<T>\textcolor{keyword}{>}(arg.abs\_value), arg.prefix,}
\DoxyCodeLine{2196               specs, \mbox{\hyperlink{classdetail_1_1digit__grouping}{digit\_grouping<Char>}}(grouping, sep));}
\DoxyCodeLine{2197     \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2198   \}}
\DoxyCodeLine{2199 }
\DoxyCodeLine{2200   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{2201   \textcolor{keyword}{auto} operator()(T) -\/> \textcolor{keywordtype}{bool} \{}
\DoxyCodeLine{2202     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2203   \}}
\DoxyCodeLine{2204 \};}
\DoxyCodeLine{2205 }
\DoxyCodeLine{2206 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2207 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write\_int(OutputIt out, \mbox{\hyperlink{structdetail_1_1write__int__arg}{write\_int\_arg<T>}} arg,}
\DoxyCodeLine{2208                                         \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2209                                         \mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}}) -\/> OutputIt \{}
\DoxyCodeLine{2210   \textcolor{keyword}{static\_assert}(std::is\_same<T, uint32\_or\_64\_or\_128\_t<T>>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2211   \textcolor{keyword}{auto} abs\_value = arg.abs\_value;}
\DoxyCodeLine{2212   \textcolor{keyword}{auto} prefix = arg.prefix;}
\DoxyCodeLine{2213   \textcolor{keywordflow}{switch} (specs.type) \{}
\DoxyCodeLine{2214   \textcolor{keywordflow}{case} presentation\_type::none:}
\DoxyCodeLine{2215   \textcolor{keywordflow}{case} presentation\_type::dec: \{}
\DoxyCodeLine{2216     \textcolor{keyword}{auto} num\_digits = count\_digits(abs\_value);}
\DoxyCodeLine{2217     \textcolor{keywordflow}{return} write\_int(}
\DoxyCodeLine{2218         out, num\_digits, prefix, specs, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2219           \textcolor{keywordflow}{return} format\_decimal<Char>(it, abs\_value, num\_digits).end;}
\DoxyCodeLine{2220         \});}
\DoxyCodeLine{2221   \}}
\DoxyCodeLine{2222   \textcolor{keywordflow}{case} presentation\_type::hex\_lower:}
\DoxyCodeLine{2223   \textcolor{keywordflow}{case} presentation\_type::hex\_upper: \{}
\DoxyCodeLine{2224     \textcolor{keywordtype}{bool} upper = specs.type == presentation\_type::hex\_upper;}
\DoxyCodeLine{2225     \textcolor{keywordflow}{if} (specs.alt)}
\DoxyCodeLine{2226       prefix\_append(prefix, \textcolor{keywordtype}{unsigned}(upper ? \textcolor{charliteral}{'X'} : \textcolor{charliteral}{'x'}) << 8 | \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2227     \textcolor{keywordtype}{int} num\_digits = count\_digits<4>(abs\_value);}
\DoxyCodeLine{2228     \textcolor{keywordflow}{return} write\_int(}
\DoxyCodeLine{2229         out, num\_digits, prefix, specs, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2230           \textcolor{keywordflow}{return} format\_uint<4, Char>(it, abs\_value, num\_digits, upper);}
\DoxyCodeLine{2231         \});}
\DoxyCodeLine{2232   \}}
\DoxyCodeLine{2233   \textcolor{keywordflow}{case} presentation\_type::bin\_lower:}
\DoxyCodeLine{2234   \textcolor{keywordflow}{case} presentation\_type::bin\_upper: \{}
\DoxyCodeLine{2235     \textcolor{keywordtype}{bool} upper = specs.type == presentation\_type::bin\_upper;}
\DoxyCodeLine{2236     \textcolor{keywordflow}{if} (specs.alt)}
\DoxyCodeLine{2237       prefix\_append(prefix, \textcolor{keywordtype}{unsigned}(upper ? \textcolor{charliteral}{'B'} : \textcolor{charliteral}{'b'}) << 8 | \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2238     \textcolor{keywordtype}{int} num\_digits = count\_digits<1>(abs\_value);}
\DoxyCodeLine{2239     \textcolor{keywordflow}{return} write\_int(out, num\_digits, prefix, specs,}
\DoxyCodeLine{2240                      [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2241                        \textcolor{keywordflow}{return} format\_uint<1, Char>(it, abs\_value, num\_digits);}
\DoxyCodeLine{2242                      \});}
\DoxyCodeLine{2243   \}}
\DoxyCodeLine{2244   \textcolor{keywordflow}{case} presentation\_type::oct: \{}
\DoxyCodeLine{2245     \textcolor{keywordtype}{int} num\_digits = count\_digits<3>(abs\_value);}
\DoxyCodeLine{2246     \textcolor{comment}{// Octal prefix '0' is counted as a digit, so only add it if precision}}
\DoxyCodeLine{2247     \textcolor{comment}{// is not greater than the number of digits.}}
\DoxyCodeLine{2248     \textcolor{keywordflow}{if} (specs.alt \&\& specs.precision <= num\_digits \&\& abs\_value != 0)}
\DoxyCodeLine{2249       prefix\_append(prefix, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2250     \textcolor{keywordflow}{return} write\_int(out, num\_digits, prefix, specs,}
\DoxyCodeLine{2251                      [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2252                        \textcolor{keywordflow}{return} format\_uint<3, Char>(it, abs\_value, num\_digits);}
\DoxyCodeLine{2253                      \});}
\DoxyCodeLine{2254   \}}
\DoxyCodeLine{2255   \textcolor{keywordflow}{case} presentation\_type::chr:}
\DoxyCodeLine{2256     \textcolor{keywordflow}{return} write\_char(out, \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(abs\_value), specs);}
\DoxyCodeLine{2257   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2258     throw\_format\_error(\textcolor{stringliteral}{"{}invalid format specifier"{}});}
\DoxyCodeLine{2259   \}}
\DoxyCodeLine{2260   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2261 \}}
\DoxyCodeLine{2262 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2263 FMT\_CONSTEXPR FMT\_NOINLINE \textcolor{keyword}{auto} write\_int\_noinline(}
\DoxyCodeLine{2264     OutputIt out, write\_int\_arg<T> arg, \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2265     locale\_ref loc) -\/> OutputIt \{}
\DoxyCodeLine{2266   \textcolor{keywordflow}{return} write\_int(out, arg, specs, loc);}
\DoxyCodeLine{2267 \}}
\DoxyCodeLine{2268 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{2269           FMT\_ENABLE\_IF(is\_integral<T>::value \&\&}
\DoxyCodeLine{2270                         !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{2271                         std::is\_same<OutputIt, buffer\_appender<Char>>::value)>}
\DoxyCodeLine{2272 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write(OutputIt out, T value,}
\DoxyCodeLine{2273                                     \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2274                                     locale\_ref loc) -\/> OutputIt \{}
\DoxyCodeLine{2275   \textcolor{keywordflow}{if} (specs.localized \&\& write\_loc(out, value, specs, loc)) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2276   \textcolor{keywordflow}{return} write\_int\_noinline(out, make\_write\_int\_arg(value, specs.sign), specs,}
\DoxyCodeLine{2277                             loc);}
\DoxyCodeLine{2278 \}}
\DoxyCodeLine{2279 \textcolor{comment}{// An inlined version of write used in format string compilation.}}
\DoxyCodeLine{2280 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{2281           FMT\_ENABLE\_IF(is\_integral<T>::value \&\&}
\DoxyCodeLine{2282                         !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{2283                         !std::is\_same<OutputIt, buffer\_appender<Char>>::value)>}
\DoxyCodeLine{2284 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} write(OutputIt out, T value,}
\DoxyCodeLine{2285                                     \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2286                                     locale\_ref loc) -\/> OutputIt \{}
\DoxyCodeLine{2287   \textcolor{keywordflow}{if} (specs.localized \&\& write\_loc(out, value, specs, loc)) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2288   \textcolor{keywordflow}{return} write\_int(out, make\_write\_int\_arg(value, specs.sign), specs, loc);}
\DoxyCodeLine{2289 \}}
\DoxyCodeLine{2290 }
\DoxyCodeLine{2291 \textcolor{comment}{// An output iterator that counts the number of objects written to it and}}
\DoxyCodeLine{2292 \textcolor{comment}{// discards them.}}
\DoxyCodeLine{2293 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1counting__iterator}{counting\_iterator}} \{}
\DoxyCodeLine{2294  \textcolor{keyword}{private}:}
\DoxyCodeLine{2295   \textcolor{keywordtype}{size\_t} count\_;}
\DoxyCodeLine{2296 }
\DoxyCodeLine{2297  \textcolor{keyword}{public}:}
\DoxyCodeLine{2298   \textcolor{keyword}{using }iterator\_category = std::output\_iterator\_tag;}
\DoxyCodeLine{2299   \textcolor{keyword}{using }difference\_type = std::ptrdiff\_t;}
\DoxyCodeLine{2300   \textcolor{keyword}{using }pointer = void;}
\DoxyCodeLine{2301   \textcolor{keyword}{using }reference = void;}
\DoxyCodeLine{2302   FMT\_UNCHECKED\_ITERATOR(\mbox{\hyperlink{classdetail_1_1counting__iterator}{counting\_iterator}});}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304   \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1counting__iterator_1_1value__type}{value\_type}} \{}
\DoxyCodeLine{2305     \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> FMT\_CONSTEXPR \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} T\&) \{\}}
\DoxyCodeLine{2306   \};}
\DoxyCodeLine{2307 }
\DoxyCodeLine{2308   FMT\_CONSTEXPR \mbox{\hyperlink{classdetail_1_1counting__iterator}{counting\_iterator}}() : count\_(0) \{\}}
\DoxyCodeLine{2309 }
\DoxyCodeLine{2310   FMT\_CONSTEXPR \textcolor{keywordtype}{size\_t} count()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} count\_; \}}
\DoxyCodeLine{2311 }
\DoxyCodeLine{2312   FMT\_CONSTEXPR counting\_iterator\& operator++() \{}
\DoxyCodeLine{2313     ++count\_;}
\DoxyCodeLine{2314     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2315   \}}
\DoxyCodeLine{2316   FMT\_CONSTEXPR counting\_iterator operator++(\textcolor{keywordtype}{int}) \{}
\DoxyCodeLine{2317     \textcolor{keyword}{auto} it = *\textcolor{keyword}{this};}
\DoxyCodeLine{2318     ++*\textcolor{keyword}{this};}
\DoxyCodeLine{2319     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2320   \}}
\DoxyCodeLine{2321 }
\DoxyCodeLine{2322   FMT\_CONSTEXPR \textcolor{keyword}{friend} counting\_iterator operator+(counting\_iterator it,}
\DoxyCodeLine{2323                                                    difference\_type n) \{}
\DoxyCodeLine{2324     it.count\_ += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(n);}
\DoxyCodeLine{2325     \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2326   \}}
\DoxyCodeLine{2327 }
\DoxyCodeLine{2328   FMT\_CONSTEXPR value\_type operator*()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \{\}; \}}
\DoxyCodeLine{2329 \};}
\DoxyCodeLine{2330 }
\DoxyCodeLine{2331 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2332 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s,}
\DoxyCodeLine{2333                          \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs) -\/> OutputIt \{}
\DoxyCodeLine{2334   \textcolor{keyword}{auto} data = s.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}();}
\DoxyCodeLine{2335   \textcolor{keyword}{auto} size = s.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}();}
\DoxyCodeLine{2336   \textcolor{keywordflow}{if} (specs.precision >= 0 \&\& to\_unsigned(specs.precision) < size)}
\DoxyCodeLine{2337     size = code\_point\_index(s, to\_unsigned(specs.precision));}
\DoxyCodeLine{2338   \textcolor{keywordtype}{bool} is\_debug = specs.type == presentation\_type::debug;}
\DoxyCodeLine{2339   \textcolor{keywordtype}{size\_t} width = 0;}
\DoxyCodeLine{2340   \textcolor{keywordflow}{if} (specs.width != 0) \{}
\DoxyCodeLine{2341     \textcolor{keywordflow}{if} (is\_debug)}
\DoxyCodeLine{2342       width = write\_escaped\_string(counting\_iterator\{\}, s).count();}
\DoxyCodeLine{2343     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2344       width = compute\_width(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(data, size));}
\DoxyCodeLine{2345   \}}
\DoxyCodeLine{2346   \textcolor{keywordflow}{return} write\_padded(out, specs, size, width,}
\DoxyCodeLine{2347                       [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2348                         \textcolor{keywordflow}{if} (is\_debug) \textcolor{keywordflow}{return} write\_escaped\_string(it, s);}
\DoxyCodeLine{2349                         \textcolor{keywordflow}{return} copy\_str<Char>(data, data + size, it);}
\DoxyCodeLine{2350                       \});}
\DoxyCodeLine{2351 \}}
\DoxyCodeLine{2352 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2353 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out,}
\DoxyCodeLine{2354                          \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view}}<type\_identity\_t<Char>> s,}
\DoxyCodeLine{2355                          \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs, locale\_ref)}
\DoxyCodeLine{2356     -\/> OutputIt \{}
\DoxyCodeLine{2357   \textcolor{keywordflow}{return} write(out, s, specs);}
\DoxyCodeLine{2358 \}}
\DoxyCodeLine{2359 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2360 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} Char* s,}
\DoxyCodeLine{2361                          \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs, locale\_ref)}
\DoxyCodeLine{2362     -\/> OutputIt \{}
\DoxyCodeLine{2363   \textcolor{keywordflow}{return} specs.type != presentation\_type::pointer}
\DoxyCodeLine{2364              ? write(out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(s), specs, \{\})}
\DoxyCodeLine{2365              : write\_ptr<Char>(out, bit\_cast<uintptr\_t>(s), \&specs);}
\DoxyCodeLine{2366 \}}
\DoxyCodeLine{2367 }
\DoxyCodeLine{2368 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{2369           FMT\_ENABLE\_IF(is\_integral<T>::value \&\&}
\DoxyCodeLine{2370                         !std::is\_same<T, bool>::value \&\&}
\DoxyCodeLine{2371                         !std::is\_same<T, Char>::value)>}
\DoxyCodeLine{2372 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{2373   \textcolor{keyword}{auto} abs\_value = \textcolor{keyword}{static\_cast<}uint32\_or\_64\_or\_128\_t<T>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{2374   \textcolor{keywordtype}{bool} negative = is\_negative(value);}
\DoxyCodeLine{2375   \textcolor{comment}{// Don't do -\/abs\_value since it trips unsigned-\/integer-\/overflow sanitizer.}}
\DoxyCodeLine{2376   \textcolor{keywordflow}{if} (negative) abs\_value = \string~abs\_value + 1;}
\DoxyCodeLine{2377   \textcolor{keywordtype}{int} num\_digits = count\_digits(abs\_value);}
\DoxyCodeLine{2378   \textcolor{keyword}{auto} size = (negative ? 1 : 0) + \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(num\_digits);}
\DoxyCodeLine{2379   \textcolor{keyword}{auto} it = reserve(out, size);}
\DoxyCodeLine{2380   \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} ptr = to\_pointer<Char>(it, size)) \{}
\DoxyCodeLine{2381     \textcolor{keywordflow}{if} (negative) *ptr++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{2382     format\_decimal<Char>(ptr, abs\_value, num\_digits);}
\DoxyCodeLine{2383     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2384   \}}
\DoxyCodeLine{2385   \textcolor{keywordflow}{if} (negative) *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{2386   it = format\_decimal<Char>(it, abs\_value, num\_digits).end;}
\DoxyCodeLine{2387   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{2388 \}}
\DoxyCodeLine{2389 }
\DoxyCodeLine{2390 \textcolor{comment}{// DEPRECATED!}}
\DoxyCodeLine{2391 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2392 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_align(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end,}
\DoxyCodeLine{2393                                \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{2394   FMT\_ASSERT(begin != end, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2395   \textcolor{keyword}{auto} align = align::none;}
\DoxyCodeLine{2396   \textcolor{keyword}{auto} p = begin + code\_point\_length(begin);}
\DoxyCodeLine{2397   \textcolor{keywordflow}{if} (end -\/ p <= 0) p = begin;}
\DoxyCodeLine{2398   \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{2399     \textcolor{keywordflow}{switch} (to\_ascii(*p)) \{}
\DoxyCodeLine{2400     \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}:}
\DoxyCodeLine{2401       align = align::left;}
\DoxyCodeLine{2402       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2403     \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}:}
\DoxyCodeLine{2404       align = align::right;}
\DoxyCodeLine{2405       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2406     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\string^'}:}
\DoxyCodeLine{2407       align = align::center;}
\DoxyCodeLine{2408       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2409     \}}
\DoxyCodeLine{2410     \textcolor{keywordflow}{if} (align != align::none) \{}
\DoxyCodeLine{2411       \textcolor{keywordflow}{if} (p != begin) \{}
\DoxyCodeLine{2412         \textcolor{keyword}{auto} c = *begin;}
\DoxyCodeLine{2413         \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\}'}) \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2414         \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\{'}) \{}
\DoxyCodeLine{2415           throw\_format\_error(\textcolor{stringliteral}{"{}invalid fill character '\{'"{}});}
\DoxyCodeLine{2416           \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2417         \}}
\DoxyCodeLine{2418         specs.fill = \{begin, to\_unsigned(p -\/ begin)\};}
\DoxyCodeLine{2419         begin = p + 1;}
\DoxyCodeLine{2420       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2421         ++begin;}
\DoxyCodeLine{2422       \}}
\DoxyCodeLine{2423       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2424     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (p == begin) \{}
\DoxyCodeLine{2425       \textcolor{keywordflow}{break};}
\DoxyCodeLine{2426     \}}
\DoxyCodeLine{2427     p = begin;}
\DoxyCodeLine{2428   \}}
\DoxyCodeLine{2429   specs.align = align;}
\DoxyCodeLine{2430   \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{2431 \}}
\DoxyCodeLine{2432 }
\DoxyCodeLine{2433 \textcolor{comment}{// A floating-\/point presentation format.}}
\DoxyCodeLine{2434 \textcolor{keyword}{enum class} float\_format : \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{2435   general,  \textcolor{comment}{// General: exponent notation or fixed point based on magnitude.}}
\DoxyCodeLine{2436   exp,      \textcolor{comment}{// Exponent notation with the default precision of 6, e.g. 1.2e-\/3.}}
\DoxyCodeLine{2437   fixed,    \textcolor{comment}{// Fixed point with the default precision of 6, e.g. 0.0012.}}
\DoxyCodeLine{2438   hex}
\DoxyCodeLine{2439 \};}
\DoxyCodeLine{2440 }
\DoxyCodeLine{2441 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1float__specs}{float\_specs}} \{}
\DoxyCodeLine{2442   \textcolor{keywordtype}{int} precision;}
\DoxyCodeLine{2443   float\_format format : 8;}
\DoxyCodeLine{2444   sign\_t sign : 8;}
\DoxyCodeLine{2445   \textcolor{keywordtype}{bool} upper : 1;}
\DoxyCodeLine{2446   \textcolor{keywordtype}{bool} locale : 1;}
\DoxyCodeLine{2447   \textcolor{keywordtype}{bool} binary32 : 1;}
\DoxyCodeLine{2448   \textcolor{keywordtype}{bool} showpoint : 1;}
\DoxyCodeLine{2449 \};}
\DoxyCodeLine{2450 }
\DoxyCodeLine{2451 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler = error\_handler, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2452 FMT\_CONSTEXPR \textcolor{keyword}{auto} parse\_float\_type\_spec(\textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2453                                          ErrorHandler\&\& eh = \{\})}
\DoxyCodeLine{2454     -\/> float\_specs \{}
\DoxyCodeLine{2455   \textcolor{keyword}{auto} result = float\_specs();}
\DoxyCodeLine{2456   result.showpoint = specs.alt;}
\DoxyCodeLine{2457   result.locale = specs.localized;}
\DoxyCodeLine{2458   \textcolor{keywordflow}{switch} (specs.type) \{}
\DoxyCodeLine{2459   \textcolor{keywordflow}{case} presentation\_type::none:}
\DoxyCodeLine{2460     result.format = float\_format::general;}
\DoxyCodeLine{2461     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2462   \textcolor{keywordflow}{case} presentation\_type::general\_upper:}
\DoxyCodeLine{2463     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2464     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2465   \textcolor{keywordflow}{case} presentation\_type::general\_lower:}
\DoxyCodeLine{2466     result.format = float\_format::general;}
\DoxyCodeLine{2467     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2468   \textcolor{keywordflow}{case} presentation\_type::exp\_upper:}
\DoxyCodeLine{2469     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2470     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2471   \textcolor{keywordflow}{case} presentation\_type::exp\_lower:}
\DoxyCodeLine{2472     result.format = float\_format::exp;}
\DoxyCodeLine{2473     result.showpoint |= specs.precision != 0;}
\DoxyCodeLine{2474     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2475   \textcolor{keywordflow}{case} presentation\_type::fixed\_upper:}
\DoxyCodeLine{2476     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2477     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2478   \textcolor{keywordflow}{case} presentation\_type::fixed\_lower:}
\DoxyCodeLine{2479     result.format = float\_format::fixed;}
\DoxyCodeLine{2480     result.showpoint |= specs.precision != 0;}
\DoxyCodeLine{2481     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2482   \textcolor{keywordflow}{case} presentation\_type::hexfloat\_upper:}
\DoxyCodeLine{2483     result.upper = \textcolor{keyword}{true};}
\DoxyCodeLine{2484     FMT\_FALLTHROUGH;}
\DoxyCodeLine{2485   \textcolor{keywordflow}{case} presentation\_type::hexfloat\_lower:}
\DoxyCodeLine{2486     result.format = float\_format::hex;}
\DoxyCodeLine{2487     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2488   \textcolor{keywordflow}{default}:}
\DoxyCodeLine{2489     eh.on\_error(\textcolor{stringliteral}{"{}invalid format specifier"{}});}
\DoxyCodeLine{2490     \textcolor{keywordflow}{break};}
\DoxyCodeLine{2491   \}}
\DoxyCodeLine{2492   \textcolor{keywordflow}{return} result;}
\DoxyCodeLine{2493 \}}
\DoxyCodeLine{2494 }
\DoxyCodeLine{2495 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2496 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_nonfinite(OutputIt out, \textcolor{keywordtype}{bool} isnan,}
\DoxyCodeLine{2497                                      \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}} specs,}
\DoxyCodeLine{2498                                      \textcolor{keyword}{const} float\_specs\& fspecs) -\/> OutputIt \{}
\DoxyCodeLine{2499   \textcolor{keyword}{auto} str =}
\DoxyCodeLine{2500       isnan ? (fspecs.upper ? \textcolor{stringliteral}{"{}NAN"{}} : \textcolor{stringliteral}{"{}nan"{}}) : (fspecs.upper ? \textcolor{stringliteral}{"{}INF"{}} : \textcolor{stringliteral}{"{}inf"{}});}
\DoxyCodeLine{2501   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} str\_size = 3;}
\DoxyCodeLine{2502   \textcolor{keyword}{auto} sign = fspecs.sign;}
\DoxyCodeLine{2503   \textcolor{keyword}{auto} size = str\_size + (sign ? 1 : 0);}
\DoxyCodeLine{2504   \textcolor{comment}{// Replace '0'-\/padding with space for non-\/finite values.}}
\DoxyCodeLine{2505   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_zero\_fill =}
\DoxyCodeLine{2506       specs.fill.size() == 1 \&\& *specs.fill.data() == \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{2507   \textcolor{keywordflow}{if} (is\_zero\_fill) specs.fill[0] = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{' '});}
\DoxyCodeLine{2508   \textcolor{keywordflow}{return} write\_padded(out, specs, size, [=](reserve\_iterator<OutputIt> it) \{}
\DoxyCodeLine{2509     \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2510     \textcolor{keywordflow}{return} copy\_str<Char>(str, str + str\_size, it);}
\DoxyCodeLine{2511   \});}
\DoxyCodeLine{2512 \}}
\DoxyCodeLine{2513 }
\DoxyCodeLine{2514 \textcolor{comment}{// A decimal floating-\/point number significand * pow(10, exp).}}
\DoxyCodeLine{2515 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1big__decimal__fp}{big\_decimal\_fp}} \{}
\DoxyCodeLine{2516   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* significand;}
\DoxyCodeLine{2517   \textcolor{keywordtype}{int} significand\_size;}
\DoxyCodeLine{2518   \textcolor{keywordtype}{int} exponent;}
\DoxyCodeLine{2519 \};}
\DoxyCodeLine{2520 }
\DoxyCodeLine{2521 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} get\_significand\_size(\textcolor{keyword}{const} \mbox{\hyperlink{structdetail_1_1big__decimal__fp}{big\_decimal\_fp}}\& f) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2522   \textcolor{keywordflow}{return} f.significand\_size;}
\DoxyCodeLine{2523 \}}
\DoxyCodeLine{2524 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2525 \textcolor{keyword}{inline} \textcolor{keyword}{auto} get\_significand\_size(\textcolor{keyword}{const} dragonbox::decimal\_fp<T>\& f) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{2526   \textcolor{keywordflow}{return} count\_digits(f.significand);}
\DoxyCodeLine{2527 \}}
\DoxyCodeLine{2528 }
\DoxyCodeLine{2529 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{2530 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} write\_significand(OutputIt out, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* significand,}
\DoxyCodeLine{2531                                  \textcolor{keywordtype}{int} significand\_size) -\/> OutputIt \{}
\DoxyCodeLine{2532   \textcolor{keywordflow}{return} copy\_str<Char>(significand, significand + significand\_size, out);}
\DoxyCodeLine{2533 \}}
\DoxyCodeLine{2534 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UInt>}
\DoxyCodeLine{2535 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_significand(OutputIt out, UInt significand,}
\DoxyCodeLine{2536                               \textcolor{keywordtype}{int} significand\_size) -\/> OutputIt \{}
\DoxyCodeLine{2537   \textcolor{keywordflow}{return} format\_decimal<Char>(out, significand, significand\_size).end;}
\DoxyCodeLine{2538 \}}
\DoxyCodeLine{2539 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Grouping>}
\DoxyCodeLine{2540 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_significand(OutputIt out, T significand,}
\DoxyCodeLine{2541                                        \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} exponent,}
\DoxyCodeLine{2542                                        \textcolor{keyword}{const} Grouping\& grouping) -\/> OutputIt \{}
\DoxyCodeLine{2543   \textcolor{keywordflow}{if} (!grouping.has\_separator()) \{}
\DoxyCodeLine{2544     out = write\_significand<Char>(out, significand, significand\_size);}
\DoxyCodeLine{2545     \textcolor{keywordflow}{return} detail::fill\_n(out, exponent, \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'}));}
\DoxyCodeLine{2546   \}}
\DoxyCodeLine{2547   \textcolor{keyword}{auto} buffer = \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}}();}
\DoxyCodeLine{2548   write\_significand<char>(\mbox{\hyperlink{classappender}{appender}}(buffer), significand, significand\_size);}
\DoxyCodeLine{2549   detail::fill\_n(\mbox{\hyperlink{classappender}{appender}}(buffer), exponent, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{2550   \textcolor{keywordflow}{return} grouping.apply(out, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(buffer.data(), buffer.size()));}
\DoxyCodeLine{2551 \}}
\DoxyCodeLine{2552 }
\DoxyCodeLine{2553 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} UInt,}
\DoxyCodeLine{2554           FMT\_ENABLE\_IF(std::is\_integral<UInt>::value)>}
\DoxyCodeLine{2555 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_significand(Char* out, UInt significand, \textcolor{keywordtype}{int} significand\_size,}
\DoxyCodeLine{2556                               \textcolor{keywordtype}{int} integral\_size, Char decimal\_point) -\/> Char* \{}
\DoxyCodeLine{2557   \textcolor{keywordflow}{if} (!decimal\_point)}
\DoxyCodeLine{2558     \textcolor{keywordflow}{return} format\_decimal(out, significand, significand\_size).end;}
\DoxyCodeLine{2559   out += significand\_size + 1;}
\DoxyCodeLine{2560   Char* end = out;}
\DoxyCodeLine{2561   \textcolor{keywordtype}{int} floating\_size = significand\_size -\/ integral\_size;}
\DoxyCodeLine{2562   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = floating\_size / 2; i > 0; -\/-\/i) \{}
\DoxyCodeLine{2563     out -\/= 2;}
\DoxyCodeLine{2564     copy2(out, digits2(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(significand \% 100)));}
\DoxyCodeLine{2565     significand /= 100;}
\DoxyCodeLine{2566   \}}
\DoxyCodeLine{2567   \textcolor{keywordflow}{if} (floating\_size \% 2 != 0) \{}
\DoxyCodeLine{2568     *-\/-\/out = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + significand \% 10);}
\DoxyCodeLine{2569     significand /= 10;}
\DoxyCodeLine{2570   \}}
\DoxyCodeLine{2571   *-\/-\/out = decimal\_point;}
\DoxyCodeLine{2572   format\_decimal(out -\/ integral\_size, significand, integral\_size);}
\DoxyCodeLine{2573   \textcolor{keywordflow}{return} end;}
\DoxyCodeLine{2574 \}}
\DoxyCodeLine{2575 }
\DoxyCodeLine{2576 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} UInt, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{2577           FMT\_ENABLE\_IF(!std::is\_pointer<remove\_cvref\_t<OutputIt>>::value)>}
\DoxyCodeLine{2578 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write\_significand(OutputIt out, UInt significand,}
\DoxyCodeLine{2579                               \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} integral\_size,}
\DoxyCodeLine{2580                               Char decimal\_point) -\/> OutputIt \{}
\DoxyCodeLine{2581   \textcolor{comment}{// Buffer is large enough to hold digits (digits10 + 1) and a decimal point.}}
\DoxyCodeLine{2582   Char buffer[digits10<UInt>() + 2];}
\DoxyCodeLine{2583   \textcolor{keyword}{auto} end = write\_significand(buffer, significand, significand\_size,}
\DoxyCodeLine{2584                                integral\_size, decimal\_point);}
\DoxyCodeLine{2585   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(buffer, end, out);}
\DoxyCodeLine{2586 \}}
\DoxyCodeLine{2587 }
\DoxyCodeLine{2588 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2589 FMT\_CONSTEXPR \textcolor{keyword}{auto} write\_significand(OutputIt out, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* significand,}
\DoxyCodeLine{2590                                      \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} integral\_size,}
\DoxyCodeLine{2591                                      Char decimal\_point) -\/> OutputIt \{}
\DoxyCodeLine{2592   out = detail::copy\_str\_noinline<Char>(significand,}
\DoxyCodeLine{2593                                         significand + integral\_size, out);}
\DoxyCodeLine{2594   \textcolor{keywordflow}{if} (!decimal\_point) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2595   *out++ = decimal\_point;}
\DoxyCodeLine{2596   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(significand + integral\_size,}
\DoxyCodeLine{2597                                          significand + significand\_size, out);}
\DoxyCodeLine{2598 \}}
\DoxyCodeLine{2599 }
\DoxyCodeLine{2600 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Grouping>}
\DoxyCodeLine{2601 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_significand(OutputIt out, T significand,}
\DoxyCodeLine{2602                                        \textcolor{keywordtype}{int} significand\_size, \textcolor{keywordtype}{int} integral\_size,}
\DoxyCodeLine{2603                                        Char decimal\_point,}
\DoxyCodeLine{2604                                        \textcolor{keyword}{const} Grouping\& grouping) -\/> OutputIt \{}
\DoxyCodeLine{2605   \textcolor{keywordflow}{if} (!grouping.has\_separator()) \{}
\DoxyCodeLine{2606     \textcolor{keywordflow}{return} write\_significand(out, significand, significand\_size, integral\_size,}
\DoxyCodeLine{2607                              decimal\_point);}
\DoxyCodeLine{2608   \}}
\DoxyCodeLine{2609   \textcolor{keyword}{auto} buffer = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{2610   write\_significand(buffer\_appender<Char>(buffer), significand,}
\DoxyCodeLine{2611                     significand\_size, integral\_size, decimal\_point);}
\DoxyCodeLine{2612   grouping.apply(}
\DoxyCodeLine{2613       out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(buffer.data(), to\_unsigned(integral\_size)));}
\DoxyCodeLine{2614   \textcolor{keywordflow}{return} detail::copy\_str\_noinline<Char>(buffer.data() + integral\_size,}
\DoxyCodeLine{2615                                          buffer.end(), out);}
\DoxyCodeLine{2616 \}}
\DoxyCodeLine{2617 }
\DoxyCodeLine{2618 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} DecimalFP, \textcolor{keyword}{typename} Char,}
\DoxyCodeLine{2619           \textcolor{keyword}{typename} Grouping = digit\_grouping<Char>>}
\DoxyCodeLine{2620 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} do\_write\_float(OutputIt out, \textcolor{keyword}{const} DecimalFP\& f,}
\DoxyCodeLine{2621                                     \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2622                                     float\_specs fspecs, locale\_ref loc)}
\DoxyCodeLine{2623     -\/> OutputIt \{}
\DoxyCodeLine{2624   \textcolor{keyword}{auto} significand = f.significand;}
\DoxyCodeLine{2625   \textcolor{keywordtype}{int} significand\_size = get\_significand\_size(f);}
\DoxyCodeLine{2626   \textcolor{keyword}{const} Char zero = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{2627   \textcolor{keyword}{auto} sign = fspecs.sign;}
\DoxyCodeLine{2628   \textcolor{keywordtype}{size\_t} size = to\_unsigned(significand\_size) + (sign ? 1 : 0);}
\DoxyCodeLine{2629   \textcolor{keyword}{using }iterator = reserve\_iterator<OutputIt>;}
\DoxyCodeLine{2630 }
\DoxyCodeLine{2631   Char decimal\_point =}
\DoxyCodeLine{2632       fspecs.locale ? detail::decimal\_point<Char>(loc) : static\_cast<Char>(\textcolor{stringliteral}{'.'});}
\DoxyCodeLine{2633 }
\DoxyCodeLine{2634   \textcolor{keywordtype}{int} output\_exp = f.exponent + significand\_size -\/ 1;}
\DoxyCodeLine{2635   \textcolor{keyword}{auto} use\_exp\_format = [=]() \{}
\DoxyCodeLine{2636     \textcolor{keywordflow}{if} (fspecs.format == float\_format::exp) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2637     \textcolor{keywordflow}{if} (fspecs.format != float\_format::general) \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2638     \textcolor{comment}{// Use the fixed notation if the exponent is in [exp\_lower, exp\_upper),}}
\DoxyCodeLine{2639     \textcolor{comment}{// e.g. 0.0001 instead of 1e-\/04. Otherwise use the exponent notation.}}
\DoxyCodeLine{2640     \textcolor{keyword}{const} \textcolor{keywordtype}{int} exp\_lower = -\/4, exp\_upper = 16;}
\DoxyCodeLine{2641     \textcolor{keywordflow}{return} output\_exp < exp\_lower ||}
\DoxyCodeLine{2642            output\_exp >= (fspecs.precision > 0 ? fspecs.precision : exp\_upper);}
\DoxyCodeLine{2643   \};}
\DoxyCodeLine{2644   \textcolor{keywordflow}{if} (use\_exp\_format()) \{}
\DoxyCodeLine{2645     \textcolor{keywordtype}{int} num\_zeros = 0;}
\DoxyCodeLine{2646     \textcolor{keywordflow}{if} (fspecs.showpoint) \{}
\DoxyCodeLine{2647       num\_zeros = fspecs.precision -\/ significand\_size;}
\DoxyCodeLine{2648       \textcolor{keywordflow}{if} (num\_zeros < 0) num\_zeros = 0;}
\DoxyCodeLine{2649       size += to\_unsigned(num\_zeros);}
\DoxyCodeLine{2650     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (significand\_size == 1) \{}
\DoxyCodeLine{2651       decimal\_point = Char();}
\DoxyCodeLine{2652     \}}
\DoxyCodeLine{2653     \textcolor{keyword}{auto} abs\_output\_exp = output\_exp >= 0 ? output\_exp : -\/output\_exp;}
\DoxyCodeLine{2654     \textcolor{keywordtype}{int} exp\_digits = 2;}
\DoxyCodeLine{2655     \textcolor{keywordflow}{if} (abs\_output\_exp >= 100) exp\_digits = abs\_output\_exp >= 1000 ? 4 : 3;}
\DoxyCodeLine{2656 }
\DoxyCodeLine{2657     size += to\_unsigned((decimal\_point ? 1 : 0) + 2 + exp\_digits);}
\DoxyCodeLine{2658     \textcolor{keywordtype}{char} exp\_char = fspecs.upper ? \textcolor{charliteral}{'E'} : \textcolor{charliteral}{'e'};}
\DoxyCodeLine{2659     \textcolor{keyword}{auto} write = [=](iterator it) \{}
\DoxyCodeLine{2660       \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2661       \textcolor{comment}{// Insert a decimal point after the first digit and add an exponent.}}
\DoxyCodeLine{2662       it = write\_significand(it, significand, significand\_size, 1,}
\DoxyCodeLine{2663                              decimal\_point);}
\DoxyCodeLine{2664       \textcolor{keywordflow}{if} (num\_zeros > 0) it = detail::fill\_n(it, num\_zeros, zero);}
\DoxyCodeLine{2665       *it++ = \textcolor{keyword}{static\_cast<}Char\textcolor{keyword}{>}(exp\_char);}
\DoxyCodeLine{2666       \textcolor{keywordflow}{return} write\_exponent<Char>(output\_exp, it);}
\DoxyCodeLine{2667     \};}
\DoxyCodeLine{2668     \textcolor{keywordflow}{return} specs.width > 0 ? write\_padded<align::right>(out, specs, size, write)}
\DoxyCodeLine{2669                            : base\_iterator(out, write(reserve(out, size)));}
\DoxyCodeLine{2670   \}}
\DoxyCodeLine{2671 }
\DoxyCodeLine{2672   \textcolor{keywordtype}{int} exp = f.exponent + significand\_size;}
\DoxyCodeLine{2673   \textcolor{keywordflow}{if} (f.exponent >= 0) \{}
\DoxyCodeLine{2674     \textcolor{comment}{// 1234e5 -\/> 123400000[.0+]}}
\DoxyCodeLine{2675     size += to\_unsigned(f.exponent);}
\DoxyCodeLine{2676     \textcolor{keywordtype}{int} num\_zeros = fspecs.precision -\/ exp;}
\DoxyCodeLine{2677     abort\_fuzzing\_if(num\_zeros > 5000);}
\DoxyCodeLine{2678     \textcolor{keywordflow}{if} (fspecs.showpoint) \{}
\DoxyCodeLine{2679       ++size;}
\DoxyCodeLine{2680       \textcolor{keywordflow}{if} (num\_zeros <= 0 \&\& fspecs.format != float\_format::fixed) num\_zeros = 0;}
\DoxyCodeLine{2681       \textcolor{keywordflow}{if} (num\_zeros > 0) size += to\_unsigned(num\_zeros);}
\DoxyCodeLine{2682     \}}
\DoxyCodeLine{2683     \textcolor{keyword}{auto} grouping = Grouping(loc, fspecs.locale);}
\DoxyCodeLine{2684     size += to\_unsigned(grouping.count\_separators(exp));}
\DoxyCodeLine{2685     \textcolor{keywordflow}{return} write\_padded<align::right>(out, specs, size, [\&](iterator it) \{}
\DoxyCodeLine{2686       \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2687       it = write\_significand<Char>(it, significand, significand\_size,}
\DoxyCodeLine{2688                                    f.exponent, grouping);}
\DoxyCodeLine{2689       \textcolor{keywordflow}{if} (!fspecs.showpoint) \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2690       *it++ = decimal\_point;}
\DoxyCodeLine{2691       \textcolor{keywordflow}{return} num\_zeros > 0 ? detail::fill\_n(it, num\_zeros, zero) : it;}
\DoxyCodeLine{2692     \});}
\DoxyCodeLine{2693   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exp > 0) \{}
\DoxyCodeLine{2694     \textcolor{comment}{// 1234e-\/2 -\/> 12.34[0+]}}
\DoxyCodeLine{2695     \textcolor{keywordtype}{int} num\_zeros = fspecs.showpoint ? fspecs.precision -\/ significand\_size : 0;}
\DoxyCodeLine{2696     size += 1 + to\_unsigned(num\_zeros > 0 ? num\_zeros : 0);}
\DoxyCodeLine{2697     \textcolor{keyword}{auto} grouping = Grouping(loc, fspecs.locale);}
\DoxyCodeLine{2698     size += to\_unsigned(grouping.count\_separators(exp));}
\DoxyCodeLine{2699     \textcolor{keywordflow}{return} write\_padded<align::right>(out, specs, size, [\&](iterator it) \{}
\DoxyCodeLine{2700       \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2701       it = write\_significand(it, significand, significand\_size, exp,}
\DoxyCodeLine{2702                              decimal\_point, grouping);}
\DoxyCodeLine{2703       \textcolor{keywordflow}{return} num\_zeros > 0 ? detail::fill\_n(it, num\_zeros, zero) : it;}
\DoxyCodeLine{2704     \});}
\DoxyCodeLine{2705   \}}
\DoxyCodeLine{2706   \textcolor{comment}{// 1234e-\/6 -\/> 0.001234}}
\DoxyCodeLine{2707   \textcolor{keywordtype}{int} num\_zeros = -\/exp;}
\DoxyCodeLine{2708   \textcolor{keywordflow}{if} (significand\_size == 0 \&\& fspecs.precision >= 0 \&\&}
\DoxyCodeLine{2709       fspecs.precision < num\_zeros) \{}
\DoxyCodeLine{2710     num\_zeros = fspecs.precision;}
\DoxyCodeLine{2711   \}}
\DoxyCodeLine{2712   \textcolor{keywordtype}{bool} pointy = num\_zeros != 0 || significand\_size != 0 || fspecs.showpoint;}
\DoxyCodeLine{2713   size += 1 + (pointy ? 1 : 0) + to\_unsigned(num\_zeros);}
\DoxyCodeLine{2714   \textcolor{keywordflow}{return} write\_padded<align::right>(out, specs, size, [\&](iterator it) \{}
\DoxyCodeLine{2715     \textcolor{keywordflow}{if} (sign) *it++ = detail::sign<Char>(sign);}
\DoxyCodeLine{2716     *it++ = zero;}
\DoxyCodeLine{2717     \textcolor{keywordflow}{if} (!pointy) \textcolor{keywordflow}{return} it;}
\DoxyCodeLine{2718     *it++ = decimal\_point;}
\DoxyCodeLine{2719     it = detail::fill\_n(it, num\_zeros, zero);}
\DoxyCodeLine{2720     \textcolor{keywordflow}{return} write\_significand<Char>(it, significand, significand\_size);}
\DoxyCodeLine{2721   \});}
\DoxyCodeLine{2722 \}}
\DoxyCodeLine{2723 }
\DoxyCodeLine{2724 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1fallback__digit__grouping}{fallback\_digit\_grouping}} \{}
\DoxyCodeLine{2725  \textcolor{keyword}{public}:}
\DoxyCodeLine{2726   \textcolor{keyword}{constexpr} \mbox{\hyperlink{classdetail_1_1fallback__digit__grouping}{fallback\_digit\_grouping}}(\mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}}, \textcolor{keywordtype}{bool}) \{\}}
\DoxyCodeLine{2727 }
\DoxyCodeLine{2728   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} has\_separator()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}}
\DoxyCodeLine{2729 }
\DoxyCodeLine{2730   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} count\_separators(\textcolor{keywordtype}{int})\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} 0; \}}
\DoxyCodeLine{2731 }
\DoxyCodeLine{2732   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Out, \textcolor{keyword}{typename} C>}
\DoxyCodeLine{2733   \textcolor{keyword}{constexpr} Out apply(Out out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<C>}})\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2734     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2735   \}}
\DoxyCodeLine{2736 \};}
\DoxyCodeLine{2737 }
\DoxyCodeLine{2738 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} DecimalFP, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{2739 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_float(OutputIt out, \textcolor{keyword}{const} DecimalFP\& f,}
\DoxyCodeLine{2740                                  \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs,}
\DoxyCodeLine{2741                                  \mbox{\hyperlink{structdetail_1_1float__specs}{float\_specs}} fspecs, \mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} loc)}
\DoxyCodeLine{2742     -\/> OutputIt \{}
\DoxyCodeLine{2743   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{2744     \textcolor{keywordflow}{return} do\_write\_float<OutputIt, DecimalFP, Char,}
\DoxyCodeLine{2745                           \mbox{\hyperlink{classdetail_1_1fallback__digit__grouping}{fallback\_digit\_grouping<Char>}}>(out, f, specs, fspecs,}
\DoxyCodeLine{2746                                                          loc);}
\DoxyCodeLine{2747   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2748     \textcolor{keywordflow}{return} do\_write\_float(out, f, specs, fspecs, loc);}
\DoxyCodeLine{2749   \}}
\DoxyCodeLine{2750 \}}
\DoxyCodeLine{2751 }
\DoxyCodeLine{2752 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} isnan(T value) \{}
\DoxyCodeLine{2753   \textcolor{keywordflow}{return} !(value >= value);  \textcolor{comment}{// std::isnan doesn't support \_\_float128.}}
\DoxyCodeLine{2754 \}}
\DoxyCodeLine{2755 }
\DoxyCodeLine{2756 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Enable = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{2757 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__isfinite}{has\_isfinite}} : std::false\_type \{\};}
\DoxyCodeLine{2758 }
\DoxyCodeLine{2759 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2760 \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1has__isfinite}{has\_isfinite}}<T, enable\_if\_t<sizeof(std::isfinite(T())) != 0>>}
\DoxyCodeLine{2761     : std::true\_type \{\};}
\DoxyCodeLine{2762 }
\DoxyCodeLine{2763 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{float}ing\_po\textcolor{keywordtype}{int}<T>::value\&\&}
\DoxyCodeLine{2764                                         has\_isfinite<T>::value)>}
\DoxyCodeLine{2765 FMT\_CONSTEXPR20 \textcolor{keywordtype}{bool} isfinite(T \mbox{\hyperlink{classdetail_1_1value}{value}}) \{}
\DoxyCodeLine{2766   \textcolor{keyword}{constexpr} T inf = T(std::numeric\_limits<double>::infinity());}
\DoxyCodeLine{2767   \textcolor{keywordflow}{if} (is\_constant\_evaluated())}
\DoxyCodeLine{2768     \textcolor{keywordflow}{return} !detail::isnan(\mbox{\hyperlink{classdetail_1_1value}{value}}) \&\& \mbox{\hyperlink{classdetail_1_1value}{value < inf \&\& value >}} -\/inf;}
\DoxyCodeLine{2769   \textcolor{keywordflow}{return} std::isfinite(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{2770 \}}
\DoxyCodeLine{2771 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!has\_isfinite<T>::value)>}
\DoxyCodeLine{2772 FMT\_CONSTEXPR \textcolor{keywordtype}{bool} isfinite(T value) \{}
\DoxyCodeLine{2773   T inf = T(std::numeric\_limits<double>::infinity());}
\DoxyCodeLine{2774   \textcolor{comment}{// std::isfinite doesn't support \_\_float128.}}
\DoxyCodeLine{2775   \textcolor{keywordflow}{return} !detail::isnan(value) \&\& value < inf \&\& value > -\/inf;}
\DoxyCodeLine{2776 \}}
\DoxyCodeLine{2777 }
\DoxyCodeLine{2778 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{float}ing\_po\textcolor{keywordtype}{int}<T>::value)>}
\DoxyCodeLine{2779 FMT\_INLINE FMT\_CONSTEXPR \textcolor{keywordtype}{bool} signbit(T value) \{}
\DoxyCodeLine{2780   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \{}
\DoxyCodeLine{2781 \textcolor{preprocessor}{\#ifdef \_\_cpp\_if\_constexpr}}
\DoxyCodeLine{2782     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::numeric\_limits<double>::is\_iec559) \{}
\DoxyCodeLine{2783       \textcolor{keyword}{auto} bits = detail::bit\_cast<uint64\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{2784       \textcolor{keywordflow}{return} (bits >> (num\_bits<uint64\_t>() -\/ 1)) != 0;}
\DoxyCodeLine{2785     \}}
\DoxyCodeLine{2786 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{2787   \}}
\DoxyCodeLine{2788   \textcolor{keywordflow}{return} std::signbit(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{2789 \}}
\DoxyCodeLine{2790 }
\DoxyCodeLine{2791 \textcolor{keyword}{inline} FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} adjust\_precision(\textcolor{keywordtype}{int}\& precision, \textcolor{keywordtype}{int} exp10) \{}
\DoxyCodeLine{2792   \textcolor{comment}{// Adjust fixed precision by exponent because it is relative to decimal}}
\DoxyCodeLine{2793   \textcolor{comment}{// point.}}
\DoxyCodeLine{2794   \textcolor{keywordflow}{if} (exp10 > 0 \&\& precision > max\_value<int>() -\/ exp10)}
\DoxyCodeLine{2795     FMT\_THROW(format\_error(\textcolor{stringliteral}{"{}number is too big"{}}));}
\DoxyCodeLine{2796   precision += exp10;}
\DoxyCodeLine{2797 \}}
\DoxyCodeLine{2798 }
\DoxyCodeLine{2799 \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1bigint}{bigint}} \{}
\DoxyCodeLine{2800  \textcolor{keyword}{private}:}
\DoxyCodeLine{2801   \textcolor{comment}{// A bigint is stored as an array of bigits (big digits), with bigit at index}}
\DoxyCodeLine{2802   \textcolor{comment}{// 0 being the least significant one.}}
\DoxyCodeLine{2803   \textcolor{keyword}{using }bigit = uint32\_t;}
\DoxyCodeLine{2804   \textcolor{keyword}{using }double\_bigit = uint64\_t;}
\DoxyCodeLine{2805   \textcolor{keyword}{enum} \{ bigits\_capacity = 32 \};}
\DoxyCodeLine{2806   \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<bigit, bigits\_capacity>}} bigits\_;}
\DoxyCodeLine{2807   \textcolor{keywordtype}{int} exp\_;}
\DoxyCodeLine{2808 }
\DoxyCodeLine{2809   FMT\_CONSTEXPR20 bigit operator[](\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2810     \textcolor{keywordflow}{return} bigits\_[to\_unsigned(index)];}
\DoxyCodeLine{2811   \}}
\DoxyCodeLine{2812   FMT\_CONSTEXPR20 bigit\& operator[](\textcolor{keywordtype}{int} index) \{}
\DoxyCodeLine{2813     \textcolor{keywordflow}{return} bigits\_[to\_unsigned(index)];}
\DoxyCodeLine{2814   \}}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{const} \textcolor{keywordtype}{int} bigit\_bits = num\_bits<bigit>();}
\DoxyCodeLine{2817 }
\DoxyCodeLine{2818   \textcolor{keyword}{friend} \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{classdetail_1_1bigint}{bigint}}>;}
\DoxyCodeLine{2819 }
\DoxyCodeLine{2820   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} subtract\_bigits(\textcolor{keywordtype}{int} index, bigit other, bigit\& borrow) \{}
\DoxyCodeLine{2821     \textcolor{keyword}{auto} result = \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}((*this)[index]) -\/ other -\/ borrow;}
\DoxyCodeLine{2822     (*this)[index] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result);}
\DoxyCodeLine{2823     borrow = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result >> (bigit\_bits * 2 -\/ 1));}
\DoxyCodeLine{2824   \}}
\DoxyCodeLine{2825 }
\DoxyCodeLine{2826   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} remove\_leading\_zeros() \{}
\DoxyCodeLine{2827     \textcolor{keywordtype}{int} num\_bigits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()) -\/ 1;}
\DoxyCodeLine{2828     \textcolor{keywordflow}{while} (num\_bigits > 0 \&\& (*\textcolor{keyword}{this})[num\_bigits] == 0) -\/-\/num\_bigits;}
\DoxyCodeLine{2829     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(to\_unsigned(num\_bigits + 1));}
\DoxyCodeLine{2830   \}}
\DoxyCodeLine{2831 }
\DoxyCodeLine{2832   \textcolor{comment}{// Computes *this -\/= other assuming aligned bigints and *this >= other.}}
\DoxyCodeLine{2833   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} subtract\_aligned(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& other) \{}
\DoxyCodeLine{2834     FMT\_ASSERT(other.exp\_ >= exp\_, \textcolor{stringliteral}{"{}unaligned bigints"{}});}
\DoxyCodeLine{2835     FMT\_ASSERT(compare(*\textcolor{keyword}{this}, other) >= 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2836     bigit borrow = 0;}
\DoxyCodeLine{2837     \textcolor{keywordtype}{int} i = other.exp\_ -\/ exp\_;}
\DoxyCodeLine{2838     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} j = 0, n = other.bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}(); j != n; ++i, ++j)}
\DoxyCodeLine{2839       subtract\_bigits(i, other.bigits\_[j], borrow);}
\DoxyCodeLine{2840     \textcolor{keywordflow}{while} (borrow > 0) subtract\_bigits(i, 0, borrow);}
\DoxyCodeLine{2841     remove\_leading\_zeros();}
\DoxyCodeLine{2842   \}}
\DoxyCodeLine{2843 }
\DoxyCodeLine{2844   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} multiply(uint32\_t \mbox{\hyperlink{classdetail_1_1value}{value}}) \{}
\DoxyCodeLine{2845     \textcolor{keyword}{const} double\_bigit wide\_value = \mbox{\hyperlink{classdetail_1_1value}{value}};}
\DoxyCodeLine{2846     bigit carry = 0;}
\DoxyCodeLine{2847     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, n = bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}(); i < n; ++i) \{}
\DoxyCodeLine{2848       double\_bigit result = bigits\_[i] * wide\_value + carry;}
\DoxyCodeLine{2849       bigits\_[i] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result);}
\DoxyCodeLine{2850       carry = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result >> bigit\_bits);}
\DoxyCodeLine{2851     \}}
\DoxyCodeLine{2852     \textcolor{keywordflow}{if} (carry != 0) bigits\_.push\_back(carry);}
\DoxyCodeLine{2853   \}}
\DoxyCodeLine{2854 }
\DoxyCodeLine{2855   \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt, FMT\_ENABLE\_IF(std::is\_same<UInt, u\textcolor{keywordtype}{int}64\_t>::value ||}
\DoxyCodeLine{2856                                          std::is\_same<UInt, u\textcolor{keywordtype}{int}128\_t>::value)>}
\DoxyCodeLine{2857   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} multiply(UInt \mbox{\hyperlink{classdetail_1_1value}{value}}) \{}
\DoxyCodeLine{2858     \textcolor{keyword}{using }half\_uint =}
\DoxyCodeLine{2859         conditional\_t<std::is\_same<UInt, uint128\_t>::value, uint64\_t, uint32\_t>;}
\DoxyCodeLine{2860     \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = num\_bits<half\_uint>() -\/ bigit\_bits;}
\DoxyCodeLine{2861     \textcolor{keyword}{const} UInt lower = \textcolor{keyword}{static\_cast<}half\_uint\textcolor{keyword}{>}(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{2862     \textcolor{keyword}{const} UInt upper = \mbox{\hyperlink{classdetail_1_1value}{value}} >> num\_bits<half\_uint>();}
\DoxyCodeLine{2863     UInt carry = 0;}
\DoxyCodeLine{2864     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, n = bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}(); i < n; ++i) \{}
\DoxyCodeLine{2865       UInt result = lower * bigits\_[i] + \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(carry);}
\DoxyCodeLine{2866       carry = (upper * bigits\_[i] << shift) + (result >> bigit\_bits) +}
\DoxyCodeLine{2867               (carry >> bigit\_bits);}
\DoxyCodeLine{2868       bigits\_[i] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(result);}
\DoxyCodeLine{2869     \}}
\DoxyCodeLine{2870     \textcolor{keywordflow}{while} (carry != 0) \{}
\DoxyCodeLine{2871       bigits\_.push\_back(\textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(carry));}
\DoxyCodeLine{2872       carry >>= bigit\_bits;}
\DoxyCodeLine{2873     \}}
\DoxyCodeLine{2874   \}}
\DoxyCodeLine{2875 }
\DoxyCodeLine{2876   \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt, FMT\_ENABLE\_IF(std::is\_same<UInt, u\textcolor{keywordtype}{int}64\_t>::value ||}
\DoxyCodeLine{2877                                          std::is\_same<UInt, u\textcolor{keywordtype}{int}128\_t>::value)>}
\DoxyCodeLine{2878   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} assign(UInt n) \{}
\DoxyCodeLine{2879     \textcolor{keywordtype}{size\_t} num\_bigits = 0;}
\DoxyCodeLine{2880     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{2881       bigits\_[num\_bigits++] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(n);}
\DoxyCodeLine{2882       n >>= bigit\_bits;}
\DoxyCodeLine{2883     \} \textcolor{keywordflow}{while} (n != 0);}
\DoxyCodeLine{2884     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(num\_bigits);}
\DoxyCodeLine{2885     exp\_ = 0;}
\DoxyCodeLine{2886   \}}
\DoxyCodeLine{2887 }
\DoxyCodeLine{2888  \textcolor{keyword}{public}:}
\DoxyCodeLine{2889   FMT\_CONSTEXPR20 \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}() : exp\_(0) \{\}}
\DoxyCodeLine{2890   \textcolor{keyword}{explicit} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}(uint64\_t n) \{ assign(n); \}}
\DoxyCodeLine{2891 }
\DoxyCodeLine{2892   \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2893   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{2894 }
\DoxyCodeLine{2895   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} assign(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& other) \{}
\DoxyCodeLine{2896     \textcolor{keyword}{auto} size = other.bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}();}
\DoxyCodeLine{2897     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(size);}
\DoxyCodeLine{2898     \textcolor{keyword}{auto} \mbox{\hyperlink{structdetail_1_1data}{data}} = other.bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}();}
\DoxyCodeLine{2899     copy\_str<bigit>(\mbox{\hyperlink{structdetail_1_1data}{data}}, \mbox{\hyperlink{structdetail_1_1data}{data}} + size, bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}());}
\DoxyCodeLine{2900     exp\_ = other.exp\_;}
\DoxyCodeLine{2901   \}}
\DoxyCodeLine{2902 }
\DoxyCodeLine{2903   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} operator=(Int n) \{}
\DoxyCodeLine{2904     FMT\_ASSERT(n > 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2905     assign(uint64\_or\_128\_t<Int>(n));}
\DoxyCodeLine{2906   \}}
\DoxyCodeLine{2907 }
\DoxyCodeLine{2908   FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} num\_bigits()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{2909     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()) + exp\_;}
\DoxyCodeLine{2910   \}}
\DoxyCodeLine{2911 }
\DoxyCodeLine{2912   FMT\_NOINLINE FMT\_CONSTEXPR20 \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& operator<<=(\textcolor{keywordtype}{int} shift) \{}
\DoxyCodeLine{2913     FMT\_ASSERT(shift >= 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2914     exp\_ += shift / bigit\_bits;}
\DoxyCodeLine{2915     shift \%= bigit\_bits;}
\DoxyCodeLine{2916     \textcolor{keywordflow}{if} (shift == 0) \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2917     bigit carry = 0;}
\DoxyCodeLine{2918     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0, n = bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}(); i < n; ++i) \{}
\DoxyCodeLine{2919       bigit c = bigits\_[i] >> (bigit\_bits -\/ shift);}
\DoxyCodeLine{2920       bigits\_[i] = (bigits\_[i] << shift) + carry;}
\DoxyCodeLine{2921       carry = c;}
\DoxyCodeLine{2922     \}}
\DoxyCodeLine{2923     \textcolor{keywordflow}{if} (carry != 0) bigits\_.push\_back(carry);}
\DoxyCodeLine{2924     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2925   \}}
\DoxyCodeLine{2926 }
\DoxyCodeLine{2927   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> FMT\_CONSTEXPR20 \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& operator*=(Int \mbox{\hyperlink{classdetail_1_1value}{value}}) \{}
\DoxyCodeLine{2928     FMT\_ASSERT(\mbox{\hyperlink{classdetail_1_1value}{value}} > 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2929     multiply(uint32\_or\_64\_or\_128\_t<Int>(\mbox{\hyperlink{classdetail_1_1value}{value}}));}
\DoxyCodeLine{2930     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{2931   \}}
\DoxyCodeLine{2932 }
\DoxyCodeLine{2933   \textcolor{keyword}{friend} FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} compare(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& lhs, \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& rhs) \{}
\DoxyCodeLine{2934     \textcolor{keywordtype}{int} num\_lhs\_bigits = lhs.num\_bigits(), num\_rhs\_bigits = rhs.num\_bigits();}
\DoxyCodeLine{2935     \textcolor{keywordflow}{if} (num\_lhs\_bigits != num\_rhs\_bigits)}
\DoxyCodeLine{2936       \textcolor{keywordflow}{return} num\_lhs\_bigits > num\_rhs\_bigits ? 1 : -\/1;}
\DoxyCodeLine{2937     \textcolor{keywordtype}{int} i = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(lhs.bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()) -\/ 1;}
\DoxyCodeLine{2938     \textcolor{keywordtype}{int} j = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(rhs.bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()) -\/ 1;}
\DoxyCodeLine{2939     \textcolor{keywordtype}{int} end = i -\/ j;}
\DoxyCodeLine{2940     \textcolor{keywordflow}{if} (end < 0) end = 0;}
\DoxyCodeLine{2941     \textcolor{keywordflow}{for} (; i >= end; -\/-\/i, -\/-\/j) \{}
\DoxyCodeLine{2942       bigit lhs\_bigit = lhs[i], rhs\_bigit = rhs[j];}
\DoxyCodeLine{2943       \textcolor{keywordflow}{if} (lhs\_bigit != rhs\_bigit) \textcolor{keywordflow}{return} lhs\_bigit > rhs\_bigit ? 1 : -\/1;}
\DoxyCodeLine{2944     \}}
\DoxyCodeLine{2945     \textcolor{keywordflow}{if} (i != j) \textcolor{keywordflow}{return} i > j ? 1 : -\/1;}
\DoxyCodeLine{2946     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{2947   \}}
\DoxyCodeLine{2948 }
\DoxyCodeLine{2949   \textcolor{comment}{// Returns compare(lhs1 + lhs2, rhs).}}
\DoxyCodeLine{2950   \textcolor{keyword}{friend} FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} add\_compare(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& lhs1, \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& lhs2,}
\DoxyCodeLine{2951                                          \textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& rhs) \{}
\DoxyCodeLine{2952     \textcolor{keyword}{auto} minimum = [](\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{ \textcolor{keywordflow}{return} a < b ? a : b; \};}
\DoxyCodeLine{2953     \textcolor{keyword}{auto} maximum = [](\textcolor{keywordtype}{int} a, \textcolor{keywordtype}{int} b) \{ \textcolor{keywordflow}{return} a > b ? a : b; \};}
\DoxyCodeLine{2954     \textcolor{keywordtype}{int} max\_lhs\_bigits = maximum(lhs1.num\_bigits(), lhs2.num\_bigits());}
\DoxyCodeLine{2955     \textcolor{keywordtype}{int} num\_rhs\_bigits = rhs.num\_bigits();}
\DoxyCodeLine{2956     \textcolor{keywordflow}{if} (max\_lhs\_bigits + 1 < num\_rhs\_bigits) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2957     \textcolor{keywordflow}{if} (max\_lhs\_bigits > num\_rhs\_bigits) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2958     \textcolor{keyword}{auto} get\_bigit = [](\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& n, \textcolor{keywordtype}{int} i) -\/> bigit \{}
\DoxyCodeLine{2959       \textcolor{keywordflow}{return} i >= n.exp\_ \&\& i < n.num\_bigits() ? n[i -\/ n.exp\_] : 0;}
\DoxyCodeLine{2960     \};}
\DoxyCodeLine{2961     double\_bigit borrow = 0;}
\DoxyCodeLine{2962     \textcolor{keywordtype}{int} min\_exp = minimum(minimum(lhs1.exp\_, lhs2.exp\_), rhs.exp\_);}
\DoxyCodeLine{2963     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = num\_rhs\_bigits -\/ 1; i >= min\_exp; -\/-\/i) \{}
\DoxyCodeLine{2964       double\_bigit sum =}
\DoxyCodeLine{2965           \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}(get\_bigit(lhs1, i)) + get\_bigit(lhs2, i);}
\DoxyCodeLine{2966       bigit rhs\_bigit = get\_bigit(rhs, i);}
\DoxyCodeLine{2967       \textcolor{keywordflow}{if} (sum > rhs\_bigit + borrow) \textcolor{keywordflow}{return} 1;}
\DoxyCodeLine{2968       borrow = rhs\_bigit + borrow -\/ sum;}
\DoxyCodeLine{2969       \textcolor{keywordflow}{if} (borrow > 1) \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{2970       borrow <<= bigit\_bits;}
\DoxyCodeLine{2971     \}}
\DoxyCodeLine{2972     \textcolor{keywordflow}{return} borrow != 0 ? -\/1 : 0;}
\DoxyCodeLine{2973   \}}
\DoxyCodeLine{2974 }
\DoxyCodeLine{2975   \textcolor{comment}{// Assigns pow(10, exp) to this bigint.}}
\DoxyCodeLine{2976   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} assign\_pow10(\textcolor{keywordtype}{int} exp) \{}
\DoxyCodeLine{2977     FMT\_ASSERT(exp >= 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{2978     \textcolor{keywordflow}{if} (exp == 0) \textcolor{keywordflow}{return} *\textcolor{keyword}{this} = 1;}
\DoxyCodeLine{2979     \textcolor{comment}{// Find the top bit.}}
\DoxyCodeLine{2980     \textcolor{keywordtype}{int} bitmask = 1;}
\DoxyCodeLine{2981     \textcolor{keywordflow}{while} (exp >= bitmask) bitmask <<= 1;}
\DoxyCodeLine{2982     bitmask >>= 1;}
\DoxyCodeLine{2983     \textcolor{comment}{// pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by}}
\DoxyCodeLine{2984     \textcolor{comment}{// repeated squaring and multiplication.}}
\DoxyCodeLine{2985     *\textcolor{keyword}{this} = 5;}
\DoxyCodeLine{2986     bitmask >>= 1;}
\DoxyCodeLine{2987     \textcolor{keywordflow}{while} (bitmask != 0) \{}
\DoxyCodeLine{2988       square();}
\DoxyCodeLine{2989       \textcolor{keywordflow}{if} ((exp \& bitmask) != 0) *\textcolor{keyword}{this} *= 5;}
\DoxyCodeLine{2990       bitmask >>= 1;}
\DoxyCodeLine{2991     \}}
\DoxyCodeLine{2992     *\textcolor{keyword}{this} <<= exp;  \textcolor{comment}{// Multiply by pow(2, exp) by shifting.}}
\DoxyCodeLine{2993   \}}
\DoxyCodeLine{2994 }
\DoxyCodeLine{2995   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} square() \{}
\DoxyCodeLine{2996     \textcolor{keywordtype}{int} num\_bigits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}());}
\DoxyCodeLine{2997     \textcolor{keywordtype}{int} num\_result\_bigits = 2 * num\_bigits;}
\DoxyCodeLine{2998     \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<bigit, bigits\_capacity>}} n(std::move(bigits\_));}
\DoxyCodeLine{2999     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(to\_unsigned(num\_result\_bigits));}
\DoxyCodeLine{3000     \textcolor{keyword}{auto} sum = uint128\_t();}
\DoxyCodeLine{3001     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} bigit\_index = 0; bigit\_index < num\_bigits; ++bigit\_index) \{}
\DoxyCodeLine{3002       \textcolor{comment}{// Compute bigit at position bigit\_index of the result by adding}}
\DoxyCodeLine{3003       \textcolor{comment}{// cross-\/product terms n[i] * n[j] such that i + j == bigit\_index.}}
\DoxyCodeLine{3004       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0, j = bigit\_index; j >= 0; ++i, -\/-\/j) \{}
\DoxyCodeLine{3005         \textcolor{comment}{// Most terms are multiplied twice which can be optimized in the future.}}
\DoxyCodeLine{3006         sum += \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}(n[i]) * n[j];}
\DoxyCodeLine{3007       \}}
\DoxyCodeLine{3008       (*this)[bigit\_index] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(sum);}
\DoxyCodeLine{3009       sum >>= num\_bits<bigit>();  \textcolor{comment}{// Compute the carry.}}
\DoxyCodeLine{3010     \}}
\DoxyCodeLine{3011     \textcolor{comment}{// Do the same for the top half.}}
\DoxyCodeLine{3012     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} bigit\_index = num\_bigits; bigit\_index < num\_result\_bigits;}
\DoxyCodeLine{3013          ++bigit\_index) \{}
\DoxyCodeLine{3014       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = num\_bigits -\/ 1, i = bigit\_index -\/ j; i < num\_bigits;)}
\DoxyCodeLine{3015         sum += \textcolor{keyword}{static\_cast<}double\_bigit\textcolor{keyword}{>}(n[i++]) * n[j-\/-\/];}
\DoxyCodeLine{3016       (*this)[bigit\_index] = \textcolor{keyword}{static\_cast<}bigit\textcolor{keyword}{>}(sum);}
\DoxyCodeLine{3017       sum >>= num\_bits<bigit>();}
\DoxyCodeLine{3018     \}}
\DoxyCodeLine{3019     remove\_leading\_zeros();}
\DoxyCodeLine{3020     exp\_ *= 2;}
\DoxyCodeLine{3021   \}}
\DoxyCodeLine{3022 }
\DoxyCodeLine{3023   \textcolor{comment}{// If this bigint has a bigger exponent than other, adds trailing zero to make}}
\DoxyCodeLine{3024   \textcolor{comment}{// exponents equal. This simplifies some operations such as subtraction.}}
\DoxyCodeLine{3025   FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} align(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& other) \{}
\DoxyCodeLine{3026     \textcolor{keywordtype}{int} exp\_difference = exp\_ -\/ other.exp\_;}
\DoxyCodeLine{3027     \textcolor{keywordflow}{if} (exp\_difference <= 0) \textcolor{keywordflow}{return};}
\DoxyCodeLine{3028     \textcolor{keywordtype}{int} num\_bigits = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}());}
\DoxyCodeLine{3029     bigits\_.\mbox{\hyperlink{classbasic__memory__buffer_a153c47788d6d1a76ec97780748755ea1}{resize}}(to\_unsigned(num\_bigits + exp\_difference));}
\DoxyCodeLine{3030     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = num\_bigits -\/ 1, j = i + exp\_difference; i >= 0; -\/-\/i, -\/-\/j)}
\DoxyCodeLine{3031       bigits\_[j] = bigits\_[i];}
\DoxyCodeLine{3032     std::uninitialized\_fill\_n(bigits\_.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}(), exp\_difference, 0);}
\DoxyCodeLine{3033     exp\_ -\/= exp\_difference;}
\DoxyCodeLine{3034   \}}
\DoxyCodeLine{3035 }
\DoxyCodeLine{3036   \textcolor{comment}{// Divides this bignum by divisor, assigning the remainder to this and}}
\DoxyCodeLine{3037   \textcolor{comment}{// returning the quotient.}}
\DoxyCodeLine{3038   FMT\_CONSTEXPR20 \textcolor{keywordtype}{int} divmod\_assign(\textcolor{keyword}{const} \mbox{\hyperlink{classdetail_1_1bigint}{bigint}}\& divisor) \{}
\DoxyCodeLine{3039     FMT\_ASSERT(\textcolor{keyword}{this} != \&divisor, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3040     \textcolor{keywordflow}{if} (compare(*\textcolor{keyword}{this}, divisor) < 0) \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3041     FMT\_ASSERT(divisor.bigits\_[divisor.bigits\_.size() -\/ 1u] != 0, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3042     align(divisor);}
\DoxyCodeLine{3043     \textcolor{keywordtype}{int} quotient = 0;}
\DoxyCodeLine{3044     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{3045       subtract\_aligned(divisor);}
\DoxyCodeLine{3046       ++quotient;}
\DoxyCodeLine{3047     \} \textcolor{keywordflow}{while} (compare(*\textcolor{keyword}{this}, divisor) >= 0);}
\DoxyCodeLine{3048     \textcolor{keywordflow}{return} quotient;}
\DoxyCodeLine{3049   \}}
\DoxyCodeLine{3050 \};}
\DoxyCodeLine{3051 }
\DoxyCodeLine{3052 \textcolor{comment}{// format\_dragon flags.}}
\DoxyCodeLine{3053 \textcolor{keyword}{enum} dragon \{}
\DoxyCodeLine{3054   predecessor\_closer = 1,}
\DoxyCodeLine{3055   fixup = 2,  \textcolor{comment}{// Run fixup to correct exp10 which can be off by one.}}
\DoxyCodeLine{3056   fixed = 4,}
\DoxyCodeLine{3057 \};}
\DoxyCodeLine{3058 }
\DoxyCodeLine{3059 \textcolor{comment}{// Formats a floating-\/point number using a variation of the Fixed-\/Precision}}
\DoxyCodeLine{3060 \textcolor{comment}{// Positive Floating-\/Point Printout ((FPP)\string^2) algorithm by Steele \& White:}}
\DoxyCodeLine{3061 \textcolor{comment}{// https://fmt.dev/papers/p372-\/steele.pdf.}}
\DoxyCodeLine{3062 FMT\_CONSTEXPR20 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} format\_dragon(basic\_fp<uint128\_t> value,}
\DoxyCodeLine{3063                                           \textcolor{keywordtype}{unsigned} flags, \textcolor{keywordtype}{int} num\_digits,}
\DoxyCodeLine{3064                                           buffer<char>\& buf, \textcolor{keywordtype}{int}\& exp10) \{}
\DoxyCodeLine{3065   bigint numerator;    \textcolor{comment}{// 2 * R in (FPP)\string^2.}}
\DoxyCodeLine{3066   bigint denominator;  \textcolor{comment}{// 2 * S in (FPP)\string^2.}}
\DoxyCodeLine{3067   \textcolor{comment}{// lower and upper are differences between value and corresponding boundaries.}}
\DoxyCodeLine{3068   bigint lower;             \textcolor{comment}{// (M\string^-\/ in (FPP)\string^2).}}
\DoxyCodeLine{3069   bigint upper\_store;       \textcolor{comment}{// upper's value if different from lower.}}
\DoxyCodeLine{3070   bigint* upper = \textcolor{keyword}{nullptr};  \textcolor{comment}{// (M\string^+ in (FPP)\string^2).}}
\DoxyCodeLine{3071   \textcolor{comment}{// Shift numerator and denominator by an extra bit or two (if lower boundary}}
\DoxyCodeLine{3072   \textcolor{comment}{// is closer) to make lower and upper integers. This eliminates multiplication}}
\DoxyCodeLine{3073   \textcolor{comment}{// by 2 during later computations.}}
\DoxyCodeLine{3074   \textcolor{keywordtype}{bool} is\_predecessor\_closer = (flags \& dragon::predecessor\_closer) != 0;}
\DoxyCodeLine{3075   \textcolor{keywordtype}{int} shift = is\_predecessor\_closer ? 2 : 1;}
\DoxyCodeLine{3076   \textcolor{keywordflow}{if} (value.e >= 0) \{}
\DoxyCodeLine{3077     numerator = value.f;}
\DoxyCodeLine{3078     numerator <<= value.e + shift;}
\DoxyCodeLine{3079     lower = 1;}
\DoxyCodeLine{3080     lower <<= value.e;}
\DoxyCodeLine{3081     \textcolor{keywordflow}{if} (is\_predecessor\_closer) \{}
\DoxyCodeLine{3082       upper\_store = 1;}
\DoxyCodeLine{3083       upper\_store <<= value.e + 1;}
\DoxyCodeLine{3084       upper = \&upper\_store;}
\DoxyCodeLine{3085     \}}
\DoxyCodeLine{3086     denominator.assign\_pow10(exp10);}
\DoxyCodeLine{3087     denominator <<= shift;}
\DoxyCodeLine{3088   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exp10 < 0) \{}
\DoxyCodeLine{3089     numerator.assign\_pow10(-\/exp10);}
\DoxyCodeLine{3090     lower.assign(numerator);}
\DoxyCodeLine{3091     \textcolor{keywordflow}{if} (is\_predecessor\_closer) \{}
\DoxyCodeLine{3092       upper\_store.assign(numerator);}
\DoxyCodeLine{3093       upper\_store <<= 1;}
\DoxyCodeLine{3094       upper = \&upper\_store;}
\DoxyCodeLine{3095     \}}
\DoxyCodeLine{3096     numerator *= value.f;}
\DoxyCodeLine{3097     numerator <<= shift;}
\DoxyCodeLine{3098     denominator = 1;}
\DoxyCodeLine{3099     denominator <<= shift -\/ value.e;}
\DoxyCodeLine{3100   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3101     numerator = value.f;}
\DoxyCodeLine{3102     numerator <<= shift;}
\DoxyCodeLine{3103     denominator.assign\_pow10(exp10);}
\DoxyCodeLine{3104     denominator <<= shift -\/ value.e;}
\DoxyCodeLine{3105     lower = 1;}
\DoxyCodeLine{3106     \textcolor{keywordflow}{if} (is\_predecessor\_closer) \{}
\DoxyCodeLine{3107       upper\_store = 1ULL << 1;}
\DoxyCodeLine{3108       upper = \&upper\_store;}
\DoxyCodeLine{3109     \}}
\DoxyCodeLine{3110   \}}
\DoxyCodeLine{3111   \textcolor{keywordtype}{int} even = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((value.f \& 1) == 0);}
\DoxyCodeLine{3112   \textcolor{keywordflow}{if} (!upper) upper = \&lower;}
\DoxyCodeLine{3113   \textcolor{keywordtype}{bool} shortest = num\_digits < 0;}
\DoxyCodeLine{3114   \textcolor{keywordflow}{if} ((flags \& dragon::fixup) != 0) \{}
\DoxyCodeLine{3115     \textcolor{keywordflow}{if} (add\_compare(numerator, *upper, denominator) + even <= 0) \{}
\DoxyCodeLine{3116       -\/-\/exp10;}
\DoxyCodeLine{3117       numerator *= 10;}
\DoxyCodeLine{3118       \textcolor{keywordflow}{if} (num\_digits < 0) \{}
\DoxyCodeLine{3119         lower *= 10;}
\DoxyCodeLine{3120         \textcolor{keywordflow}{if} (upper != \&lower) *upper *= 10;}
\DoxyCodeLine{3121       \}}
\DoxyCodeLine{3122     \}}
\DoxyCodeLine{3123     \textcolor{keywordflow}{if} ((flags \& dragon::fixed) != 0) adjust\_precision(num\_digits, exp10 + 1);}
\DoxyCodeLine{3124   \}}
\DoxyCodeLine{3125   \textcolor{comment}{// Invariant: value == (numerator / denominator) * pow(10, exp10).}}
\DoxyCodeLine{3126   \textcolor{keywordflow}{if} (shortest) \{}
\DoxyCodeLine{3127     \textcolor{comment}{// Generate the shortest representation.}}
\DoxyCodeLine{3128     num\_digits = 0;}
\DoxyCodeLine{3129     \textcolor{keywordtype}{char}* data = buf.data();}
\DoxyCodeLine{3130     \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{3131       \textcolor{keywordtype}{int} digit = numerator.divmod\_assign(denominator);}
\DoxyCodeLine{3132       \textcolor{keywordtype}{bool} low = compare(numerator, lower) -\/ even < 0;  \textcolor{comment}{// numerator <[=] lower.}}
\DoxyCodeLine{3133       \textcolor{comment}{// numerator + upper >[=] pow10:}}
\DoxyCodeLine{3134       \textcolor{keywordtype}{bool} high = add\_compare(numerator, *upper, denominator) + even > 0;}
\DoxyCodeLine{3135       data[num\_digits++] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{3136       \textcolor{keywordflow}{if} (low || high) \{}
\DoxyCodeLine{3137         \textcolor{keywordflow}{if} (!low) \{}
\DoxyCodeLine{3138           ++data[num\_digits -\/ 1];}
\DoxyCodeLine{3139         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (high) \{}
\DoxyCodeLine{3140           \textcolor{keywordtype}{int} result = add\_compare(numerator, numerator, denominator);}
\DoxyCodeLine{3141           \textcolor{comment}{// Round half to even.}}
\DoxyCodeLine{3142           \textcolor{keywordflow}{if} (result > 0 || (result == 0 \&\& (digit \% 2) != 0))}
\DoxyCodeLine{3143             ++data[num\_digits -\/ 1];}
\DoxyCodeLine{3144         \}}
\DoxyCodeLine{3145         buf.try\_resize(to\_unsigned(num\_digits));}
\DoxyCodeLine{3146         exp10 -\/= num\_digits -\/ 1;}
\DoxyCodeLine{3147         \textcolor{keywordflow}{return};}
\DoxyCodeLine{3148       \}}
\DoxyCodeLine{3149       numerator *= 10;}
\DoxyCodeLine{3150       lower *= 10;}
\DoxyCodeLine{3151       \textcolor{keywordflow}{if} (upper != \&lower) *upper *= 10;}
\DoxyCodeLine{3152     \}}
\DoxyCodeLine{3153   \}}
\DoxyCodeLine{3154   \textcolor{comment}{// Generate the given number of digits.}}
\DoxyCodeLine{3155   exp10 -\/= num\_digits -\/ 1;}
\DoxyCodeLine{3156   \textcolor{keywordflow}{if} (num\_digits <= 0) \{}
\DoxyCodeLine{3157     denominator *= 10;}
\DoxyCodeLine{3158     \textcolor{keyword}{auto} digit = add\_compare(numerator, numerator, denominator) > 0 ? \textcolor{charliteral}{'1'} : \textcolor{charliteral}{'0'};}
\DoxyCodeLine{3159     buf.push\_back(digit);}
\DoxyCodeLine{3160     \textcolor{keywordflow}{return};}
\DoxyCodeLine{3161   \}}
\DoxyCodeLine{3162   buf.try\_resize(to\_unsigned(num\_digits));}
\DoxyCodeLine{3163   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < num\_digits -\/ 1; ++i) \{}
\DoxyCodeLine{3164     \textcolor{keywordtype}{int} digit = numerator.divmod\_assign(denominator);}
\DoxyCodeLine{3165     buf[i] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{3166     numerator *= 10;}
\DoxyCodeLine{3167   \}}
\DoxyCodeLine{3168   \textcolor{keywordtype}{int} digit = numerator.divmod\_assign(denominator);}
\DoxyCodeLine{3169   \textcolor{keyword}{auto} result = add\_compare(numerator, numerator, denominator);}
\DoxyCodeLine{3170   \textcolor{keywordflow}{if} (result > 0 || (result == 0 \&\& (digit \% 2) != 0)) \{}
\DoxyCodeLine{3171     \textcolor{keywordflow}{if} (digit == 9) \{}
\DoxyCodeLine{3172       \textcolor{keyword}{const} \textcolor{keyword}{auto} overflow = \textcolor{charliteral}{'0'} + 10;}
\DoxyCodeLine{3173       buf[num\_digits -\/ 1] = overflow;}
\DoxyCodeLine{3174       \textcolor{comment}{// Propagate the carry.}}
\DoxyCodeLine{3175       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = num\_digits -\/ 1; i > 0 \&\& buf[i] == overflow; -\/-\/i) \{}
\DoxyCodeLine{3176         buf[i] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{3177         ++buf[i -\/ 1];}
\DoxyCodeLine{3178       \}}
\DoxyCodeLine{3179       \textcolor{keywordflow}{if} (buf[0] == overflow) \{}
\DoxyCodeLine{3180         buf[0] = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{3181         ++exp10;}
\DoxyCodeLine{3182       \}}
\DoxyCodeLine{3183       \textcolor{keywordflow}{return};}
\DoxyCodeLine{3184     \}}
\DoxyCodeLine{3185     ++digit;}
\DoxyCodeLine{3186   \}}
\DoxyCodeLine{3187   buf[num\_digits -\/ 1] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digit);}
\DoxyCodeLine{3188 \}}
\DoxyCodeLine{3189 }
\DoxyCodeLine{3190 \textcolor{comment}{// Formats a floating-\/point number using the hexfloat format.}}
\DoxyCodeLine{3191 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{double}\_\textcolor{keywordtype}{double}<Float>::value)>}
\DoxyCodeLine{3192 FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} format\_hexfloat(Float value, \textcolor{keywordtype}{int} precision,}
\DoxyCodeLine{3193                                      float\_specs specs, buffer<char>\& buf) \{}
\DoxyCodeLine{3194   \textcolor{comment}{// float is passed as double to reduce the number of instantiations and to}}
\DoxyCodeLine{3195   \textcolor{comment}{// simplify implementation.}}
\DoxyCodeLine{3196   \textcolor{keyword}{static\_assert}(!std::is\_same<Float, float>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3197 }
\DoxyCodeLine{3198   \textcolor{keyword}{using }info = dragonbox::float\_info<Float>;}
\DoxyCodeLine{3199 }
\DoxyCodeLine{3200   \textcolor{comment}{// Assume Float is in the format [sign][exponent][significand].}}
\DoxyCodeLine{3201   \textcolor{keyword}{using }carrier\_uint = \textcolor{keyword}{typename} info::carrier\_uint;}
\DoxyCodeLine{3202 }
\DoxyCodeLine{3203   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_float\_significand\_bits =}
\DoxyCodeLine{3204       detail::num\_significand\_bits<Float>();}
\DoxyCodeLine{3205 }
\DoxyCodeLine{3206   basic\_fp<carrier\_uint> f(value);}
\DoxyCodeLine{3207   f.e += num\_float\_significand\_bits;}
\DoxyCodeLine{3208   \textcolor{keywordflow}{if} (!has\_implicit\_bit<Float>()) -\/-\/f.e;}
\DoxyCodeLine{3209 }
\DoxyCodeLine{3210   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_fraction\_bits =}
\DoxyCodeLine{3211       num\_float\_significand\_bits + (has\_implicit\_bit<Float>() ? 1 : 0);}
\DoxyCodeLine{3212   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} num\_xdigits = (num\_fraction\_bits + 3) / 4;}
\DoxyCodeLine{3213 }
\DoxyCodeLine{3214   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} leading\_shift = ((num\_xdigits -\/ 1) * 4);}
\DoxyCodeLine{3215   \textcolor{keyword}{const} \textcolor{keyword}{auto} leading\_mask = carrier\_uint(0xF) << leading\_shift;}
\DoxyCodeLine{3216   \textcolor{keyword}{const} \textcolor{keyword}{auto} leading\_xdigit =}
\DoxyCodeLine{3217       \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}((f.f \& leading\_mask) >> leading\_shift);}
\DoxyCodeLine{3218   \textcolor{keywordflow}{if} (leading\_xdigit > 1) f.e -\/= (32 -\/ countl\_zero(leading\_xdigit) -\/ 1);}
\DoxyCodeLine{3219 }
\DoxyCodeLine{3220   \textcolor{keywordtype}{int} print\_xdigits = num\_xdigits -\/ 1;}
\DoxyCodeLine{3221   \textcolor{keywordflow}{if} (precision >= 0 \&\& print\_xdigits > precision) \{}
\DoxyCodeLine{3222     \textcolor{keyword}{const} \textcolor{keywordtype}{int} shift = ((print\_xdigits -\/ precision -\/ 1) * 4);}
\DoxyCodeLine{3223     \textcolor{keyword}{const} \textcolor{keyword}{auto} mask = carrier\_uint(0xF) << shift;}
\DoxyCodeLine{3224     \textcolor{keyword}{const} \textcolor{keyword}{auto} v = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}((f.f \& mask) >> shift);}
\DoxyCodeLine{3225 }
\DoxyCodeLine{3226     \textcolor{keywordflow}{if} (v >= 8) \{}
\DoxyCodeLine{3227       \textcolor{keyword}{const} \textcolor{keyword}{auto} inc = carrier\_uint(1) << (shift + 4);}
\DoxyCodeLine{3228       f.f += inc;}
\DoxyCodeLine{3229       f.f \&= \string~(inc -\/ 1);}
\DoxyCodeLine{3230     \}}
\DoxyCodeLine{3231 }
\DoxyCodeLine{3232     \textcolor{comment}{// Check long double overflow}}
\DoxyCodeLine{3233     \textcolor{keywordflow}{if} (!has\_implicit\_bit<Float>()) \{}
\DoxyCodeLine{3234       \textcolor{keyword}{const} \textcolor{keyword}{auto} implicit\_bit = carrier\_uint(1) << num\_float\_significand\_bits;}
\DoxyCodeLine{3235       \textcolor{keywordflow}{if} ((f.f \& implicit\_bit) == implicit\_bit) \{}
\DoxyCodeLine{3236         f.f >>= 4;}
\DoxyCodeLine{3237         f.e += 4;}
\DoxyCodeLine{3238       \}}
\DoxyCodeLine{3239     \}}
\DoxyCodeLine{3240 }
\DoxyCodeLine{3241     print\_xdigits = precision;}
\DoxyCodeLine{3242   \}}
\DoxyCodeLine{3243 }
\DoxyCodeLine{3244   \textcolor{keywordtype}{char} xdigits[num\_bits<carrier\_uint>() / 4];}
\DoxyCodeLine{3245   detail::fill\_n(xdigits, \textcolor{keyword}{sizeof}(xdigits), \textcolor{charliteral}{'0'});}
\DoxyCodeLine{3246   format\_uint<4>(xdigits, f.f, num\_xdigits, specs.upper);}
\DoxyCodeLine{3247 }
\DoxyCodeLine{3248   \textcolor{comment}{// Remove zero tail}}
\DoxyCodeLine{3249   \textcolor{keywordflow}{while} (print\_xdigits > 0 \&\& xdigits[print\_xdigits] == \textcolor{charliteral}{'0'}) -\/-\/print\_xdigits;}
\DoxyCodeLine{3250 }
\DoxyCodeLine{3251   buf.push\_back(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{3252   buf.push\_back(specs.upper ? \textcolor{charliteral}{'X'} : \textcolor{charliteral}{'x'});}
\DoxyCodeLine{3253   buf.push\_back(xdigits[0]);}
\DoxyCodeLine{3254   \textcolor{keywordflow}{if} (specs.showpoint || print\_xdigits > 0 || print\_xdigits < precision)}
\DoxyCodeLine{3255     buf.push\_back(\textcolor{charliteral}{'.'});}
\DoxyCodeLine{3256   buf.append(xdigits + 1, xdigits + 1 + print\_xdigits);}
\DoxyCodeLine{3257   \textcolor{keywordflow}{for} (; print\_xdigits < precision; ++print\_xdigits) buf.push\_back(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{3258 }
\DoxyCodeLine{3259   buf.push\_back(specs.upper ? \textcolor{charliteral}{'P'} : \textcolor{charliteral}{'p'});}
\DoxyCodeLine{3260 }
\DoxyCodeLine{3261   uint32\_t abs\_e;}
\DoxyCodeLine{3262   \textcolor{keywordflow}{if} (f.e < 0) \{}
\DoxyCodeLine{3263     buf.push\_back(\textcolor{charliteral}{'-\/'});}
\DoxyCodeLine{3264     abs\_e = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(-\/f.e);}
\DoxyCodeLine{3265   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3266     buf.push\_back(\textcolor{charliteral}{'+'});}
\DoxyCodeLine{3267     abs\_e = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(f.e);}
\DoxyCodeLine{3268   \}}
\DoxyCodeLine{3269   format\_decimal<char>(\mbox{\hyperlink{classappender}{appender}}(buf), abs\_e, detail::count\_digits(abs\_e));}
\DoxyCodeLine{3270 \}}
\DoxyCodeLine{3271 }
\DoxyCodeLine{3272 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{double}\_\textcolor{keywordtype}{double}<Float>::value)>}
\DoxyCodeLine{3273 FMT\_CONSTEXPR20 \textcolor{keywordtype}{void} format\_hexfloat(Float value, \textcolor{keywordtype}{int} precision,}
\DoxyCodeLine{3274                                      float\_specs specs, buffer<char>\& buf) \{}
\DoxyCodeLine{3275   format\_hexfloat(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value), precision, specs, buf);}
\DoxyCodeLine{3276 \}}
\DoxyCodeLine{3277 }
\DoxyCodeLine{3278 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Float>}
\DoxyCodeLine{3279 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} format\_float(Float value, \textcolor{keywordtype}{int} precision, float\_specs specs,}
\DoxyCodeLine{3280                                   buffer<char>\& buf) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{3281   \textcolor{comment}{// float is passed as double to reduce the number of instantiations.}}
\DoxyCodeLine{3282   \textcolor{keyword}{static\_assert}(!std::is\_same<Float, float>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3283   FMT\_ASSERT(value >= 0, \textcolor{stringliteral}{"{}value is negative"{}});}
\DoxyCodeLine{3284   \textcolor{keyword}{auto} converted\_value = convert\_float(value);}
\DoxyCodeLine{3285 }
\DoxyCodeLine{3286   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} fixed = specs.format == float\_format::fixed;}
\DoxyCodeLine{3287   \textcolor{keywordflow}{if} (value <= 0) \{  \textcolor{comment}{// <= instead of == to silence a warning.}}
\DoxyCodeLine{3288     \textcolor{keywordflow}{if} (precision <= 0 || !fixed) \{}
\DoxyCodeLine{3289       buf.push\_back(\textcolor{charliteral}{'0'});}
\DoxyCodeLine{3290       \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3291     \}}
\DoxyCodeLine{3292     buf.try\_resize(to\_unsigned(precision));}
\DoxyCodeLine{3293     fill\_n(buf.data(), precision, \textcolor{charliteral}{'0'});}
\DoxyCodeLine{3294     \textcolor{keywordflow}{return} -\/precision;}
\DoxyCodeLine{3295   \}}
\DoxyCodeLine{3296 }
\DoxyCodeLine{3297   \textcolor{keywordtype}{int} exp = 0;}
\DoxyCodeLine{3298   \textcolor{keywordtype}{bool} use\_dragon = \textcolor{keyword}{true};}
\DoxyCodeLine{3299   \textcolor{keywordtype}{unsigned} dragon\_flags = 0;}
\DoxyCodeLine{3300   \textcolor{keywordflow}{if} (!is\_fast\_float<Float>() || is\_constant\_evaluated()) \{}
\DoxyCodeLine{3301     \textcolor{keyword}{const} \textcolor{keyword}{auto} inv\_log2\_10 = 0.3010299956639812;  \textcolor{comment}{// 1 / log2(10)}}
\DoxyCodeLine{3302     \textcolor{keyword}{using }info = dragonbox::float\_info<\textcolor{keyword}{decltype}(converted\_value)>;}
\DoxyCodeLine{3303     \textcolor{keyword}{const} \textcolor{keyword}{auto} f = basic\_fp<typename info::carrier\_uint>(converted\_value);}
\DoxyCodeLine{3304     \textcolor{comment}{// Compute exp, an approximate power of 10, such that}}
\DoxyCodeLine{3305     \textcolor{comment}{//   10\string^(exp -\/ 1) <= value < 10\string^exp or 10\string^exp <= value < 10\string^(exp + 1).}}
\DoxyCodeLine{3306     \textcolor{comment}{// This is based on log10(value) == log2(value) / log2(10) and approximation}}
\DoxyCodeLine{3307     \textcolor{comment}{// of log2(value) by e + num\_fraction\_bits idea from double-\/conversion.}}
\DoxyCodeLine{3308     \textcolor{keyword}{auto} e = (f.e + count\_digits<1>(f.f) -\/ 1) * inv\_log2\_10 -\/ 1e-\/10;}
\DoxyCodeLine{3309     exp = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(e);}
\DoxyCodeLine{3310     \textcolor{keywordflow}{if} (e > exp) ++exp;  \textcolor{comment}{// Compute ceil.}}
\DoxyCodeLine{3311     dragon\_flags = dragon::fixup;}
\DoxyCodeLine{3312   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (precision < 0) \{}
\DoxyCodeLine{3313     \textcolor{comment}{// Use Dragonbox for the shortest format.}}
\DoxyCodeLine{3314     \textcolor{keywordflow}{if} (specs.binary32) \{}
\DoxyCodeLine{3315       \textcolor{keyword}{auto} dec = dragonbox::to\_decimal(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3316       write<char>(buffer\_appender<char>(buf), dec.significand);}
\DoxyCodeLine{3317       \textcolor{keywordflow}{return} dec.exponent;}
\DoxyCodeLine{3318     \}}
\DoxyCodeLine{3319     \textcolor{keyword}{auto} dec = dragonbox::to\_decimal(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3320     write<char>(buffer\_appender<char>(buf), dec.significand);}
\DoxyCodeLine{3321     \textcolor{keywordflow}{return} dec.exponent;}
\DoxyCodeLine{3322   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3323     \textcolor{comment}{// Extract significand bits and exponent bits.}}
\DoxyCodeLine{3324     \textcolor{keyword}{using }info = dragonbox::float\_info<double>;}
\DoxyCodeLine{3325     \textcolor{keyword}{auto} br = bit\_cast<uint64\_t>(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3326 }
\DoxyCodeLine{3327     \textcolor{keyword}{const} uint64\_t significand\_mask =}
\DoxyCodeLine{3328         (\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(1) << num\_significand\_bits<double>()) -\/ 1;}
\DoxyCodeLine{3329     uint64\_t significand = (br \& significand\_mask);}
\DoxyCodeLine{3330     \textcolor{keywordtype}{int} exponent = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}((br \& exponent\_mask<double>()) >>}
\DoxyCodeLine{3331                                     num\_significand\_bits<double>());}
\DoxyCodeLine{3332 }
\DoxyCodeLine{3333     \textcolor{keywordflow}{if} (exponent != 0) \{  \textcolor{comment}{// Check if normal.}}
\DoxyCodeLine{3334       exponent -\/= exponent\_bias<double>() + num\_significand\_bits<double>();}
\DoxyCodeLine{3335       significand |=}
\DoxyCodeLine{3336           (\textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(1) << num\_significand\_bits<double>());}
\DoxyCodeLine{3337       significand <<= 1;}
\DoxyCodeLine{3338     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3339       \textcolor{comment}{// Normalize subnormal inputs.}}
\DoxyCodeLine{3340       FMT\_ASSERT(significand != 0, \textcolor{stringliteral}{"{}zeros should not appear here"{}});}
\DoxyCodeLine{3341       \textcolor{keywordtype}{int} shift = countl\_zero(significand);}
\DoxyCodeLine{3342       FMT\_ASSERT(shift >= num\_bits<uint64\_t>() -\/ num\_significand\_bits<double>(),}
\DoxyCodeLine{3343                  \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3344       shift -\/= (num\_bits<uint64\_t>() -\/ num\_significand\_bits<double>() -\/ 2);}
\DoxyCodeLine{3345       exponent = (std::numeric\_limits<double>::min\_exponent -\/}
\DoxyCodeLine{3346                   num\_significand\_bits<double>()) -\/}
\DoxyCodeLine{3347                  shift;}
\DoxyCodeLine{3348       significand <<= shift;}
\DoxyCodeLine{3349     \}}
\DoxyCodeLine{3350 }
\DoxyCodeLine{3351     \textcolor{comment}{// Compute the first several nonzero decimal significand digits.}}
\DoxyCodeLine{3352     \textcolor{comment}{// We call the number we get the first segment.}}
\DoxyCodeLine{3353     \textcolor{keyword}{const} \textcolor{keywordtype}{int} k = info::kappa -\/ dragonbox::floor\_log10\_pow2(exponent);}
\DoxyCodeLine{3354     exp = -\/k;}
\DoxyCodeLine{3355     \textcolor{keyword}{const} \textcolor{keywordtype}{int} beta = exponent + dragonbox::floor\_log2\_pow10(k);}
\DoxyCodeLine{3356     uint64\_t first\_segment;}
\DoxyCodeLine{3357     \textcolor{keywordtype}{bool} has\_more\_segments;}
\DoxyCodeLine{3358     \textcolor{keywordtype}{int} digits\_in\_the\_first\_segment;}
\DoxyCodeLine{3359     \{}
\DoxyCodeLine{3360       \textcolor{keyword}{const} \textcolor{keyword}{auto} r = dragonbox::umul192\_upper128(}
\DoxyCodeLine{3361           significand << beta, dragonbox::get\_cached\_power(k));}
\DoxyCodeLine{3362       first\_segment = r.high();}
\DoxyCodeLine{3363       has\_more\_segments = r.low() != 0;}
\DoxyCodeLine{3364 }
\DoxyCodeLine{3365       \textcolor{comment}{// The first segment can have 18 \string~ 19 digits.}}
\DoxyCodeLine{3366       \textcolor{keywordflow}{if} (first\_segment >= 1000000000000000000ULL) \{}
\DoxyCodeLine{3367         digits\_in\_the\_first\_segment = 19;}
\DoxyCodeLine{3368       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3369         \textcolor{comment}{// When it is of 18-\/digits, we align it to 19-\/digits by adding a bogus}}
\DoxyCodeLine{3370         \textcolor{comment}{// zero at the end.}}
\DoxyCodeLine{3371         digits\_in\_the\_first\_segment = 18;}
\DoxyCodeLine{3372         first\_segment *= 10;}
\DoxyCodeLine{3373       \}}
\DoxyCodeLine{3374     \}}
\DoxyCodeLine{3375 }
\DoxyCodeLine{3376     \textcolor{comment}{// Compute the actual number of decimal digits to print.}}
\DoxyCodeLine{3377     \textcolor{keywordflow}{if} (fixed) adjust\_precision(precision, exp + digits\_in\_the\_first\_segment);}
\DoxyCodeLine{3378 }
\DoxyCodeLine{3379     \textcolor{comment}{// Use Dragon4 only when there might be not enough digits in the first}}
\DoxyCodeLine{3380     \textcolor{comment}{// segment.}}
\DoxyCodeLine{3381     \textcolor{keywordflow}{if} (digits\_in\_the\_first\_segment > precision) \{}
\DoxyCodeLine{3382       use\_dragon = \textcolor{keyword}{false};}
\DoxyCodeLine{3383 }
\DoxyCodeLine{3384       \textcolor{keywordflow}{if} (precision <= 0) \{}
\DoxyCodeLine{3385         exp += digits\_in\_the\_first\_segment;}
\DoxyCodeLine{3386 }
\DoxyCodeLine{3387         \textcolor{keywordflow}{if} (precision < 0) \{}
\DoxyCodeLine{3388           \textcolor{comment}{// Nothing to do, since all we have are just leading zeros.}}
\DoxyCodeLine{3389           buf.try\_resize(0);}
\DoxyCodeLine{3390         \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3391           \textcolor{comment}{// We may need to round-\/up.}}
\DoxyCodeLine{3392           buf.try\_resize(1);}
\DoxyCodeLine{3393           \textcolor{keywordflow}{if} ((first\_segment | \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(has\_more\_segments)) >}
\DoxyCodeLine{3394               5000000000000000000ULL) \{}
\DoxyCodeLine{3395             buf[0] = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{3396           \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3397             buf[0] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{3398           \}}
\DoxyCodeLine{3399         \}}
\DoxyCodeLine{3400       \}  \textcolor{comment}{// precision <= 0}}
\DoxyCodeLine{3401       \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3402         exp += digits\_in\_the\_first\_segment -\/ precision;}
\DoxyCodeLine{3403 }
\DoxyCodeLine{3404         \textcolor{comment}{// When precision > 0, we divide the first segment into three}}
\DoxyCodeLine{3405         \textcolor{comment}{// subsegments, each with 9, 9, and 0 \string~ 1 digits so that each fits}}
\DoxyCodeLine{3406         \textcolor{comment}{// in 32-\/bits which usually allows faster calculation than in}}
\DoxyCodeLine{3407         \textcolor{comment}{// 64-\/bits. Since some compiler (e.g. MSVC) doesn't know how to optimize}}
\DoxyCodeLine{3408         \textcolor{comment}{// division-\/by-\/constant for large 64-\/bit divisors, we do it here}}
\DoxyCodeLine{3409         \textcolor{comment}{// manually. The magic number 7922816251426433760 below is equal to}}
\DoxyCodeLine{3410         \textcolor{comment}{// ceil(2\string^(64+32) / 10\string^10).}}
\DoxyCodeLine{3411         \textcolor{keyword}{const} uint32\_t first\_subsegment = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(}
\DoxyCodeLine{3412             dragonbox::umul128\_upper64(first\_segment, 7922816251426433760ULL) >>}
\DoxyCodeLine{3413             32);}
\DoxyCodeLine{3414         \textcolor{keyword}{const} uint64\_t second\_third\_subsegments =}
\DoxyCodeLine{3415             first\_segment -\/ first\_subsegment * 10000000000ULL;}
\DoxyCodeLine{3416 }
\DoxyCodeLine{3417         uint64\_t prod;}
\DoxyCodeLine{3418         uint32\_t digits;}
\DoxyCodeLine{3419         \textcolor{keywordtype}{bool} should\_round\_up;}
\DoxyCodeLine{3420         \textcolor{keywordtype}{int} number\_of\_digits\_to\_print = precision > 9 ? 9 : precision;}
\DoxyCodeLine{3421 }
\DoxyCodeLine{3422         \textcolor{comment}{// Print a 9-\/digits subsegment, either the first or the second.}}
\DoxyCodeLine{3423         \textcolor{keyword}{auto} print\_subsegment = [\&](uint32\_t subsegment, \textcolor{keywordtype}{char}* buffer) \{}
\DoxyCodeLine{3424           \textcolor{keywordtype}{int} number\_of\_digits\_printed = 0;}
\DoxyCodeLine{3425 }
\DoxyCodeLine{3426           \textcolor{comment}{// If we want to print an odd number of digits from the subsegment,}}
\DoxyCodeLine{3427           \textcolor{keywordflow}{if} ((number\_of\_digits\_to\_print \& 1) != 0) \{}
\DoxyCodeLine{3428             \textcolor{comment}{// Convert to 64-\/bit fixed-\/point fractional form with 1-\/digit}}
\DoxyCodeLine{3429             \textcolor{comment}{// integer part. The magic number 720575941 is a good enough}}
\DoxyCodeLine{3430             \textcolor{comment}{// approximation of 2\string^(32 + 24) / 10\string^8; see}}
\DoxyCodeLine{3431             \textcolor{comment}{// https://jk-\/jeon.github.io/posts/2022/12/fixed-\/precision-\/formatting/\#fixed-\/length-\/case}}
\DoxyCodeLine{3432             \textcolor{comment}{// for details.}}
\DoxyCodeLine{3433             prod = ((subsegment * \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(720575941)) >> 24) + 1;}
\DoxyCodeLine{3434             digits = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(prod >> 32);}
\DoxyCodeLine{3435             *buffer = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(\textcolor{charliteral}{'0'} + digits);}
\DoxyCodeLine{3436             number\_of\_digits\_printed++;}
\DoxyCodeLine{3437           \}}
\DoxyCodeLine{3438           \textcolor{comment}{// If we want to print an even number of digits from the}}
\DoxyCodeLine{3439           \textcolor{comment}{// first\_subsegment,}}
\DoxyCodeLine{3440           \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3441             \textcolor{comment}{// Convert to 64-\/bit fixed-\/point fractional form with 2-\/digits}}
\DoxyCodeLine{3442             \textcolor{comment}{// integer part. The magic number 450359963 is a good enough}}
\DoxyCodeLine{3443             \textcolor{comment}{// approximation of 2\string^(32 + 20) / 10\string^7; see}}
\DoxyCodeLine{3444             \textcolor{comment}{// https://jk-\/jeon.github.io/posts/2022/12/fixed-\/precision-\/formatting/\#fixed-\/length-\/case}}
\DoxyCodeLine{3445             \textcolor{comment}{// for details.}}
\DoxyCodeLine{3446             prod = ((subsegment * \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(450359963)) >> 20) + 1;}
\DoxyCodeLine{3447             digits = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(prod >> 32);}
\DoxyCodeLine{3448             copy2(buffer, digits2(digits));}
\DoxyCodeLine{3449             number\_of\_digits\_printed += 2;}
\DoxyCodeLine{3450           \}}
\DoxyCodeLine{3451 }
\DoxyCodeLine{3452           \textcolor{comment}{// Print all digit pairs.}}
\DoxyCodeLine{3453           \textcolor{keywordflow}{while} (number\_of\_digits\_printed < number\_of\_digits\_to\_print) \{}
\DoxyCodeLine{3454             prod = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(prod) * \textcolor{keyword}{static\_cast<}uint64\_t\textcolor{keyword}{>}(100);}
\DoxyCodeLine{3455             digits = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(prod >> 32);}
\DoxyCodeLine{3456             copy2(buffer + number\_of\_digits\_printed, digits2(digits));}
\DoxyCodeLine{3457             number\_of\_digits\_printed += 2;}
\DoxyCodeLine{3458           \}}
\DoxyCodeLine{3459         \};}
\DoxyCodeLine{3460 }
\DoxyCodeLine{3461         \textcolor{comment}{// Print first subsegment.}}
\DoxyCodeLine{3462         print\_subsegment(first\_subsegment, buf.data());}
\DoxyCodeLine{3463 }
\DoxyCodeLine{3464         \textcolor{comment}{// Perform rounding if the first subsegment is the last subsegment to}}
\DoxyCodeLine{3465         \textcolor{comment}{// print.}}
\DoxyCodeLine{3466         \textcolor{keywordflow}{if} (precision <= 9) \{}
\DoxyCodeLine{3467           \textcolor{comment}{// Rounding inside the subsegment.}}
\DoxyCodeLine{3468           \textcolor{comment}{// We round-\/up if:}}
\DoxyCodeLine{3469           \textcolor{comment}{//  -\/ either the fractional part is strictly larger than 1/2, or}}
\DoxyCodeLine{3470           \textcolor{comment}{//  -\/ the fractional part is exactly 1/2 and the last digit is odd.}}
\DoxyCodeLine{3471           \textcolor{comment}{// We rely on the following observations:}}
\DoxyCodeLine{3472           \textcolor{comment}{//  -\/ If fractional\_part >= threshold, then the fractional part is}}
\DoxyCodeLine{3473           \textcolor{comment}{//    strictly larger than 1/2.}}
\DoxyCodeLine{3474           \textcolor{comment}{//  -\/ If the MSB of fractional\_part is set, then the fractional part}}
\DoxyCodeLine{3475           \textcolor{comment}{//    must be at least 1/2.}}
\DoxyCodeLine{3476           \textcolor{comment}{//  -\/ When the MSB of fractional\_part is set, either}}
\DoxyCodeLine{3477           \textcolor{comment}{//    second\_third\_subsegments being nonzero or has\_more\_segments}}
\DoxyCodeLine{3478           \textcolor{comment}{//    being true means there are further digits not printed, so the}}
\DoxyCodeLine{3479           \textcolor{comment}{//    fractional part is strictly larger than 1/2.}}
\DoxyCodeLine{3480           \textcolor{keywordflow}{if} (precision < 9) \{}
\DoxyCodeLine{3481             uint32\_t fractional\_part = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(prod);}
\DoxyCodeLine{3482             should\_round\_up = fractional\_part >=}
\DoxyCodeLine{3483                                   data::fractional\_part\_rounding\_thresholds}
\DoxyCodeLine{3484                                       [8 -\/ number\_of\_digits\_to\_print] ||}
\DoxyCodeLine{3485                               ((fractional\_part >> 31) \&}
\DoxyCodeLine{3486                                ((digits \& 1) | (second\_third\_subsegments != 0) |}
\DoxyCodeLine{3487                                 has\_more\_segments)) != 0;}
\DoxyCodeLine{3488           \}}
\DoxyCodeLine{3489           \textcolor{comment}{// Rounding at the subsegment boundary.}}
\DoxyCodeLine{3490           \textcolor{comment}{// In this case, the fractional part is at least 1/2 if and only if}}
\DoxyCodeLine{3491           \textcolor{comment}{// second\_third\_subsegments >= 5000000000ULL, and is strictly larger}}
\DoxyCodeLine{3492           \textcolor{comment}{// than 1/2 if we further have either second\_third\_subsegments >}}
\DoxyCodeLine{3493           \textcolor{comment}{// 5000000000ULL or has\_more\_segments == true.}}
\DoxyCodeLine{3494           \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3495             should\_round\_up = second\_third\_subsegments > 5000000000ULL ||}
\DoxyCodeLine{3496                               (second\_third\_subsegments == 5000000000ULL \&\&}
\DoxyCodeLine{3497                                ((digits \& 1) != 0 || has\_more\_segments));}
\DoxyCodeLine{3498           \}}
\DoxyCodeLine{3499         \}}
\DoxyCodeLine{3500         \textcolor{comment}{// Otherwise, print the second subsegment.}}
\DoxyCodeLine{3501         \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3502           \textcolor{comment}{// Compilers are not aware of how to leverage the maximum value of}}
\DoxyCodeLine{3503           \textcolor{comment}{// second\_third\_subsegments to find out a better magic number which}}
\DoxyCodeLine{3504           \textcolor{comment}{// allows us to eliminate an additional shift. 1844674407370955162 =}}
\DoxyCodeLine{3505           \textcolor{comment}{// ceil(2\string^64/10) < ceil(2\string^64*(10\string^9/(10\string^10 -\/ 1))).}}
\DoxyCodeLine{3506           \textcolor{keyword}{const} uint32\_t second\_subsegment =}
\DoxyCodeLine{3507               \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(dragonbox::umul128\_upper64(}
\DoxyCodeLine{3508                   second\_third\_subsegments, 1844674407370955162ULL));}
\DoxyCodeLine{3509           \textcolor{keyword}{const} uint32\_t third\_subsegment =}
\DoxyCodeLine{3510               \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(second\_third\_subsegments) -\/}
\DoxyCodeLine{3511               second\_subsegment * 10;}
\DoxyCodeLine{3512 }
\DoxyCodeLine{3513           number\_of\_digits\_to\_print = precision -\/ 9;}
\DoxyCodeLine{3514           print\_subsegment(second\_subsegment, buf.data() + 9);}
\DoxyCodeLine{3515 }
\DoxyCodeLine{3516           \textcolor{comment}{// Rounding inside the subsegment.}}
\DoxyCodeLine{3517           \textcolor{keywordflow}{if} (precision < 18) \{}
\DoxyCodeLine{3518             \textcolor{comment}{// The condition third\_subsegment != 0 implies that the segment was}}
\DoxyCodeLine{3519             \textcolor{comment}{// of 19 digits, so in this case the third segment should be}}
\DoxyCodeLine{3520             \textcolor{comment}{// consisting of a genuine digit from the input.}}
\DoxyCodeLine{3521             uint32\_t fractional\_part = \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(prod);}
\DoxyCodeLine{3522             should\_round\_up = fractional\_part >=}
\DoxyCodeLine{3523                                   data::fractional\_part\_rounding\_thresholds}
\DoxyCodeLine{3524                                       [8 -\/ number\_of\_digits\_to\_print] ||}
\DoxyCodeLine{3525                               ((fractional\_part >> 31) \&}
\DoxyCodeLine{3526                                ((digits \& 1) | (third\_subsegment != 0) |}
\DoxyCodeLine{3527                                 has\_more\_segments)) != 0;}
\DoxyCodeLine{3528           \}}
\DoxyCodeLine{3529           \textcolor{comment}{// Rounding at the subsegment boundary.}}
\DoxyCodeLine{3530           \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3531             \textcolor{comment}{// In this case, the segment must be of 19 digits, thus}}
\DoxyCodeLine{3532             \textcolor{comment}{// the third subsegment should be consisting of a genuine digit from}}
\DoxyCodeLine{3533             \textcolor{comment}{// the input.}}
\DoxyCodeLine{3534             should\_round\_up = third\_subsegment > 5 ||}
\DoxyCodeLine{3535                               (third\_subsegment == 5 \&\&}
\DoxyCodeLine{3536                                ((digits \& 1) != 0 || has\_more\_segments));}
\DoxyCodeLine{3537           \}}
\DoxyCodeLine{3538         \}}
\DoxyCodeLine{3539 }
\DoxyCodeLine{3540         \textcolor{comment}{// Round-\/up if necessary.}}
\DoxyCodeLine{3541         \textcolor{keywordflow}{if} (should\_round\_up) \{}
\DoxyCodeLine{3542           ++buf[precision -\/ 1];}
\DoxyCodeLine{3543           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = precision -\/ 1; i > 0 \&\& buf[i] > \textcolor{charliteral}{'9'}; -\/-\/i) \{}
\DoxyCodeLine{3544             buf[i] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{3545             ++buf[i -\/ 1];}
\DoxyCodeLine{3546           \}}
\DoxyCodeLine{3547           \textcolor{keywordflow}{if} (buf[0] > \textcolor{charliteral}{'9'}) \{}
\DoxyCodeLine{3548             buf[0] = \textcolor{charliteral}{'1'};}
\DoxyCodeLine{3549             \textcolor{keywordflow}{if} (fixed)}
\DoxyCodeLine{3550               buf[precision++] = \textcolor{charliteral}{'0'};}
\DoxyCodeLine{3551             \textcolor{keywordflow}{else}}
\DoxyCodeLine{3552               ++exp;}
\DoxyCodeLine{3553           \}}
\DoxyCodeLine{3554         \}}
\DoxyCodeLine{3555         buf.try\_resize(to\_unsigned(precision));}
\DoxyCodeLine{3556       \}}
\DoxyCodeLine{3557     \}  \textcolor{comment}{// if (digits\_in\_the\_first\_segment > precision)}}
\DoxyCodeLine{3558     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{3559       \textcolor{comment}{// Adjust the exponent for its use in Dragon4.}}
\DoxyCodeLine{3560       exp += digits\_in\_the\_first\_segment -\/ 1;}
\DoxyCodeLine{3561     \}}
\DoxyCodeLine{3562   \}}
\DoxyCodeLine{3563   \textcolor{keywordflow}{if} (use\_dragon) \{}
\DoxyCodeLine{3564     \textcolor{keyword}{auto} f = basic\_fp<uint128\_t>();}
\DoxyCodeLine{3565     \textcolor{keywordtype}{bool} is\_predecessor\_closer = specs.binary32}
\DoxyCodeLine{3566                                      ? f.assign(\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(value))}
\DoxyCodeLine{3567                                      : f.assign(converted\_value);}
\DoxyCodeLine{3568     \textcolor{keywordflow}{if} (is\_predecessor\_closer) dragon\_flags |= dragon::predecessor\_closer;}
\DoxyCodeLine{3569     \textcolor{keywordflow}{if} (fixed) dragon\_flags |= dragon::fixed;}
\DoxyCodeLine{3570     \textcolor{comment}{// Limit precision to the maximum possible number of significant digits in}}
\DoxyCodeLine{3571     \textcolor{comment}{// an IEEE754 double because we don't need to generate zeros.}}
\DoxyCodeLine{3572     \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_double\_digits = 767;}
\DoxyCodeLine{3573     \textcolor{keywordflow}{if} (precision > max\_double\_digits) precision = max\_double\_digits;}
\DoxyCodeLine{3574     format\_dragon(f, dragon\_flags, precision, buf, exp);}
\DoxyCodeLine{3575   \}}
\DoxyCodeLine{3576   \textcolor{keywordflow}{if} (!fixed \&\& !specs.showpoint) \{}
\DoxyCodeLine{3577     \textcolor{comment}{// Remove trailing zeros.}}
\DoxyCodeLine{3578     \textcolor{keyword}{auto} num\_digits = buf.size();}
\DoxyCodeLine{3579     \textcolor{keywordflow}{while} (num\_digits > 0 \&\& buf[num\_digits -\/ 1] == \textcolor{charliteral}{'0'}) \{}
\DoxyCodeLine{3580       -\/-\/num\_digits;}
\DoxyCodeLine{3581       ++exp;}
\DoxyCodeLine{3582     \}}
\DoxyCodeLine{3583     buf.try\_resize(num\_digits);}
\DoxyCodeLine{3584   \}}
\DoxyCodeLine{3585   \textcolor{keywordflow}{return} exp;}
\DoxyCodeLine{3586 \}}
\DoxyCodeLine{3587 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{3588 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write\_float(OutputIt out, T value,}
\DoxyCodeLine{3589                                  \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}} specs, locale\_ref loc)}
\DoxyCodeLine{3590     -\/> OutputIt \{}
\DoxyCodeLine{3591   float\_specs fspecs = parse\_float\_type\_spec(specs);}
\DoxyCodeLine{3592   fspecs.sign = specs.sign;}
\DoxyCodeLine{3593   \textcolor{keywordflow}{if} (detail::signbit(value)) \{  \textcolor{comment}{// value < 0 is false for NaN so use signbit.}}
\DoxyCodeLine{3594     fspecs.sign = sign::minus;}
\DoxyCodeLine{3595     value = -\/value;}
\DoxyCodeLine{3596   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (fspecs.sign == sign::minus) \{}
\DoxyCodeLine{3597     fspecs.sign = sign::none;}
\DoxyCodeLine{3598   \}}
\DoxyCodeLine{3599 }
\DoxyCodeLine{3600   \textcolor{keywordflow}{if} (!detail::isfinite(value))}
\DoxyCodeLine{3601     \textcolor{keywordflow}{return} write\_nonfinite(out, detail::isnan(value), specs, fspecs);}
\DoxyCodeLine{3602 }
\DoxyCodeLine{3603   \textcolor{keywordflow}{if} (specs.align == align::numeric \&\& fspecs.sign) \{}
\DoxyCodeLine{3604     \textcolor{keyword}{auto} it = reserve(out, 1);}
\DoxyCodeLine{3605     *it++ = detail::sign<Char>(fspecs.sign);}
\DoxyCodeLine{3606     out = base\_iterator(out, it);}
\DoxyCodeLine{3607     fspecs.sign = sign::none;}
\DoxyCodeLine{3608     \textcolor{keywordflow}{if} (specs.width != 0) -\/-\/specs.width;}
\DoxyCodeLine{3609   \}}
\DoxyCodeLine{3610 }
\DoxyCodeLine{3611   \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}} buffer;}
\DoxyCodeLine{3612   \textcolor{keywordflow}{if} (fspecs.format == float\_format::hex) \{}
\DoxyCodeLine{3613     \textcolor{keywordflow}{if} (fspecs.sign) buffer.push\_back(detail::sign<char>(fspecs.sign));}
\DoxyCodeLine{3614     format\_hexfloat(convert\_float(value), specs.precision, fspecs, buffer);}
\DoxyCodeLine{3615     \textcolor{keywordflow}{return} write\_bytes<align::right>(out, \{buffer.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}(), buffer.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()\},}
\DoxyCodeLine{3616                                      specs);}
\DoxyCodeLine{3617   \}}
\DoxyCodeLine{3618   \textcolor{keywordtype}{int} precision = specs.precision >= 0 || specs.type == presentation\_type::none}
\DoxyCodeLine{3619                       ? specs.precision}
\DoxyCodeLine{3620                       : 6;}
\DoxyCodeLine{3621   \textcolor{keywordflow}{if} (fspecs.format == float\_format::exp) \{}
\DoxyCodeLine{3622     \textcolor{keywordflow}{if} (precision == max\_value<int>())}
\DoxyCodeLine{3623       throw\_format\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{3624     \textcolor{keywordflow}{else}}
\DoxyCodeLine{3625       ++precision;}
\DoxyCodeLine{3626   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (fspecs.format != float\_format::fixed \&\& precision == 0) \{}
\DoxyCodeLine{3627     precision = 1;}
\DoxyCodeLine{3628   \}}
\DoxyCodeLine{3629   \textcolor{keywordflow}{if} (const\_check(std::is\_same<T, float>())) fspecs.binary32 = \textcolor{keyword}{true};}
\DoxyCodeLine{3630   \textcolor{keywordtype}{int} exp = format\_float(convert\_float(value), precision, fspecs, buffer);}
\DoxyCodeLine{3631   fspecs.precision = precision;}
\DoxyCodeLine{3632   \textcolor{keyword}{auto} f = big\_decimal\_fp\{buffer.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}(), \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(buffer.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()), exp\};}
\DoxyCodeLine{3633   \textcolor{keywordflow}{return} write\_float(out, f, specs, fspecs, loc);}
\DoxyCodeLine{3634 \}}
\DoxyCodeLine{3635 }
\DoxyCodeLine{3636 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3637           FMT\_ENABLE\_IF(is\_floating\_point<T>::value)>}
\DoxyCodeLine{3638 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write(OutputIt out, T value, \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}} specs,}
\DoxyCodeLine{3639                            locale\_ref loc = \{\}) -\/> OutputIt \{}
\DoxyCodeLine{3640   \textcolor{keywordflow}{if} (const\_check(!is\_supported\_floating\_point(value))) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3641   \textcolor{keywordflow}{return} specs.localized \&\& write\_loc(out, value, specs, loc)}
\DoxyCodeLine{3642              ? out}
\DoxyCodeLine{3643              : write\_float(out, value, specs, loc);}
\DoxyCodeLine{3644 \}}
\DoxyCodeLine{3645 }
\DoxyCodeLine{3646 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3647           FMT\_ENABLE\_IF(is\_fast\_float<T>::value)>}
\DoxyCodeLine{3648 FMT\_CONSTEXPR20 \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{3649   \textcolor{keywordflow}{if} (is\_constant\_evaluated()) \textcolor{keywordflow}{return} write(out, value, \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}());}
\DoxyCodeLine{3650   \textcolor{keywordflow}{if} (const\_check(!is\_supported\_floating\_point(value))) \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3651 }
\DoxyCodeLine{3652   \textcolor{keyword}{auto} fspecs = float\_specs();}
\DoxyCodeLine{3653   \textcolor{keywordflow}{if} (detail::signbit(value)) \{}
\DoxyCodeLine{3654     fspecs.sign = sign::minus;}
\DoxyCodeLine{3655     value = -\/value;}
\DoxyCodeLine{3656   \}}
\DoxyCodeLine{3657 }
\DoxyCodeLine{3658   \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} specs = \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}();}
\DoxyCodeLine{3659   \textcolor{keyword}{using }floaty = conditional\_t<std::is\_same<T, long double>::value, double, T>;}
\DoxyCodeLine{3660   \textcolor{keyword}{using }floaty\_uint = \textcolor{keyword}{typename} dragonbox::float\_info<floaty>::carrier\_uint;}
\DoxyCodeLine{3661   floaty\_uint mask = exponent\_mask<floaty>();}
\DoxyCodeLine{3662   \textcolor{keywordflow}{if} ((bit\_cast<floaty\_uint>(value) \& mask) == mask)}
\DoxyCodeLine{3663     \textcolor{keywordflow}{return} write\_nonfinite(out, std::isnan(value), specs, fspecs);}
\DoxyCodeLine{3664 }
\DoxyCodeLine{3665   \textcolor{keyword}{auto} dec = dragonbox::to\_decimal(\textcolor{keyword}{static\_cast<}floaty\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3666   \textcolor{keywordflow}{return} write\_float(out, dec, specs, fspecs, \{\});}
\DoxyCodeLine{3667 \}}
\DoxyCodeLine{3668 }
\DoxyCodeLine{3669 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3670           FMT\_ENABLE\_IF(is\_floating\_point<T>::value \&\&}
\DoxyCodeLine{3671                         !is\_fast\_float<T>::value)>}
\DoxyCodeLine{3672 \textcolor{keyword}{inline} \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{3673   \textcolor{keywordflow}{return} write(out, value, \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}());}
\DoxyCodeLine{3674 \}}
\DoxyCodeLine{3675 }
\DoxyCodeLine{3676 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3677 \textcolor{keyword}{auto} write(OutputIt out, \mbox{\hyperlink{structmonostate}{monostate}}, \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}} = \{\}, locale\_ref = \{\})}
\DoxyCodeLine{3678     -\/> OutputIt \{}
\DoxyCodeLine{3679   FMT\_ASSERT(\textcolor{keyword}{false}, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{3680   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3681 \}}
\DoxyCodeLine{3682 }
\DoxyCodeLine{3683 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3684 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} value)}
\DoxyCodeLine{3685     -\/> OutputIt \{}
\DoxyCodeLine{3686   \textcolor{keyword}{auto} it = reserve(out, value.size());}
\DoxyCodeLine{3687   it = copy\_str\_noinline<Char>(value.begin(), value.end(), it);}
\DoxyCodeLine{3688   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{3689 \}}
\DoxyCodeLine{3690 }
\DoxyCodeLine{3691 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3692           FMT\_ENABLE\_IF(is\_string<T>::value)>}
\DoxyCodeLine{3693 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T\& value) -\/> OutputIt \{}
\DoxyCodeLine{3694   \textcolor{keywordflow}{return} write<Char>(out, to\_string\_view(value));}
\DoxyCodeLine{3695 \}}
\DoxyCodeLine{3696 }
\DoxyCodeLine{3697 \textcolor{comment}{// FMT\_ENABLE\_IF() condition separated to workaround an MSVC bug.}}
\DoxyCodeLine{3698 \textcolor{keyword}{template} <}
\DoxyCodeLine{3699     \textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3700     \textcolor{keywordtype}{bool} check =}
\DoxyCodeLine{3701         std::is\_enum<T>::value \&\& !std::is\_same<T, Char>::value \&\&}
\DoxyCodeLine{3702         mapped\_type\_constant<T, basic\_format\_context<OutputIt, Char>>::value !=}
\DoxyCodeLine{3703             type::custom\_type,}
\DoxyCodeLine{3704     FMT\_ENABLE\_IF(check)>}
\DoxyCodeLine{3705 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, T value) -\/> OutputIt \{}
\DoxyCodeLine{3706   \textcolor{keywordflow}{return} write<Char>(out, \textcolor{keyword}{static\_cast<}underlying\_t<T>\textcolor{keyword}{>}(value));}
\DoxyCodeLine{3707 \}}
\DoxyCodeLine{3708 }
\DoxyCodeLine{3709 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3710           FMT\_ENABLE\_IF(std::is\_same<T, bool>::value)>}
\DoxyCodeLine{3711 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, T value,}
\DoxyCodeLine{3712                          \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs = \{\}, locale\_ref = \{\})}
\DoxyCodeLine{3713     -\/> OutputIt \{}
\DoxyCodeLine{3714   \textcolor{keywordflow}{return} specs.type != presentation\_type::none \&\&}
\DoxyCodeLine{3715                  specs.type != presentation\_type::string}
\DoxyCodeLine{3716              ? write(out, value ? 1 : 0, specs, \{\})}
\DoxyCodeLine{3717              : write\_bytes(out, value ? \textcolor{stringliteral}{"{}true"{}} : \textcolor{stringliteral}{"{}false"{}}, specs);}
\DoxyCodeLine{3718 \}}
\DoxyCodeLine{3719 }
\DoxyCodeLine{3720 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3721 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, Char value) -\/> OutputIt \{}
\DoxyCodeLine{3722   \textcolor{keyword}{auto} it = reserve(out, 1);}
\DoxyCodeLine{3723   *it++ = value;}
\DoxyCodeLine{3724   \textcolor{keywordflow}{return} base\_iterator(out, it);}
\DoxyCodeLine{3725 \}}
\DoxyCodeLine{3726 }
\DoxyCodeLine{3727 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt>}
\DoxyCodeLine{3728 FMT\_CONSTEXPR\_CHAR\_TRAITS \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} Char* value)}
\DoxyCodeLine{3729     -\/> OutputIt \{}
\DoxyCodeLine{3730   \textcolor{keywordflow}{if} (value) \textcolor{keywordflow}{return} write(out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(value));}
\DoxyCodeLine{3731   throw\_format\_error(\textcolor{stringliteral}{"{}string pointer is null"{}});}
\DoxyCodeLine{3732   \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3733 \}}
\DoxyCodeLine{3734 }
\DoxyCodeLine{3735 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3736           FMT\_ENABLE\_IF(std::is\_same<T, void>::value)>}
\DoxyCodeLine{3737 \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T* value, \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs = \{\},}
\DoxyCodeLine{3738            locale\_ref = \{\}) -\/> OutputIt \{}
\DoxyCodeLine{3739   \textcolor{keywordflow}{return} write\_ptr<Char>(out, bit\_cast<uintptr\_t>(value), \&specs);}
\DoxyCodeLine{3740 \}}
\DoxyCodeLine{3741 }
\DoxyCodeLine{3742 \textcolor{comment}{// A write overload that handles implicit conversions.}}
\DoxyCodeLine{3743 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3744           \textcolor{keyword}{typename} Context = \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<OutputIt, Char>}}>}
\DoxyCodeLine{3745 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T\& value) -\/> enable\_if\_t<}
\DoxyCodeLine{3746     std::is\_class<T>::value \&\& !is\_string<T>::value \&\&}
\DoxyCodeLine{3747         !is\_floating\_point<T>::value \&\& !std::is\_same<T, Char>::value \&\&}
\DoxyCodeLine{3748         !std::is\_same<T, remove\_cvref\_t<decltype(arg\_mapper<Context>().map(}
\DoxyCodeLine{3749                              value))>>::value,}
\DoxyCodeLine{3750     OutputIt> \{}
\DoxyCodeLine{3751   \textcolor{keywordflow}{return} write<Char>(out, arg\_mapper<Context>().map(value));}
\DoxyCodeLine{3752 \}}
\DoxyCodeLine{3753 }
\DoxyCodeLine{3754 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} T,}
\DoxyCodeLine{3755           \textcolor{keyword}{typename} Context = \mbox{\hyperlink{classbasic__format__context}{basic\_format\_context<OutputIt, Char>}}>}
\DoxyCodeLine{3756 FMT\_CONSTEXPR \textcolor{keyword}{auto} write(OutputIt out, \textcolor{keyword}{const} T\& value)}
\DoxyCodeLine{3757     -\/> enable\_if\_t<mapped\_type\_constant<T, Context>::value == type::custom\_type,}
\DoxyCodeLine{3758                    OutputIt> \{}
\DoxyCodeLine{3759   \textcolor{keyword}{auto} ctx = Context(out, \{\}, \{\});}
\DoxyCodeLine{3760   \textcolor{keywordflow}{return} \textcolor{keyword}{typename} Context::template formatter\_type<T>().format(value, ctx);}
\DoxyCodeLine{3761 \}}
\DoxyCodeLine{3762 }
\DoxyCodeLine{3763 \textcolor{comment}{// An argument visitor that formats the argument and writes it via the output}}
\DoxyCodeLine{3764 \textcolor{comment}{// iterator. It's a class and not a generic lambda for compatibility with C++11.}}
\DoxyCodeLine{3765 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1default__arg__formatter}{default\_arg\_formatter}} \{}
\DoxyCodeLine{3766   \textcolor{keyword}{using }iterator = buffer\_appender<Char>;}
\DoxyCodeLine{3767   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__context}{context}} = \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>}};}
\DoxyCodeLine{3768 }
\DoxyCodeLine{3769   iterator out;}
\DoxyCodeLine{3770   \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args<context>}} args;}
\DoxyCodeLine{3771   \mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} loc;}
\DoxyCodeLine{3772 }
\DoxyCodeLine{3773   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} operator()(T \mbox{\hyperlink{classdetail_1_1value}{value}}) -\/> iterator \{}
\DoxyCodeLine{3774     \textcolor{keywordflow}{return} write<Char>(out, \mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{3775   \}}
\DoxyCodeLine{3776   \textcolor{keyword}{auto} operator()(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<context>::handle}} h) -\/> iterator \{}
\DoxyCodeLine{3777     \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}} parse\_ctx(\{\});}
\DoxyCodeLine{3778     \mbox{\hyperlink{classbasic__format__context}{context}} format\_ctx(out, args, loc);}
\DoxyCodeLine{3779     h.format(parse\_ctx, format\_ctx);}
\DoxyCodeLine{3780     \textcolor{keywordflow}{return} format\_ctx.out();}
\DoxyCodeLine{3781   \}}
\DoxyCodeLine{3782 \};}
\DoxyCodeLine{3783 }
\DoxyCodeLine{3784 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1arg__formatter}{arg\_formatter}} \{}
\DoxyCodeLine{3785   \textcolor{keyword}{using }iterator = buffer\_appender<Char>;}
\DoxyCodeLine{3786   \textcolor{keyword}{using }\mbox{\hyperlink{classbasic__format__context}{context}} = \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>}};}
\DoxyCodeLine{3787 }
\DoxyCodeLine{3788   iterator out;}
\DoxyCodeLine{3789   \textcolor{keyword}{const} \mbox{\hyperlink{structformat__specs}{format\_specs<Char>}}\& specs;}
\DoxyCodeLine{3790   \mbox{\hyperlink{classdetail_1_1locale__ref}{locale\_ref}} locale;}
\DoxyCodeLine{3791 }
\DoxyCodeLine{3792   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{3793   FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto} operator()(T \mbox{\hyperlink{classdetail_1_1value}{value}}) -\/> iterator \{}
\DoxyCodeLine{3794     \textcolor{keywordflow}{return} detail::write(out, \mbox{\hyperlink{classdetail_1_1value}{value}}, specs, locale);}
\DoxyCodeLine{3795   \}}
\DoxyCodeLine{3796   \textcolor{keyword}{auto} operator()(\textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg_1_1handle}{basic\_format\_arg<context>::handle}}) -\/> iterator \{}
\DoxyCodeLine{3797     \textcolor{comment}{// User-\/defined types are handled separately because they require access}}
\DoxyCodeLine{3798     \textcolor{comment}{// to the parse context.}}
\DoxyCodeLine{3799     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{3800   \}}
\DoxyCodeLine{3801 \};}
\DoxyCodeLine{3802 }
\DoxyCodeLine{3803 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }\mbox{\hyperlink{structdetail_1_1custom__formatter}{custom\_formatter}} \{}
\DoxyCodeLine{3804   \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}}\& parse\_ctx;}
\DoxyCodeLine{3805   \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>}}\& ctx;}
\DoxyCodeLine{3806 }
\DoxyCodeLine{3807   \textcolor{keywordtype}{void} operator()(}
\DoxyCodeLine{3808       \textcolor{keyword}{typename} \mbox{\hyperlink{classbasic__format__arg}{basic\_format\_arg}}<\mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>}}>::handle h)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3809     h.format(parse\_ctx, ctx);}
\DoxyCodeLine{3810   \}}
\DoxyCodeLine{3811   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keywordtype}{void} operator()(T)\textcolor{keyword}{ const }\{\}}
\DoxyCodeLine{3812 \};}
\DoxyCodeLine{3813 }
\DoxyCodeLine{3814 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1width__checker}{width\_checker}} \{}
\DoxyCodeLine{3815  \textcolor{keyword}{public}:}
\DoxyCodeLine{3816   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classdetail_1_1width__checker}{width\_checker}}(ErrorHandler\& eh) : handler\_(eh) \{\}}
\DoxyCodeLine{3817 }
\DoxyCodeLine{3818   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3819   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T \mbox{\hyperlink{classdetail_1_1value}{value}}) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3820     \textcolor{keywordflow}{if} (is\_negative(\mbox{\hyperlink{classdetail_1_1value}{value}})) handler\_.on\_error(\textcolor{stringliteral}{"{}negative width"{}});}
\DoxyCodeLine{3821     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{3822   \}}
\DoxyCodeLine{3823 }
\DoxyCodeLine{3824   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3825   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3826     handler\_.on\_error(\textcolor{stringliteral}{"{}width is not integer"{}});}
\DoxyCodeLine{3827     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3828   \}}
\DoxyCodeLine{3829 }
\DoxyCodeLine{3830  \textcolor{keyword}{private}:}
\DoxyCodeLine{3831   ErrorHandler\& handler\_;}
\DoxyCodeLine{3832 \};}
\DoxyCodeLine{3833 }
\DoxyCodeLine{3834 \textcolor{keyword}{template} <\textcolor{keyword}{typename} ErrorHandler> \textcolor{keyword}{class }\mbox{\hyperlink{classdetail_1_1precision__checker}{precision\_checker}} \{}
\DoxyCodeLine{3835  \textcolor{keyword}{public}:}
\DoxyCodeLine{3836   \textcolor{keyword}{explicit} FMT\_CONSTEXPR \mbox{\hyperlink{classdetail_1_1precision__checker}{precision\_checker}}(ErrorHandler\& eh) : handler\_(eh) \{\}}
\DoxyCodeLine{3837 }
\DoxyCodeLine{3838   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3839   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T \mbox{\hyperlink{classdetail_1_1value}{value}}) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3840     \textcolor{keywordflow}{if} (is\_negative(\mbox{\hyperlink{classdetail_1_1value}{value}})) handler\_.on\_error(\textcolor{stringliteral}{"{}negative precision"{}});}
\DoxyCodeLine{3841     \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long}\textcolor{keyword}{>}(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{3842   \}}
\DoxyCodeLine{3843 }
\DoxyCodeLine{3844   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!is\_\textcolor{keywordtype}{int}eger<T>::value)>}
\DoxyCodeLine{3845   FMT\_CONSTEXPR \textcolor{keyword}{auto} operator()(T) -\/> \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \{}
\DoxyCodeLine{3846     handler\_.on\_error(\textcolor{stringliteral}{"{}precision is not integer"{}});}
\DoxyCodeLine{3847     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{3848   \}}
\DoxyCodeLine{3849 }
\DoxyCodeLine{3850  \textcolor{keyword}{private}:}
\DoxyCodeLine{3851   ErrorHandler\& handler\_;}
\DoxyCodeLine{3852 \};}
\DoxyCodeLine{3853 }
\DoxyCodeLine{3854 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }Handler, \textcolor{keyword}{typename} FormatArg,}
\DoxyCodeLine{3855           \textcolor{keyword}{typename} ErrorHandler>}
\DoxyCodeLine{3856 FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_dynamic\_spec(FormatArg arg, ErrorHandler eh) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{3857   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \mbox{\hyperlink{classdetail_1_1value}{value}} = visit\_format\_arg(Handler<ErrorHandler>(eh), arg);}
\DoxyCodeLine{3858   \textcolor{keywordflow}{if} (\mbox{\hyperlink{classdetail_1_1value}{value}} > to\_unsigned(max\_value<int>())) eh.on\_error(\textcolor{stringliteral}{"{}number is too big"{}});}
\DoxyCodeLine{3859   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(\mbox{\hyperlink{classdetail_1_1value}{value}});}
\DoxyCodeLine{3860 \}}
\DoxyCodeLine{3861 }
\DoxyCodeLine{3862 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Context, \textcolor{keyword}{typename} ID>}
\DoxyCodeLine{3863 FMT\_CONSTEXPR \textcolor{keyword}{auto} get\_arg(Context\& ctx, ID \textcolor{keywordtype}{id}) -\/> \textcolor{keyword}{decltype}(ctx.arg(\textcolor{keywordtype}{id})) \{}
\DoxyCodeLine{3864   \textcolor{keyword}{auto} arg = ctx.arg(\textcolor{keywordtype}{id});}
\DoxyCodeLine{3865   \textcolor{keywordflow}{if} (!arg) ctx.on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{3866   \textcolor{keywordflow}{return} arg;}
\DoxyCodeLine{3867 \}}
\DoxyCodeLine{3868 }
\DoxyCodeLine{3869 \textcolor{keyword}{template} <\textcolor{keyword}{template} <\textcolor{keyword}{typename}> \textcolor{keyword}{class }Handler, \textcolor{keyword}{typename} Context>}
\DoxyCodeLine{3870 FMT\_CONSTEXPR \textcolor{keywordtype}{void} handle\_dynamic\_spec(\textcolor{keywordtype}{int}\& value,}
\DoxyCodeLine{3871                                        arg\_ref<typename Context::char\_type> ref,}
\DoxyCodeLine{3872                                        Context\& ctx) \{}
\DoxyCodeLine{3873   \textcolor{keywordflow}{switch} (ref.kind) \{}
\DoxyCodeLine{3874   \textcolor{keywordflow}{case} arg\_id\_kind::none:}
\DoxyCodeLine{3875     \textcolor{keywordflow}{break};}
\DoxyCodeLine{3876   \textcolor{keywordflow}{case} arg\_id\_kind::index:}
\DoxyCodeLine{3877     value = detail::get\_dynamic\_spec<Handler>(get\_arg(ctx, ref.val.index),}
\DoxyCodeLine{3878                                               ctx.error\_handler());}
\DoxyCodeLine{3879     \textcolor{keywordflow}{break};}
\DoxyCodeLine{3880   \textcolor{keywordflow}{case} arg\_id\_kind::name:}
\DoxyCodeLine{3881     value = detail::get\_dynamic\_spec<Handler>(get\_arg(ctx, ref.val.name),}
\DoxyCodeLine{3882                                               ctx.error\_handler());}
\DoxyCodeLine{3883     \textcolor{keywordflow}{break};}
\DoxyCodeLine{3884   \}}
\DoxyCodeLine{3885 \}}
\DoxyCodeLine{3886 }
\DoxyCodeLine{3887 \textcolor{preprocessor}{\#if FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{3888 \textcolor{preprocessor}{\#  if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{3889 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3890           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3891 \textcolor{keyword}{struct }statically\_named\_arg : view \{}
\DoxyCodeLine{3892   \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} name = Str.data;}
\DoxyCodeLine{3893 }
\DoxyCodeLine{3894   \textcolor{keyword}{const} T\& value;}
\DoxyCodeLine{3895   statically\_named\_arg(\textcolor{keyword}{const} T\& v) : value(v) \{\}}
\DoxyCodeLine{3896 \};}
\DoxyCodeLine{3897 }
\DoxyCodeLine{3898 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3899           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3900 \textcolor{keyword}{struct }is\_named\_arg<statically\_named\_arg<T, Char, N, Str>> : std::true\_type \{\};}
\DoxyCodeLine{3901 }
\DoxyCodeLine{3902 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3903           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3904 \textcolor{keyword}{struct }is\_statically\_named\_arg<statically\_named\_arg<T, Char, N, Str>>}
\DoxyCodeLine{3905     : std::true\_type \{\};}
\DoxyCodeLine{3906 }
\DoxyCodeLine{3907 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N,}
\DoxyCodeLine{3908           fmt::detail\_exported::fixed\_string<Char, N> Str>}
\DoxyCodeLine{3909 \textcolor{keyword}{struct }udl\_arg \{}
\DoxyCodeLine{3910   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} operator=(T\&\& value)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{3911     \textcolor{keywordflow}{return} statically\_named\_arg<T, Char, N, Str>(std::forward<T>(value));}
\DoxyCodeLine{3912   \}}
\DoxyCodeLine{3913 \};}
\DoxyCodeLine{3914 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{3915 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char> \textcolor{keyword}{struct }udl\_arg \{}
\DoxyCodeLine{3916   \textcolor{keyword}{const} Char* str;}
\DoxyCodeLine{3917 }
\DoxyCodeLine{3918   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} operator=(T\&\& value) \textcolor{keyword}{const} -\/> named\_arg<Char, T> \{}
\DoxyCodeLine{3919     \textcolor{keywordflow}{return} \{str, std::forward<T>(value)\};}
\DoxyCodeLine{3920   \}}
\DoxyCodeLine{3921 \};}
\DoxyCodeLine{3922 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{3923 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{3924 }
\DoxyCodeLine{3925 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{3926 \textcolor{keyword}{auto} vformat(\textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fmt,}
\DoxyCodeLine{3927              \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\mbox{\hyperlink{classbasic__format__context}{buffer\_context}}<type\_identity\_t<Char>>> args)}
\DoxyCodeLine{3928     -\/> std::basic\_string<Char> \{}
\DoxyCodeLine{3929   \textcolor{keyword}{auto} buf = \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char>}}();}
\DoxyCodeLine{3930   detail::vformat\_to(buf, fmt, args, \mbox{\hyperlink{classdetail_1_1locale__ref}{detail::locale\_ref}}(loc));}
\DoxyCodeLine{3931   \textcolor{keywordflow}{return} \{buf.data(), buf.size()\};}
\DoxyCodeLine{3932 \}}
\DoxyCodeLine{3933 }
\DoxyCodeLine{3934 \textcolor{keyword}{using }format\_func = void (*)(\mbox{\hyperlink{classdetail_1_1buffer}{detail::buffer<char>}}\&, int, \textcolor{keyword}{const} \textcolor{keywordtype}{char}*);}
\DoxyCodeLine{3935 }
\DoxyCodeLine{3936 FMT\_API \textcolor{keywordtype}{void} format\_error\_code(buffer<char>\& out, \textcolor{keywordtype}{int} error\_code,}
\DoxyCodeLine{3937                                \mbox{\hyperlink{classbasic__string__view}{string\_view}} message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3938 }
\DoxyCodeLine{3939 FMT\_API \textcolor{keywordtype}{void} report\_error(format\_func func, \textcolor{keywordtype}{int} error\_code,}
\DoxyCodeLine{3940                           \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3941 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{3942 }
\DoxyCodeLine{3943 FMT\_API \textcolor{keyword}{auto} vsystem\_error(\textcolor{keywordtype}{int} error\_code, \mbox{\hyperlink{classbasic__string__view}{string\_view}} format\_str,}
\DoxyCodeLine{3944                            \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> std::system\_error;}
\DoxyCodeLine{3945 }
\DoxyCodeLine{3963 \textcolor{keyword}{template} <\textcolor{keyword}{typename}... T>}
\DoxyCodeLine{3964 \textcolor{keyword}{auto} system\_error(\textcolor{keywordtype}{int} error\_code, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{3965     -\/> std::system\_error \{}
\DoxyCodeLine{3966   \textcolor{keywordflow}{return} vsystem\_error(error\_code, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{3967 \}}
\DoxyCodeLine{3968 }
\DoxyCodeLine{3985 FMT\_API \textcolor{keywordtype}{void} format\_system\_error(\mbox{\hyperlink{classdetail_1_1buffer}{detail::buffer<char>}}\& out, \textcolor{keywordtype}{int} error\_code,}
\DoxyCodeLine{3986                                  \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3987 }
\DoxyCodeLine{3988 \textcolor{comment}{// Reports a system error without throwing an exception.}}
\DoxyCodeLine{3989 \textcolor{comment}{// Can be used to report errors from destructors.}}
\DoxyCodeLine{3990 FMT\_API \textcolor{keywordtype}{void} report\_system\_error(\textcolor{keywordtype}{int} error\_code, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* message) \textcolor{keyword}{noexcept};}
\DoxyCodeLine{3991 }
\DoxyCodeLine{3993 \textcolor{keyword}{class }\mbox{\hyperlink{classformat__int}{format\_int}} \{}
\DoxyCodeLine{3994  \textcolor{keyword}{private}:}
\DoxyCodeLine{3995   \textcolor{comment}{// Buffer should be large enough to hold all digits (digits10 + 1),}}
\DoxyCodeLine{3996   \textcolor{comment}{// a sign and a null character.}}
\DoxyCodeLine{3997   \textcolor{keyword}{enum} \{ buffer\_size = std::numeric\_limits<unsigned long long>::digits10 + 3 \};}
\DoxyCodeLine{3998   \textcolor{keyword}{mutable} \textcolor{keywordtype}{char} buffer\_[buffer\_size];}
\DoxyCodeLine{3999   \textcolor{keywordtype}{char}* str\_;}
\DoxyCodeLine{4000 }
\DoxyCodeLine{4001   \textcolor{keyword}{template} <\textcolor{keyword}{typename} UInt> \textcolor{keyword}{auto} format\_unsigned(UInt value) -\/> \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{4002     \textcolor{keyword}{auto} n = \textcolor{keyword}{static\_cast<}detail::uint32\_or\_64\_or\_128\_t<UInt>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{4003     \textcolor{keywordflow}{return} detail::format\_decimal(buffer\_, n, buffer\_size -\/ 1).begin;}
\DoxyCodeLine{4004   \}}
\DoxyCodeLine{4005 }
\DoxyCodeLine{4006   \textcolor{keyword}{template} <\textcolor{keyword}{typename} Int> \textcolor{keyword}{auto} format\_signed(Int value) -\/> \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{4007     \textcolor{keyword}{auto} abs\_value = \textcolor{keyword}{static\_cast<}detail::uint32\_or\_64\_or\_128\_t<Int>\textcolor{keyword}{>}(value);}
\DoxyCodeLine{4008     \textcolor{keywordtype}{bool} negative = value < 0;}
\DoxyCodeLine{4009     \textcolor{keywordflow}{if} (negative) abs\_value = 0 -\/ abs\_value;}
\DoxyCodeLine{4010     \textcolor{keyword}{auto} begin = format\_unsigned(abs\_value);}
\DoxyCodeLine{4011     \textcolor{keywordflow}{if} (negative) *-\/-\/begin = \textcolor{charliteral}{'-\/'};}
\DoxyCodeLine{4012     \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{4013   \}}
\DoxyCodeLine{4014 }
\DoxyCodeLine{4015  \textcolor{keyword}{public}:}
\DoxyCodeLine{4016   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{int} value) : str\_(format\_signed(value)) \{\}}
\DoxyCodeLine{4017   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{long} value) : str\_(format\_signed(value)) \{\}}
\DoxyCodeLine{4018   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value) : str\_(format\_signed(value)) \{\}}
\DoxyCodeLine{4019   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} value) : str\_(format\_unsigned(value)) \{\}}
\DoxyCodeLine{4020   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} value) : str\_(format\_unsigned(value)) \{\}}
\DoxyCodeLine{4021   \textcolor{keyword}{explicit} \mbox{\hyperlink{classformat__int}{format\_int}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} value)}
\DoxyCodeLine{4022       : str\_(format\_unsigned(value)) \{\}}
\DoxyCodeLine{4023 }
\DoxyCodeLine{4025   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_a2f1870d4b535ead8699717fdcb25e997}{size}}() const -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{4026     \textcolor{keywordflow}{return} detail::to\_unsigned(buffer\_ -\/ str\_ + buffer\_size -\/ 1);}
\DoxyCodeLine{4027   \}}
\DoxyCodeLine{4028 }
\DoxyCodeLine{4033   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_ac8f7ea8ed9a0d5bdfa5cb0661e8851b8}{data}}() const -\/> const \textcolor{keywordtype}{char}* \{ \textcolor{keywordflow}{return} str\_; \}}
\DoxyCodeLine{4034 }
\DoxyCodeLine{4039   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_aadfe4e08e0007018df9c78863ad13d23}{c\_str}}() const -\/> const \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{4040     buffer\_[buffer\_size -\/ 1] = \textcolor{charliteral}{'\(\backslash\)0'};}
\DoxyCodeLine{4041     \textcolor{keywordflow}{return} str\_;}
\DoxyCodeLine{4042   \}}
\DoxyCodeLine{4043 }
\DoxyCodeLine{4049   \textcolor{keyword}{auto} \mbox{\hyperlink{classformat__int_a0f1b5493b06b98edb747737ba864f86f}{str}}() const -\/> std::\textcolor{keywordtype}{string} \{ \textcolor{keywordflow}{return} std::string(str\_, \mbox{\hyperlink{classformat__int_a2f1870d4b535ead8699717fdcb25e997}{size}}()); \}}
\DoxyCodeLine{4050 \};}
\DoxyCodeLine{4051 }
\DoxyCodeLine{4052 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{4053 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<T, Char, enable\_if\_t<detail::has\_format\_as<T>::value>>}
\DoxyCodeLine{4054     : \textcolor{keyword}{private} \mbox{\hyperlink{structformatter}{formatter}}<detail::format\_as\_t<T>, Char> \{}
\DoxyCodeLine{4055   \textcolor{keyword}{using }\mbox{\hyperlink{structformatter}{base}} = \mbox{\hyperlink{structformatter}{formatter<detail::format\_as\_t<T>}}, Char>;}
\DoxyCodeLine{4056   \textcolor{keyword}{using }base::parse;}
\DoxyCodeLine{4057 }
\DoxyCodeLine{4058   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{4059   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} T\& value, FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{4060     \textcolor{keywordflow}{return} base::format(format\_as(value), ctx);}
\DoxyCodeLine{4061   \}}
\DoxyCodeLine{4062 \};}
\DoxyCodeLine{4063 }
\DoxyCodeLine{4064 \textcolor{preprocessor}{\#define FMT\_FORMAT\_AS(Type, Base) \(\backslash\)}}
\DoxyCodeLine{4065 \textcolor{preprocessor}{  template <typename Char>        \(\backslash\)}}
\DoxyCodeLine{4066 \textcolor{preprocessor}{  struct formatter<Type, Char> : formatter<Base, Char> \{\}}}
\DoxyCodeLine{4067 }
\DoxyCodeLine{4068 FMT\_FORMAT\_AS(\textcolor{keywordtype}{signed} \textcolor{keywordtype}{char}, \textcolor{keywordtype}{int});}
\DoxyCodeLine{4069 FMT\_FORMAT\_AS(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}, \textcolor{keywordtype}{unsigned});}
\DoxyCodeLine{4070 FMT\_FORMAT\_AS(\textcolor{keywordtype}{short}, \textcolor{keywordtype}{int});}
\DoxyCodeLine{4071 FMT\_FORMAT\_AS(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short}, \textcolor{keywordtype}{unsigned});}
\DoxyCodeLine{4072 FMT\_FORMAT\_AS(\textcolor{keywordtype}{long}, detail::long\_type);}
\DoxyCodeLine{4073 FMT\_FORMAT\_AS(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}, detail::ulong\_type);}
\DoxyCodeLine{4074 FMT\_FORMAT\_AS(Char*, \textcolor{keyword}{const} Char*);}
\DoxyCodeLine{4075 FMT\_FORMAT\_AS(std::basic\_string<Char>, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}});}
\DoxyCodeLine{4076 FMT\_FORMAT\_AS(std::nullptr\_t, \textcolor{keyword}{const} \textcolor{keywordtype}{void}*);}
\DoxyCodeLine{4077 FMT\_FORMAT\_AS(\mbox{\hyperlink{structdetail_1_1std__string__view}{detail::std\_string\_view<Char>}}, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}});}
\DoxyCodeLine{4078 FMT\_FORMAT\_AS(\textcolor{keywordtype}{void}*, \textcolor{keyword}{const} \textcolor{keywordtype}{void}*);}
\DoxyCodeLine{4079 }
\DoxyCodeLine{4080 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} N>}
\DoxyCodeLine{4081 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<Char[N], Char> : \mbox{\hyperlink{structformatter}{formatter}}<basic\_string\_view<Char>, Char> \{\};}
\DoxyCodeLine{4082 }
\DoxyCodeLine{4092 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} ptr(T p) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{4093   \textcolor{keyword}{static\_assert}(std::is\_pointer<T>::value, \textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{4094   \textcolor{keywordflow}{return} detail::bit\_cast<const void*>(p);}
\DoxyCodeLine{4095 \}}
\DoxyCodeLine{4096 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Deleter>}
\DoxyCodeLine{4097 \textcolor{keyword}{auto} ptr(\textcolor{keyword}{const} std::unique\_ptr<T, Deleter>\& p) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{4098   \textcolor{keywordflow}{return} p.get();}
\DoxyCodeLine{4099 \}}
\DoxyCodeLine{4100 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} ptr(\textcolor{keyword}{const} std::shared\_ptr<T>\& p) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{void}* \{}
\DoxyCodeLine{4101   \textcolor{keywordflow}{return} p.get();}
\DoxyCodeLine{4102 \}}
\DoxyCodeLine{4103 }
\DoxyCodeLine{4114 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Enum>}
\DoxyCodeLine{4115 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} underlying(Enum e) \textcolor{keyword}{noexcept} -\/> underlying\_t<Enum> \{}
\DoxyCodeLine{4116   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}underlying\_t<Enum>\textcolor{keyword}{>}(e);}
\DoxyCodeLine{4117 \}}
\DoxyCodeLine{4118 }
\DoxyCodeLine{4119 \textcolor{keyword}{namespace }enums \{}
\DoxyCodeLine{4120 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Enum, FMT\_ENABLE\_IF(std::is\_enum<Enum>::value)>}
\DoxyCodeLine{4121 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} format\_as(Enum e) \textcolor{keyword}{noexcept} -\/> underlying\_t<Enum> \{}
\DoxyCodeLine{4122   \textcolor{keywordflow}{return} \textcolor{keyword}{static\_cast<}underlying\_t<Enum>\textcolor{keyword}{>}(e);}
\DoxyCodeLine{4123 \}}
\DoxyCodeLine{4124 \}  \textcolor{comment}{// namespace enums}}
\DoxyCodeLine{4125 }
\DoxyCodeLine{4126 \textcolor{keyword}{class }\mbox{\hyperlink{classbytes}{bytes}} \{}
\DoxyCodeLine{4127  \textcolor{keyword}{private}:}
\DoxyCodeLine{4128   \mbox{\hyperlink{classbasic__string__view}{string\_view}} data\_;}
\DoxyCodeLine{4129   \textcolor{keyword}{friend} \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{classbytes}{bytes}}>;}
\DoxyCodeLine{4130 }
\DoxyCodeLine{4131  \textcolor{keyword}{public}:}
\DoxyCodeLine{4132   \textcolor{keyword}{explicit} \mbox{\hyperlink{classbytes}{bytes}}(\mbox{\hyperlink{classbasic__string__view}{string\_view}} data) : data\_(data) \{\}}
\DoxyCodeLine{4133 \};}
\DoxyCodeLine{4134 }
\DoxyCodeLine{4135 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{classbytes}{bytes}}> \{}
\DoxyCodeLine{4136  \textcolor{keyword}{private}:}
\DoxyCodeLine{4137   \mbox{\hyperlink{structdetail_1_1dynamic__format__specs}{detail::dynamic\_format\_specs<>}} specs\_;}
\DoxyCodeLine{4138 }
\DoxyCodeLine{4139  \textcolor{keyword}{public}:}
\DoxyCodeLine{4140   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{4141   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{4142     \textcolor{keywordflow}{return} parse\_format\_specs(ctx.begin(), ctx.end(), specs\_, ctx,}
\DoxyCodeLine{4143                               detail::type::string\_type);}
\DoxyCodeLine{4144   \}}
\DoxyCodeLine{4145 }
\DoxyCodeLine{4146   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{4147   \textcolor{keyword}{auto} format(\mbox{\hyperlink{classbytes}{bytes}} b, FormatContext\& ctx) -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{4148     detail::handle\_dynamic\_spec<detail::width\_checker>(specs\_.width,}
\DoxyCodeLine{4149                                                        specs\_.width\_ref, ctx);}
\DoxyCodeLine{4150     detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{4151         specs\_.precision, specs\_.precision\_ref, ctx);}
\DoxyCodeLine{4152     \textcolor{keywordflow}{return} detail::write\_bytes(ctx.out(), b.data\_, specs\_);}
\DoxyCodeLine{4153   \}}
\DoxyCodeLine{4154 \};}
\DoxyCodeLine{4155 }
\DoxyCodeLine{4156 \textcolor{comment}{// group\_digits\_view is not derived from view because it copies the argument.}}
\DoxyCodeLine{4157 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structgroup__digits__view}{group\_digits\_view}} \{}
\DoxyCodeLine{4158   T value;}
\DoxyCodeLine{4159 \};}
\DoxyCodeLine{4160 }
\DoxyCodeLine{4172 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{auto} group\_digits(T value) -\/> \mbox{\hyperlink{structgroup__digits__view}{group\_digits\_view<T>}} \{}
\DoxyCodeLine{4173   \textcolor{keywordflow}{return} \{value\};}
\DoxyCodeLine{4174 \}}
\DoxyCodeLine{4175 }
\DoxyCodeLine{4176 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{structgroup__digits__view}{group\_digits\_view}}<T>> : \mbox{\hyperlink{structformatter}{formatter}}<T> \{}
\DoxyCodeLine{4177  \textcolor{keyword}{private}:}
\DoxyCodeLine{4178   \mbox{\hyperlink{structdetail_1_1dynamic__format__specs}{detail::dynamic\_format\_specs<>}} specs\_;}
\DoxyCodeLine{4179 }
\DoxyCodeLine{4180  \textcolor{keyword}{public}:}
\DoxyCodeLine{4181   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{4182   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \{}
\DoxyCodeLine{4183     \textcolor{keywordflow}{return} parse\_format\_specs(ctx.begin(), ctx.end(), specs\_, ctx,}
\DoxyCodeLine{4184                               detail::type::int\_type);}
\DoxyCodeLine{4185   \}}
\DoxyCodeLine{4186 }
\DoxyCodeLine{4187   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{4188   \textcolor{keyword}{auto} format(\mbox{\hyperlink{structgroup__digits__view}{group\_digits\_view<T>}} t, FormatContext\& ctx)}
\DoxyCodeLine{4189       -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{4190     detail::handle\_dynamic\_spec<detail::width\_checker>(specs\_.width,}
\DoxyCodeLine{4191                                                        specs\_.width\_ref, ctx);}
\DoxyCodeLine{4192     detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{4193         specs\_.precision, specs\_.precision\_ref, ctx);}
\DoxyCodeLine{4194     \textcolor{keywordflow}{return} detail::write\_int(}
\DoxyCodeLine{4195         ctx.out(), \textcolor{keyword}{static\_cast<}detail::uint64\_or\_128\_t<T>\textcolor{keyword}{>}(t.value), 0, specs\_,}
\DoxyCodeLine{4196         \mbox{\hyperlink{classdetail_1_1digit__grouping}{detail::digit\_grouping<char>}}(\textcolor{stringliteral}{"{}\(\backslash\)3"{}}, \textcolor{stringliteral}{"{},"{}}));}
\DoxyCodeLine{4197   \}}
\DoxyCodeLine{4198 \};}
\DoxyCodeLine{4199 }
\DoxyCodeLine{4200 \textcolor{comment}{// DEPRECATED! join\_view will be moved to ranges.h.}}
\DoxyCodeLine{4201 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Sentinel, \textcolor{keyword}{typename} Char = \textcolor{keywordtype}{char}>}
\DoxyCodeLine{4202 \textcolor{keyword}{struct }\mbox{\hyperlink{structjoin__view}{join\_view}} : \mbox{\hyperlink{structdetail_1_1view}{detail::view}} \{}
\DoxyCodeLine{4203   It begin;}
\DoxyCodeLine{4204   Sentinel end;}
\DoxyCodeLine{4205   \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} sep;}
\DoxyCodeLine{4206 }
\DoxyCodeLine{4207   \mbox{\hyperlink{structjoin__view}{join\_view}}(It b, Sentinel e, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} s)}
\DoxyCodeLine{4208       : begin(b), end(e), sep(s) \{\}}
\DoxyCodeLine{4209 \};}
\DoxyCodeLine{4210 }
\DoxyCodeLine{4211 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Sentinel, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{4212 \textcolor{keyword}{struct }\mbox{\hyperlink{structformatter}{formatter}}<\mbox{\hyperlink{structjoin__view}{join\_view}}<It, Sentinel, Char>, Char> \{}
\DoxyCodeLine{4213  \textcolor{keyword}{private}:}
\DoxyCodeLine{4214   \textcolor{keyword}{using }value\_type =}
\DoxyCodeLine{4215 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_ranges}}
\DoxyCodeLine{4216       std::iter\_value\_t<It>;}
\DoxyCodeLine{4217 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4218       \textcolor{keyword}{typename} std::iterator\_traits<It>::value\_type;}
\DoxyCodeLine{4219 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4220   \mbox{\hyperlink{structformatter}{formatter<remove\_cvref\_t<value\_type>}}, Char> value\_formatter\_;}
\DoxyCodeLine{4221 }
\DoxyCodeLine{4222  \textcolor{keyword}{public}:}
\DoxyCodeLine{4223   \textcolor{keyword}{template} <\textcolor{keyword}{typename} ParseContext>}
\DoxyCodeLine{4224   FMT\_CONSTEXPR \textcolor{keyword}{auto} parse(ParseContext\& ctx) -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{4225     \textcolor{keywordflow}{return} value\_formatter\_.parse(ctx);}
\DoxyCodeLine{4226   \}}
\DoxyCodeLine{4227 }
\DoxyCodeLine{4228   \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{4229   \textcolor{keyword}{auto} format(\textcolor{keyword}{const} \mbox{\hyperlink{structjoin__view}{join\_view<It, Sentinel, Char>}}\& value,}
\DoxyCodeLine{4230               FormatContext\& ctx) \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{4231     \textcolor{keyword}{auto} it = value.begin;}
\DoxyCodeLine{4232     \textcolor{keyword}{auto} out = ctx.out();}
\DoxyCodeLine{4233     \textcolor{keywordflow}{if} (it != value.end) \{}
\DoxyCodeLine{4234       out = value\_formatter\_.format(*it, ctx);}
\DoxyCodeLine{4235       ++it;}
\DoxyCodeLine{4236       \textcolor{keywordflow}{while} (it != value.end) \{}
\DoxyCodeLine{4237         out = detail::copy\_str<Char>(value.sep.begin(), value.sep.end(), out);}
\DoxyCodeLine{4238         ctx.advance\_to(out);}
\DoxyCodeLine{4239         out = value\_formatter\_.format(*it, ctx);}
\DoxyCodeLine{4240         ++it;}
\DoxyCodeLine{4241       \}}
\DoxyCodeLine{4242     \}}
\DoxyCodeLine{4243     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{4244   \}}
\DoxyCodeLine{4245 \};}
\DoxyCodeLine{4246 }
\DoxyCodeLine{4251 \textcolor{keyword}{template} <\textcolor{keyword}{typename} It, \textcolor{keyword}{typename} Sentinel>}
\DoxyCodeLine{4252 \textcolor{keyword}{auto} join(It begin, Sentinel end, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep) -\/> \mbox{\hyperlink{structjoin__view}{join\_view<It, Sentinel>}} \{}
\DoxyCodeLine{4253   \textcolor{keywordflow}{return} \{begin, end, sep\};}
\DoxyCodeLine{4254 \}}
\DoxyCodeLine{4255 }
\DoxyCodeLine{4272 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Range>}
\DoxyCodeLine{4273 \textcolor{keyword}{auto} join(Range\&\& range, \mbox{\hyperlink{classbasic__string__view}{string\_view}} sep)}
\DoxyCodeLine{4274     -\/> \mbox{\hyperlink{structjoin__view}{join\_view<detail::iterator\_t<Range>}}, detail::sentinel\_t<Range>> \{}
\DoxyCodeLine{4275   \textcolor{keywordflow}{return} join(std::begin(range), std::end(range), sep);}
\DoxyCodeLine{4276 \}}
\DoxyCodeLine{4277 }
\DoxyCodeLine{4289 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(!std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{4290 \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string(\textcolor{keyword}{const} T\& value) -\/> std::string \{}
\DoxyCodeLine{4291   \textcolor{keyword}{auto} buffer = \mbox{\hyperlink{classbasic__memory__buffer}{memory\_buffer}}();}
\DoxyCodeLine{4292   detail::write<char>(\mbox{\hyperlink{classappender}{appender}}(buffer), value);}
\DoxyCodeLine{4293   \textcolor{keywordflow}{return} \{buffer.\mbox{\hyperlink{classdetail_1_1buffer_aeb33e0a2d2be2bbca9e0236c148089c8}{data}}(), buffer.\mbox{\hyperlink{classdetail_1_1buffer_a8685285932360c284d19003fc4ba3edc}{size}}()\};}
\DoxyCodeLine{4294 \}}
\DoxyCodeLine{4295 }
\DoxyCodeLine{4296 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, FMT\_ENABLE\_IF(std::is\_\textcolor{keywordtype}{int}egral<T>::value)>}
\DoxyCodeLine{4297 FMT\_NODISCARD \textcolor{keyword}{inline} \textcolor{keyword}{auto} to\_string(T value) -\/> std::string \{}
\DoxyCodeLine{4298   \textcolor{comment}{// The buffer should be large enough to store the number including the sign}}
\DoxyCodeLine{4299   \textcolor{comment}{// or "{}false"{} for bool.}}
\DoxyCodeLine{4300   \textcolor{keyword}{constexpr} \textcolor{keywordtype}{int} max\_size = detail::digits10<T>() + 2;}
\DoxyCodeLine{4301   \textcolor{keywordtype}{char} buffer[max\_size > 5 ? \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(max\_size) : 5];}
\DoxyCodeLine{4302   \textcolor{keywordtype}{char}* begin = buffer;}
\DoxyCodeLine{4303   \textcolor{keywordflow}{return} std::string(begin, detail::write<char>(begin, value));}
\DoxyCodeLine{4304 \}}
\DoxyCodeLine{4305 }
\DoxyCodeLine{4306 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char, \textcolor{keywordtype}{size\_t} SIZE>}
\DoxyCodeLine{4307 FMT\_NODISCARD \textcolor{keyword}{auto} to\_string(\textcolor{keyword}{const} \mbox{\hyperlink{classbasic__memory__buffer}{basic\_memory\_buffer<Char, SIZE>}}\& buf)}
\DoxyCodeLine{4308     -\/> std::basic\_string<Char> \{}
\DoxyCodeLine{4309   \textcolor{keyword}{auto} size = buf.size();}
\DoxyCodeLine{4310   detail::assume(size < std::basic\_string<Char>().max\_size());}
\DoxyCodeLine{4311   \textcolor{keywordflow}{return} std::basic\_string<Char>(buf.data(), size);}
\DoxyCodeLine{4312 \}}
\DoxyCodeLine{4313 }
\DoxyCodeLine{4314 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{4315 }
\DoxyCodeLine{4316 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Char>}
\DoxyCodeLine{4317 \textcolor{keywordtype}{void} vformat\_to(buffer<Char>\& buf, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} fmt,}
\DoxyCodeLine{4318                 \textcolor{keyword}{typename} vformat\_args<Char>::type args, locale\_ref loc) \{}
\DoxyCodeLine{4319   \textcolor{keyword}{auto} out = buffer\_appender<Char>(buf);}
\DoxyCodeLine{4320   \textcolor{keywordflow}{if} (fmt.\mbox{\hyperlink{classbasic__string__view_a216bbe1b012b590698d7bb4e96d1af3f}{size}}() == 2 \&\& equal2(fmt.\mbox{\hyperlink{classbasic__string__view_a39cdfe061dc6d64a3adc230b62d8a026}{data}}(), \textcolor{stringliteral}{"{}\{\}"{}})) \{}
\DoxyCodeLine{4321     \textcolor{keyword}{auto} arg = args.get(0);}
\DoxyCodeLine{4322     \textcolor{keywordflow}{if} (!arg) error\_handler().on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{4323     visit\_format\_arg(default\_arg\_formatter<Char>\{out, args, loc\}, arg);}
\DoxyCodeLine{4324     \textcolor{keywordflow}{return};}
\DoxyCodeLine{4325   \}}
\DoxyCodeLine{4326 }
\DoxyCodeLine{4327   \textcolor{keyword}{struct }format\_handler : error\_handler \{}
\DoxyCodeLine{4328     \mbox{\hyperlink{classbasic__format__parse__context}{basic\_format\_parse\_context<Char>}} parse\_context;}
\DoxyCodeLine{4329     \mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>}} context;}
\DoxyCodeLine{4330 }
\DoxyCodeLine{4331     format\_handler(buffer\_appender<Char> p\_out, \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} str,}
\DoxyCodeLine{4332                    \mbox{\hyperlink{classbasic__format__args}{basic\_format\_args}}<\mbox{\hyperlink{classbasic__format__context}{buffer\_context<Char>}}> p\_args,}
\DoxyCodeLine{4333                    locale\_ref p\_loc)}
\DoxyCodeLine{4334         : parse\_context(str), context(p\_out, p\_args, p\_loc) \{\}}
\DoxyCodeLine{4335 }
\DoxyCodeLine{4336     \textcolor{keywordtype}{void} on\_text(\textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end) \{}
\DoxyCodeLine{4337       \textcolor{keyword}{auto} text = \mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}}(begin, to\_unsigned(end -\/ begin));}
\DoxyCodeLine{4338       context.advance\_to(write<Char>(context.out(), text));}
\DoxyCodeLine{4339     \}}
\DoxyCodeLine{4340 }
\DoxyCodeLine{4341     FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id() -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{4342       \textcolor{keywordflow}{return} parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_a152d3961cfbc244624a877d827fc1172}{next\_arg\_id}}();}
\DoxyCodeLine{4343     \}}
\DoxyCodeLine{4344     FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{4345       \textcolor{keywordflow}{return} parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_a83f130644eeb162a932245c95447cf63}{check\_arg\_id}}(\textcolor{keywordtype}{id}), id;}
\DoxyCodeLine{4346     \}}
\DoxyCodeLine{4347     FMT\_CONSTEXPR \textcolor{keyword}{auto} on\_arg\_id(\mbox{\hyperlink{classbasic__string__view}{basic\_string\_view<Char>}} \textcolor{keywordtype}{id}) -\/> \textcolor{keywordtype}{int} \{}
\DoxyCodeLine{4348       \textcolor{keywordtype}{int} arg\_id = context.arg\_id(\textcolor{keywordtype}{id});}
\DoxyCodeLine{4349       \textcolor{keywordflow}{if} (arg\_id < 0) on\_error(\textcolor{stringliteral}{"{}argument not found"{}});}
\DoxyCodeLine{4350       \textcolor{keywordflow}{return} arg\_id;}
\DoxyCodeLine{4351     \}}
\DoxyCodeLine{4352 }
\DoxyCodeLine{4353     FMT\_INLINE \textcolor{keywordtype}{void} on\_replacement\_field(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keyword}{const} Char*) \{}
\DoxyCodeLine{4354       \textcolor{keyword}{auto} arg = get\_arg(context, \textcolor{keywordtype}{id});}
\DoxyCodeLine{4355       context.advance\_to(visit\_format\_arg(}
\DoxyCodeLine{4356           default\_arg\_formatter<Char>\{context.out(), context.args(),}
\DoxyCodeLine{4357                                       context.locale()\},}
\DoxyCodeLine{4358           arg));}
\DoxyCodeLine{4359     \}}
\DoxyCodeLine{4360 }
\DoxyCodeLine{4361     \textcolor{keyword}{auto} on\_format\_specs(\textcolor{keywordtype}{int} \textcolor{keywordtype}{id}, \textcolor{keyword}{const} Char* begin, \textcolor{keyword}{const} Char* end)}
\DoxyCodeLine{4362         -\/> \textcolor{keyword}{const} Char* \{}
\DoxyCodeLine{4363       \textcolor{keyword}{auto} arg = get\_arg(context, \textcolor{keywordtype}{id});}
\DoxyCodeLine{4364       \textcolor{keywordflow}{if} (arg.type() == type::custom\_type) \{}
\DoxyCodeLine{4365         parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_ad18dcd3d0fbeb0174569b88da00c87f2}{advance\_to}}(begin);}
\DoxyCodeLine{4366         visit\_format\_arg(custom\_formatter<Char>\{parse\_context, context\}, arg);}
\DoxyCodeLine{4367         \textcolor{keywordflow}{return} parse\_context.\mbox{\hyperlink{classbasic__format__parse__context_afb21ddaa0d32b5430f99eed530666ea9}{begin}}();}
\DoxyCodeLine{4368       \}}
\DoxyCodeLine{4369       \textcolor{keyword}{auto} specs = \mbox{\hyperlink{structdetail_1_1dynamic__format__specs}{detail::dynamic\_format\_specs<Char>}}();}
\DoxyCodeLine{4370       begin = parse\_format\_specs(begin, end, specs, parse\_context, arg.type());}
\DoxyCodeLine{4371       detail::handle\_dynamic\_spec<detail::width\_checker>(}
\DoxyCodeLine{4372           specs.width, specs.width\_ref, context);}
\DoxyCodeLine{4373       detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{4374           specs.precision, specs.precision\_ref, context);}
\DoxyCodeLine{4375       \textcolor{keywordflow}{if} (begin == end || *begin != \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{4376         on\_error(\textcolor{stringliteral}{"{}missing '\}' in format string"{}});}
\DoxyCodeLine{4377       \textcolor{keyword}{auto} f = arg\_formatter<Char>\{context.out(), specs, context.locale()\};}
\DoxyCodeLine{4378       context.advance\_to(visit\_format\_arg(f, arg));}
\DoxyCodeLine{4379       \textcolor{keywordflow}{return} begin;}
\DoxyCodeLine{4380     \}}
\DoxyCodeLine{4381   \};}
\DoxyCodeLine{4382   detail::parse\_format\_string<false>(fmt, format\_handler(out, fmt, args, loc));}
\DoxyCodeLine{4383 \}}
\DoxyCodeLine{4384 }
\DoxyCodeLine{4385 \textcolor{preprocessor}{\#ifndef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{4386 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keywordtype}{void} vformat\_to(buffer<char>\&, \mbox{\hyperlink{classbasic__string__view}{string\_view}},}
\DoxyCodeLine{4387                                         \textcolor{keyword}{typename} vformat\_args<>::type,}
\DoxyCodeLine{4388                                         locale\_ref);}
\DoxyCodeLine{4389 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} thousands\_sep\_impl<char>(locale\_ref)}
\DoxyCodeLine{4390     -\/> thousands\_sep\_result<char>;}
\DoxyCodeLine{4391 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} thousands\_sep\_impl<wchar\_t>(locale\_ref)}
\DoxyCodeLine{4392     -\/> thousands\_sep\_result<wchar\_t>;}
\DoxyCodeLine{4393 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} decimal\_point\_impl(locale\_ref) -\/> char;}
\DoxyCodeLine{4394 \textcolor{keyword}{extern} \textcolor{keyword}{template} FMT\_API \textcolor{keyword}{auto} decimal\_point\_impl(locale\_ref) -\/> wchar\_t;}
\DoxyCodeLine{4395 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_HEADER\_ONLY}}
\DoxyCodeLine{4396 }
\DoxyCodeLine{4397 \}  \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{4398 }
\DoxyCodeLine{4399 \textcolor{preprocessor}{\#if FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{4400 \textcolor{keyword}{inline} \textcolor{keyword}{namespace }literals \{}
\DoxyCodeLine{4411 \textcolor{preprocessor}{\#  if FMT\_USE\_NONTYPE\_TEMPLATE\_ARGS}}
\DoxyCodeLine{4412 \textcolor{keyword}{template} <detail\_exported::fixed\_\textcolor{keywordtype}{string} Str> \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}}\_a() \{}
\DoxyCodeLine{4413   \textcolor{keyword}{using }char\_t = remove\_cvref\_t<\textcolor{keyword}{decltype}(Str.data[0])>;}
\DoxyCodeLine{4414   \textcolor{keywordflow}{return} detail::udl\_arg<char\_t, \textcolor{keyword}{sizeof}(Str.data) / \textcolor{keyword}{sizeof}(char\_t), Str>();}
\DoxyCodeLine{4415 \}}
\DoxyCodeLine{4416 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{4417 \textcolor{keyword}{constexpr} \textcolor{keyword}{auto} \textcolor{keyword}{operator}\textcolor{stringliteral}{"{}"{}} \_a(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, \textcolor{keywordtype}{size\_t}) -\/> detail::udl\_arg<char> \{}
\DoxyCodeLine{4418   \textcolor{keywordflow}{return} \{s\};}
\DoxyCodeLine{4419 \}}
\DoxyCodeLine{4420 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{4421 \}  \textcolor{comment}{// namespace literals}}
\DoxyCodeLine{4422 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_USE\_USER\_DEFINED\_LITERALS}}
\DoxyCodeLine{4423 }
\DoxyCodeLine{4424 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale, FMT\_ENABLE\_IF(detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4425 \textcolor{keyword}{inline} \textcolor{keyword}{auto} vformat(\textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt, \mbox{\hyperlink{classbasic__format__args}{format\_args}} args)}
\DoxyCodeLine{4426     -\/> std::string \{}
\DoxyCodeLine{4427   \textcolor{keywordflow}{return} detail::vformat(loc, fmt, args);}
\DoxyCodeLine{4428 \}}
\DoxyCodeLine{4429 }
\DoxyCodeLine{4430 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{4431           FMT\_ENABLE\_IF(detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4432 \textcolor{keyword}{inline} \textcolor{keyword}{auto} format(\textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args)}
\DoxyCodeLine{4433     -\/> std::string \{}
\DoxyCodeLine{4434   \textcolor{keywordflow}{return} fmt::vformat(loc, \mbox{\hyperlink{classbasic__string__view}{string\_view}}(fmt), fmt::make\_format\_args(args...));}
\DoxyCodeLine{4435 \}}
\DoxyCodeLine{4436 }
\DoxyCodeLine{4437 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Locale,}
\DoxyCodeLine{4438           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__output__iterator}{detail::is\_output\_iterator<OutputIt, char>::value}}\&\&}
\DoxyCodeLine{4439                             detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4440 \textcolor{keyword}{auto} vformat\_to(OutputIt out, \textcolor{keyword}{const} Locale\& loc, \mbox{\hyperlink{classbasic__string__view}{string\_view}} fmt,}
\DoxyCodeLine{4441                 \mbox{\hyperlink{classbasic__format__args}{format\_args}} args) -\/> OutputIt \{}
\DoxyCodeLine{4442   \textcolor{keyword}{using }detail::get\_buffer;}
\DoxyCodeLine{4443   \textcolor{keyword}{auto}\&\& buf = get\_buffer<char>(out);}
\DoxyCodeLine{4444   detail::vformat\_to(buf, fmt, args, \mbox{\hyperlink{classdetail_1_1locale__ref}{detail::locale\_ref}}(loc));}
\DoxyCodeLine{4445   \textcolor{keywordflow}{return} detail::get\_iterator(buf, out);}
\DoxyCodeLine{4446 \}}
\DoxyCodeLine{4447 }
\DoxyCodeLine{4448 \textcolor{keyword}{template} <\textcolor{keyword}{typename} OutputIt, \textcolor{keyword}{typename} Locale, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{4449           FMT\_ENABLE\_IF(\mbox{\hyperlink{structdetail_1_1is__output__iterator}{detail::is\_output\_iterator<OutputIt, char>::value}}\&\&}
\DoxyCodeLine{4450                             detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4451 FMT\_INLINE \textcolor{keyword}{auto} format\_to(OutputIt out, \textcolor{keyword}{const} Locale\& loc,}
\DoxyCodeLine{4452                           \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt, T\&\&... args) -\/> OutputIt \{}
\DoxyCodeLine{4453   \textcolor{keywordflow}{return} vformat\_to(out, loc, fmt, fmt::make\_format\_args(args...));}
\DoxyCodeLine{4454 \}}
\DoxyCodeLine{4455 }
\DoxyCodeLine{4456 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Locale, \textcolor{keyword}{typename}... T,}
\DoxyCodeLine{4457           FMT\_ENABLE\_IF(detail::is\_locale<Locale>::value)>}
\DoxyCodeLine{4458 FMT\_NODISCARD FMT\_INLINE \textcolor{keyword}{auto} formatted\_size(\textcolor{keyword}{const} Locale\& loc,}
\DoxyCodeLine{4459                                              \mbox{\hyperlink{classbasic__format__string}{format\_string<T...>}} fmt,}
\DoxyCodeLine{4460                                              T\&\&... args) -\/> \textcolor{keywordtype}{size\_t} \{}
\DoxyCodeLine{4461   \textcolor{keyword}{auto} buf = \mbox{\hyperlink{classdetail_1_1counting__buffer}{detail::counting\_buffer<>}}();}
\DoxyCodeLine{4462   detail::vformat\_to<char>(buf, fmt, fmt::make\_format\_args(args...),}
\DoxyCodeLine{4463                            \mbox{\hyperlink{classdetail_1_1locale__ref}{detail::locale\_ref}}(loc));}
\DoxyCodeLine{4464   \textcolor{keywordflow}{return} buf.count();}
\DoxyCodeLine{4465 \}}
\DoxyCodeLine{4466 }
\DoxyCodeLine{4467 FMT\_END\_EXPORT}
\DoxyCodeLine{4468 }
\DoxyCodeLine{4469 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Char>}
\DoxyCodeLine{4470 \textcolor{keyword}{template} <\textcolor{keyword}{typename} FormatContext>}
\DoxyCodeLine{4471 FMT\_CONSTEXPR FMT\_INLINE \textcolor{keyword}{auto}}
\DoxyCodeLine{4472 \mbox{\hyperlink{structformatter}{formatter}}<T, Char,}
\DoxyCodeLine{4473           enable\_if\_t<detail::type\_constant<T, Char>::value !=}
\DoxyCodeLine{4474                       detail::type::custom\_type>>::format(\textcolor{keyword}{const} T\& val,}
\DoxyCodeLine{4475                                                           FormatContext\& ctx)}
\DoxyCodeLine{4476     \textcolor{keyword}{const} -\/> \textcolor{keyword}{decltype}(ctx.out()) \{}
\DoxyCodeLine{4477   \textcolor{keywordflow}{if} (specs\_.width\_ref.kind != detail::arg\_id\_kind::none ||}
\DoxyCodeLine{4478       specs\_.precision\_ref.kind != detail::arg\_id\_kind::none) \{}
\DoxyCodeLine{4479     \textcolor{keyword}{auto} specs = specs\_;}
\DoxyCodeLine{4480     detail::handle\_dynamic\_spec<detail::width\_checker>(specs.width,}
\DoxyCodeLine{4481                                                        specs.width\_ref, ctx);}
\DoxyCodeLine{4482     detail::handle\_dynamic\_spec<detail::precision\_checker>(}
\DoxyCodeLine{4483         specs.precision, specs.precision\_ref, ctx);}
\DoxyCodeLine{4484     \textcolor{keywordflow}{return} detail::write<Char>(ctx.out(), val, specs, ctx.locale());}
\DoxyCodeLine{4485   \}}
\DoxyCodeLine{4486   \textcolor{keywordflow}{return} detail::write<Char>(ctx.out(), val, specs\_, ctx.locale());}
\DoxyCodeLine{4487 \}}
\DoxyCodeLine{4488 }
\DoxyCodeLine{4489 FMT\_END\_NAMESPACE}
\DoxyCodeLine{4490 }
\DoxyCodeLine{4491 \textcolor{preprocessor}{\#ifdef FMT\_HEADER\_ONLY}}
\DoxyCodeLine{4492 \textcolor{preprocessor}{\#  define FMT\_FUNC inline}}
\DoxyCodeLine{4493 \textcolor{preprocessor}{\#  include "{}format-\/inl.h"{}}}
\DoxyCodeLine{4494 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{4495 \textcolor{preprocessor}{\#  define FMT\_FUNC}}
\DoxyCodeLine{4496 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{4497 }
\DoxyCodeLine{4498 \textcolor{preprocessor}{\#endif  }\textcolor{comment}{// FMT\_FORMAT\_H\_}}

\end{DoxyCode}
