template <typename ThreadPool>
class BookEventGetter3 : public detail::FamilyBookEventGetter,
                         public inner::BookEventGetterI {
    using CallbackMap =
        std::unordered_map<common::TradingPair, const OnWssFBTradingPair*,
                           common::TradingPairHash, common::TradingPairEqual>;
    using CloseSessionCallbackMap =
        std::unordered_map<common::TradingPair, const OnCloseSession*,
                           common::TradingPairHash, common::TradingPairEqual>;

    ::V2::ConnectionPool<WSSesionType3, const std::string_view&>* session_pool_;
    common::TradingPairHashMap& pairs_;
    CallbackMap callback_map_;
    CloseSessionCallbackMap callback_on_close_session_map_;
    std::atomic<WSSesionType3*> active_session_{nullptr};

  protected:
    ThreadPool& thread_pool_;
    boost::asio::strand<typename ThreadPool::executor_type> strand_;

  public:
    /**
     * @brief Constructor for BookEventGetter3.
     *
     * @param executor The executor for asynchronous operations.
     * @param session_pool Pointer to the WebSocket session pool.
     * @param type The type of exchange (mainnet or testnet).
     * @param pairs Reference to the trading pair hash map.
     */
    BookEventGetter3(
        ThreadPool& thread_pool,
        ::V2::ConnectionPool<WSSesionType3, const std::string_view&>*
            session_pool,
       common::TradingPairHashMap& pairs)
        : 
          strand_(boost::asio::make_strand(thread_pool)),
          session_pool_(session_pool),
          pairs_(pairs),
          thread_pool_(thread_pool){}
    /**
     * @brief Default destructor.
     */
    ~BookEventGetter3() override = default;
    /**
     * @brief Asynchronously handles book events.
     *
     * @param bus_event_request_diff_order_book Pointer to the event request for
     * the order book.
     */
    boost::asio::awaitable<void> CoExec(
        boost::intrusive_ptr<Exchange::BusEventRequestDiffOrderBook>
            bus_event_request_diff_order_book) override {

        if (!bus_event_request_diff_order_book || !session_pool_) {
            loge("Invalid bus_event_request_diff_order_book or session_pool");
            co_return;
        }

        //co_await HandleBookEvent(bus_event_request_diff_order_book);
        boost::asio::co_spawn(strand_, HandleBookEvent(bus_event_request_diff_order_book),
                              boost::asio::detached);
    }
    /**
     * @brief Registers a callback for a specific trading pair's WebSocket
     * response.
     *
     * @param trading_pair The trading pair to register the callback for.
     * @param callback Pointer to the callback function.
     */
    void RegisterCallback(common::TradingPair trading_pair,
                          const OnWssFBTradingPair* callback) {
        callback_map_[trading_pair] = callback;
    }
    /**
     * @brief Registers a callback for a specific trading pair when a session is
     * closed.
     *
     * @param trading_pair The trading pair to register the callback for.
     * @param callback Pointer to the close session callback function.
     */
    void RegisterCallbackOnCloseSession(common::TradingPair trading_pair,
                                        const OnCloseSession* callback) {
        callback_on_close_session_map_[trading_pair] = callback;
    }

    /**
     * @brief Asynchronously stops the active WebSocket session gracefully.
     */
    void AsyncStop() {
        if (auto session = active_session_.load()) {
            session->AsyncCloseSessionGracefully();
        } else {
            logw("No active session to stop");
        }
    }

  private:
    /**
     * @brief Handles book events by processing the provided event request.
     *
     * @param bus_event_request_diff_order_book Pointer to the event request for
     * the order book.
     */
    boost::asio::awaitable<void> HandleBookEvent(
        boost::intrusive_ptr<Exchange::BusEventRequestDiffOrderBook>
            bus_event_request_diff_order_book) {
        auto* wrapped_event = bus_event_request_diff_order_book->WrappedEvent();
        if (!wrapped_event) {
            loge("Wrapped event is null");
            co_return;
        }

        auto& trading_pair = wrapped_event->trading_pair;
        logi("[bookeventgetter] start send request to exchange for {}", trading_pair.ToString());
        detail::FamilyBookEventGetter::ArgsBody args(
            bus_event_request_diff_order_book->WrappedEvent(), pairs_);
        auto req = args.Body();

        if (!active_session_
                 .load()) {  // Check if active session is not already acquired
            AcquireActiveSession();
            if (!RegisterCallbacksForTradingPair(trading_pair)) {
                co_return;
            }
        } else {
            logd("Using existing active session");
            if (!RegisterCallbacksForTradingPair(trading_pair)) {
                co_return;
            }
        }
        logi("request to exchange: {}", req);

        co_await SendAsyncRequest(std::move(req));
        logd("Finished sending event getter for bybit request");
    }

    /**
     * @brief Acquires an active session from the session pool.
     *
     * @return True if a session was successfully acquired, otherwise false.
     */
    void AcquireActiveSession() {
        WSSesionType3* expected = nullptr;
        auto session            = session_pool_->AcquireConnection();
        if (active_session_.compare_exchange_strong(expected, session)) {
            logd("Active session acquired");
        }
    }
    /**
     * @brief Registers callbacks for a specific trading pair.
     *
     * @param trading_pair The trading pair to register callbacks for.
     * @return True if registration was successful, otherwise false.
     */
    bool RegisterCallbacksForTradingPair(
        const common::TradingPair& trading_pair) {
        if (auto callback = FindCallback(callback_map_, trading_pair)) {
            RegisterCallbackOnSession(callback, trading_pair);
        } else {
            loge("No callback on response registered for trading pair: {}",
                 trading_pair.ToString());
            return false;
        }

        if (auto callback =
                FindCallback(callback_on_close_session_map_, trading_pair)) {
            RegisterCallbackOnSessionClose(callback);
        } else {
            logw("No callback on close session registered for trading pair: {}",
                 trading_pair.ToString());
        }

        RegisterDefaultCallbackOnSessionClose();
        return true;
    }
    /**
     * @brief Finds a callback in the specified map for a given trading pair.
     *
     * @tparam MapType The type of the callback map.
     * @param map The map to search for the callback.
     * @param trading_pair The trading pair to search for.
     * @return Pointer to the callback if found, otherwise nullptr.
     */
    template <typename MapType>
    typename MapType::mapped_type FindCallback(
        const MapType& map, const common::TradingPair& trading_pair) const {
        auto it = map.find(trading_pair);
        return it != map.end() ? it->second : nullptr;
    }
    /**
     * @brief Registers a response callback on the active session.
     *
     * @param callback The callback to register.
     */
    void RegisterCallbackOnSession(const OnWssFBTradingPair* callback,
                                   common::TradingPair trading_pair) {
        if (auto session = active_session_.load()) {
            session->RegisterCallbackOnResponse(*callback, trading_pair);
        }
    }
    /**
     * @brief Registers a close session callback on the active session.
     *
     * @param callback The callback to register.
     */
    void RegisterCallbackOnSessionClose(const OnCloseSession* callback) {
        if (auto session = active_session_.load()) {
            session->RegisterCallbackOnCloseSession(*callback);
        }
    }
    /**
     * @brief Registers the default callback to execute when a session is
     * closed.
     */
    void RegisterDefaultCallbackOnSessionClose() {
        if (auto session = active_session_.load()) {
            session->RegisterCallbackOnCloseSession(
                [this]() { DefaultCBOnCloseSession(); });
        }
    }

    /**
     * @brief Sends an asynchronous request using the active session.
     *
     * @tparam RequestType The type of the request.
     * @param req The request to send.
     * @return True if the request was sent successfully, otherwise false.
     */
    boost::asio::awaitable<void> SendAsyncRequest(auto&& req) {
        if (auto session = active_session_.load()) {
            session->AsyncWrite(std::move(req));
        }
        co_return;
    }

    /**
     * @brief Default callback executed when a session is closed.
     */
    void DefaultCBOnCloseSession() {
        active_session_.store(nullptr, std::memory_order_release);
    }
};