diff --git a/aot/Binance.h b/aot/Binance.h
index fff628e..35fd340 100644
--- a/aot/Binance.h
+++ b/aot/Binance.h
@@ -6,14 +6,6 @@
 #include <unordered_map>
 #include <utility>
 
-#include "boost/asio.hpp"
-#include "boost/beast/http.hpp"
-#include "boost/beast/http/message.hpp"
-#include "boost/beast/version.hpp"
-
-#include "nlohmann/json.hpp"
-#include "simdjson.h"
-
 #include "aot/Exchange.h"
 #include "aot/Https.h"
 #include "aot/Logger.h"
@@ -26,7 +18,12 @@
 #include "aot/common/types.h"
 #include "aot/market_data/market_update.h"
 #include "aot/prometheus/event.h"
-
+#include "boost/asio.hpp"
+#include "boost/beast/http.hpp"
+#include "boost/beast/http/message.hpp"
+#include "boost/beast/version.hpp"
+#include "nlohmann/json.hpp"
+#include "simdjson.h"
 
 // Spot API URL                               Spot Test Network URL
 // https://api.binance.com/api https://testnet.binance.vision/api
@@ -592,9 +589,20 @@ class FamilyBookEventGetter {
          * @param id Variant containing the ID as a string, int, or unsigned
          * int.
          */
-        void SetId(const std::variant<std::string, long int, long unsigned int>& id) {
-            std::visit([this](const auto& value) { (*this)["id"] = value; },
-                       id);
+        void SetId(
+            const std::variant<std::string, long int, long unsigned int>& id) {
+            std::visit(
+                [this](const auto& value) {
+                    if constexpr (std::is_same_v<std::decay_t<decltype(value)>,
+                                                 std::string>) {
+                        if (value.empty()) {
+                            logw("ID request is empty");
+                            return;
+                        }
+                    }
+                    (*this)["id"] = value;
+                },
+                id);
         }
     };
     virtual ~FamilyBookEventGetter() = default;
@@ -1328,8 +1336,9 @@ class BookEventGetter3 : public detail::FamilyBookEventGetter,
 template <typename Executor>
 class BookEventGetterComponent : public bus::Component,
                                  public BookEventGetter3<Executor> {
-static constexpr std::string_view name_component_ =
+    static constexpr std::string_view name_component_ =
         "binance::BookEventGetterComponent";
+
   public:
     common::MemoryPool<Exchange::BookDiffSnapshot2> book_diff_mem_pool_;
     common::MemoryPool<Exchange::BusEventBookDiffSnapshot>
@@ -1923,7 +1932,7 @@ class BookSnapshot : public inner::BookSnapshotI,
 
 template <typename Executor>
 class BookSnapshot2 : public inner::BookSnapshotI {
-    SignerI* signer_;
+    SignerI* signer_ = nullptr;
     ::V2::ConnectionPool<HTTPSesionType3>* session_pool_;
     common::TradingPairHashMap& pairs_;
     // Add a callback map to store parsing callbacks for each trading pair
@@ -1933,18 +1942,15 @@ class BookSnapshot2 : public inner::BookSnapshotI {
 
   protected:
     Executor executor_;
-    boost::asio::cancellation_signal& signal_;
 
   public:
     explicit BookSnapshot2(Executor&& executor, SignerI* signer,
                            ::V2::ConnectionPool<HTTPSesionType3>* session_pool,
-                           TypeExchange type, common::TradingPairHashMap& pairs,
-                           boost::asio::cancellation_signal& signal)
+                           TypeExchange type, common::TradingPairHashMap& pairs)
         : executor_(std::move(executor)),
           signer_(signer),
           session_pool_(session_pool),
-          pairs_(pairs),
-          signal_(signal) {
+          pairs_(pairs) {
         switch (type) {
             case TypeExchange::MAINNET:
                 current_exchange_ = &binance_main_net_;
@@ -2011,9 +2017,8 @@ class BookSnapshot2 : public inner::BookSnapshotI {
                 auto session = session_pool_->AcquireConnection();
                 logd("start send new snapshot request");
 
-                auto slot = signal_.slot();
-                if (auto status = co_await session->AsyncRequest(
-                        std::move(req), callback, slot);
+                if (auto status = co_await session->AsyncRequest(std::move(req),
+                                                                 callback);
                     status == false)
                     loge("AsyncRequest wasn't sent in io_context");
 
@@ -2054,7 +2059,7 @@ class BookSnapshotComponent : public bus::Component,
         common::TradingPairReverseHashMap& pairs_reverse,
         ::V2::ConnectionPool<HTTPSesionType3>* session_pool)
         : BookSnapshot2<Executor>(std::move(executor), signer, session_pool,
-                                  type, pairs, signal),
+                                  type, pairs),
           snapshot_mem_pool_(number_responses),
           bus_event_response_snapshot_mem_pool_(number_responses) {}
     ~BookSnapshotComponent() override = default;
@@ -2144,7 +2149,7 @@ class GeneratorBidAskService {
     auto Run() noexcept -> void;
 };
 
-template <typename Executor>
+template <typename ThreadPool>
 class BidAskGeneratorComponent : public bus::Component {
   public:
     using SnapshotCallback = std::function<void(const Exchange::BookSnapshot&)>;
@@ -2161,7 +2166,8 @@ class BidAskGeneratorComponent : public bus::Component {
                        common::TradingPairHash, common::TradingPairEqual>
         request_bbo_;
 
-    Executor executor_;
+    ThreadPool& thread_pool_;
+    boost::asio::strand<typename ThreadPool::executor_type> strand_;
     aot::CoBus& bus_;
 
   public:
@@ -2186,10 +2192,11 @@ class BidAskGeneratorComponent : public bus::Component {
      * BidAskGeneratorComponent per tick. need this variable for mem pool
      */
     explicit BidAskGeneratorComponent(
-        Executor&& executor, aot::CoBus& bus,
+        ThreadPool& thread_pool, aot::CoBus& bus,
         const unsigned int number_snapshots, const unsigned int number_diff,
         const unsigned int max_number_event_per_tick)
-        : executor_(std::move(executor)),
+        : thread_pool_(thread_pool),
+          strand_(boost::asio::make_strand(thread_pool)),
           bus_(bus),
           request_bus_event_snapshot_mem_pool_(number_snapshots),
           request_snapshot_mem_pool_(number_snapshots),
@@ -2200,16 +2207,22 @@ class BidAskGeneratorComponent : public bus::Component {
 
     void AsyncHandleEvent(
         Exchange::BusEventResponseNewSnapshot* event) override {
-        boost::asio::co_spawn(executor_, HandleNewSnapshotEvent(event),
+        // need extend lifetime object
+        auto event_ptr =
+            boost::intrusive_ptr<Exchange::BusEventResponseNewSnapshot>(event);
+        boost::asio::co_spawn(strand_, HandleNewSnapshotEvent(event_ptr),
                               boost::asio::detached);
     };
     void AsyncHandleEvent(Exchange::BusEventBookDiffSnapshot* event) override {
-        boost::asio::co_spawn(executor_, HandleBookDiffSnapshotEvent(event),
+        // need extend lifetime object
+        auto event_ptr =
+            boost::intrusive_ptr<Exchange::BusEventBookDiffSnapshot>(event);
+        boost::asio::co_spawn(strand_, HandleBookDiffSnapshotEvent(event_ptr),
                               boost::asio::detached);
     };
     void AsyncHandleEvent(
         boost::intrusive_ptr<BusEventRequestBBOPrice> event) override {
-        boost::asio::co_spawn(executor_, HandleTrackingNewTradingPair(event),
+        boost::asio::co_spawn(strand_, HandleTrackingNewTradingPair(event),
                               boost::asio::detached);
     };
     void AsyncStop() override {
@@ -2245,7 +2258,7 @@ class BidAskGeneratorComponent : public bus::Component {
         co_return;
     }
     boost::asio::awaitable<void> HandleNewSnapshotEvent(
-        Exchange::BusEventResponseNewSnapshot* event) {
+        boost::intrusive_ptr<Exchange::BusEventResponseNewSnapshot> event) {
         // Extract the exchange ID from the event.
         const auto& exchange_id = event->WrappedEvent()->exchange_id;
 
@@ -2273,7 +2286,7 @@ class BidAskGeneratorComponent : public bus::Component {
         co_return;
     }
     boost::asio::awaitable<void> HandleBookDiffSnapshotEvent(
-        Exchange::BusEventBookDiffSnapshot* event) {
+        boost::intrusive_ptr<Exchange::BusEventBookDiffSnapshot> event) {
         const auto& diff = *event->WrappedEvent();
         logi("[DIFF ACCEPTED] {}, Diff ID Range: [{}-{}]",
              diff.trading_pair.ToString(), diff.first_id, diff.last_id);
@@ -2334,7 +2347,8 @@ class BidAskGeneratorComponent : public bus::Component {
                 "LastUpdateId: {}",
                 trading_pair.ToString(), state.snapshot.lastUpdateId);
             state.need_make_snapshot = true;
-            co_await RequestNewSnapshot(trading_pair);
+            boost::asio::co_spawn(strand_, RequestNewSnapshot(trading_pair),
+                                  boost::asio::detached);
             co_return;
         }
 
@@ -2418,7 +2432,7 @@ class BidAskGeneratorComponent : public bus::Component {
         // common::kFrequencyMSInvalid to info
         auto* ptr  = request_diff_mem_pool_.Allocate(
             &request_diff_mem_pool_, info.exchange_id, info.trading_pair,
-            common::kFrequencyMSInvalid, true);
+            common::kFrequencyMSInvalid, true, info.id);
         auto intr_ptr_request =
             boost::intrusive_ptr<Exchange::RequestDiffOrderBook>(ptr);
 
@@ -2599,12 +2613,15 @@ class ApiResponseParser {
             if (!id_field.error()) {
                 if (id_field.type() == simdjson::ondemand::json_type::string) {
                     std::string_view id_value;
-                    if (id_field.get_string().get(id_value) == simdjson::SUCCESS) {
+                    if (id_field.get_string().get(id_value) ==
+                        simdjson::SUCCESS) {
                         data.id = std::string(id_value);  // Store as string
                     }
-                } else if (id_field.type() == simdjson::ondemand::json_type::number) {
+                } else if (id_field.type() ==
+                           simdjson::ondemand::json_type::number) {
                     simdjson::ondemand::number number = id_field.get_number();
-                    simdjson::ondemand::number_type t = number.get_number_type();
+                    simdjson::ondemand::number_type t =
+                        number.get_number_type();
                     switch (t) {
                         case simdjson::ondemand::number_type::signed_integer:
                             if (number.is_int64()) {
@@ -2620,12 +2637,15 @@ class ApiResponseParser {
                                 loge("Unexpected unsigned integer size.");
                             }
                             break;
-                        case simdjson::ondemand::number_type::floating_point_number:
-                            // If it's a floating point, you can get the value as a double
+                        case simdjson::ondemand::number_type::
+                            floating_point_number:
+                            // If it's a floating point, you can get the value
+                            // as a double
                             loge("Unexpected double");
                             break;
                         case simdjson::ondemand::number_type::big_integer:
-                            // Handle big integers (e.g., large numbers out of int64_t range)
+                            // Handle big integers (e.g., large numbers out of
+                            // int64_t range)
                             loge("Big integer value detected.");
                             break;
                         default:
@@ -2634,8 +2654,14 @@ class ApiResponseParser {
                     }
                 }
             }
-            return data;  // Return populated or empty data
         }
+        return data;  // Return populated or empty data
     };
 };
+
+ParserManager InitParserManager(
+    common::TradingPairHashMap& pairs,
+    common::TradingPairReverseHashMap& pair_reverse,
+    ApiResponseParser& api_response_parser,
+    detail::FamilyBookEventGetter::ParserResponse& parser_ob_diff);
 };  // namespace binance
\ No newline at end of file
diff --git a/aot/Bybit.h b/aot/Bybit.h
index 4d7ddc0..a4d4690 100644
--- a/aot/Bybit.h
+++ b/aot/Bybit.h
@@ -294,8 +294,7 @@ class FamilyBookEventGetter {
 
       public:
         using ResponseVariant =
-            std::variant<Exchange::BookSnapshot,
-                         Exchange::BookDiffSnapshot>;
+            std::variant<Exchange::BookSnapshot, Exchange::BookDiffSnapshot>;
         explicit ParserResponse(
             common::TradingPairHashMap& pairs,
             common::TradingPairReverseHashMap& pairs_reverse)
@@ -469,7 +468,8 @@ class FamilyBookEventGetter {
                 return;
             }
             nlohmann::json params_array = nlohmann::json::array();
-            params_array.push_back(fmt::format("{}.{}.{}", "orderbook", request->frequency,
+            params_array.push_back(
+                fmt::format("{}.{}.{}", "orderbook", request->frequency,
                             pairs_[request->trading_pair].https_json_request));
             // Build the "args" string using trading pair and frequency.
             (*this)["args"] = params_array;
@@ -480,9 +480,20 @@ class FamilyBookEventGetter {
          * @param id Variant containing the ID as a string, int, or unsigned
          * int.
          */
-        void SetId(const std::variant<std::string, long int, long unsigned int>& id) {
-            std::visit([this](const auto& value) { (*this)["req_id"] = value; },
-                       id);
+        void SetId(
+            const std::variant<std::string, long int, long unsigned int>& id) {
+            std::visit(
+                [this](const auto& value) {
+                    if constexpr (std::is_same_v<std::decay_t<decltype(value)>,
+                                                 std::string>) {
+                        if (value.empty()) {
+                            logw("ID request is empty");
+                            return;
+                        }
+                    }
+                    (*this)["req_id"] = value;
+                },
+                id);
         }
     };
 
@@ -1341,9 +1352,8 @@ class BookSnapshot2 : public inner::BookSnapshotI {
                 auto session = session_pool_->AcquireConnection();
                 logd("start send new snapshot request");
 
-                auto slot = signal_.slot();
-                if (auto status = co_await session->AsyncRequest(
-                        std::move(req), callback, slot);
+                if (auto status = co_await session->AsyncRequest(std::move(req),
+                                                                 callback);
                     status == false)
                     loge("AsyncRequest wasn't sent in io_context");
 
@@ -1426,9 +1436,7 @@ class BidAskGeneratorComponent : public bus::Component {
         request_bbo_;
 
     ThreadPool& thread_pool_;
-    //boost::asio::strand<ThreadPool> strand_; //strand for sequence handle messages
     boost::asio::strand<typename ThreadPool::executor_type> strand_;
-    boost::asio::thread_pool pool_;
     aot::CoBus& bus_;
 
   public:
@@ -1457,8 +1465,8 @@ class BidAskGeneratorComponent : public bus::Component {
         const unsigned int number_snapshots, const unsigned int number_diff,
         const unsigned int max_number_event_per_tick)
         : thread_pool_(thread_pool),
-        strand_(boost::asio::make_strand(thread_pool)),
-        bus_(bus),
+          strand_(boost::asio::make_strand(thread_pool)),
+          bus_(bus),
           request_bus_event_snapshot_mem_pool_(number_snapshots),
           request_snapshot_mem_pool_(number_snapshots),
           request_bus_event_diff_mem_pool_(number_diff),
@@ -1468,18 +1476,16 @@ class BidAskGeneratorComponent : public bus::Component {
 
     void AsyncHandleEvent(
         Exchange::BusEventResponseNewSnapshot* event) override {
-        auto& snap = *event->WrappedEvent();
-        logi("ACCEPT SNAPSHOT IN BID ASK SERVICE WITH LAST_ID:{}",snap.lastUpdateId);
-        //need extend lifetime object
-        auto event_ptr = boost::intrusive_ptr<Exchange::BusEventResponseNewSnapshot>(event);
+        // need extend lifetime object
+        auto event_ptr =
+            boost::intrusive_ptr<Exchange::BusEventResponseNewSnapshot>(event);
         boost::asio::co_spawn(strand_, HandleNewSnapshotEvent(event_ptr),
                               boost::asio::detached);
     };
     void AsyncHandleEvent(Exchange::BusEventBookDiffSnapshot* event) override {
-        auto& diff = *event->WrappedEvent();
-        logi("ACCEPT DIFF EVENT IN BID ASK SERVICE WITH LAST_ID:{}",diff.last_id);
-        //need extend lifetime object
-        auto event_ptr = boost::intrusive_ptr<Exchange::BusEventBookDiffSnapshot>(event);
+        // need extend lifetime object
+        auto event_ptr =
+            boost::intrusive_ptr<Exchange::BusEventBookDiffSnapshot>(event);
         boost::asio::co_spawn(strand_, HandleBookDiffSnapshotEvent(event_ptr),
                               boost::asio::detached);
     };
@@ -1519,7 +1525,7 @@ class BidAskGeneratorComponent : public bus::Component {
 
         // need send a signal to launch diff
         constexpr bool need_subcription = true;
-        co_await RequestToDiff<need_subcription>(trading_pair);
+        co_await RequestSubscribeToDiff<need_subcription>(trading_pair);
         co_return;
     }
     boost::asio::awaitable<void> HandleNewSnapshotEvent(
@@ -1534,17 +1540,18 @@ class BidAskGeneratorComponent : public bus::Component {
         }
 
         // Extract the trading pair from the event.
-        auto trading_pair = event->WrappedEvent()->trading_pair;
+        auto trading_pair  = event->WrappedEvent()->trading_pair;
 
         // Retrieve the state associated with the trading pair.
-        auto& state       = state_map_[trading_pair];
+        auto& state        = state_map_[trading_pair];
 
         // Log that a new snapshot is being processed for the trading pair.
 
         // Update the state with the new snapshot.
         // The snapshot is moved into the state to avoid unnecessary copies.
-        auto wrapped_event                    = event->WrappedEvent();
-        logd("[PROCESSING NEW SNAPSHOT] {} last_id:{}", trading_pair.ToString(),wrapped_event->lastUpdateId);
+        auto wrapped_event = event->WrappedEvent();
+        logd("[PROCESSING NEW SNAPSHOT] {} last_id:{}", trading_pair.ToString(),
+             wrapped_event->lastUpdateId);
 
         auto previous_last_id_diff_book_event = state.snapshot.lastUpdateId;
         state.need_process_current_snapshot =
@@ -1591,9 +1598,11 @@ class BidAskGeneratorComponent : public bus::Component {
                 trading_pair.ToString(), state.last_id_diff_book_event + 1,
                 diff.last_id);
             // Unsubscribe channel and than
-            boost::asio::co_spawn(pool_, RequestToDiff<false>(trading_pair), boost::asio::detached);
+            boost::asio::co_spawn(strand_, RequestSubscribeToDiff<false>(trading_pair),
+                                  boost::asio::detached);
             // subscribe to it
-            boost::asio::co_spawn(pool_, RequestToDiff<true>(trading_pair), boost::asio::detached);
+            boost::asio::co_spawn(strand_, RequestSubscribeToDiff<true>(trading_pair),
+                                  boost::asio::detached);
             co_return;
         }
 
@@ -1652,7 +1661,7 @@ class BidAskGeneratorComponent : public bus::Component {
     }
 
     template <bool subscribe>
-    boost::asio::awaitable<void> RequestToDiff(
+    boost::asio::awaitable<void> RequestSubscribeToDiff(
         common::TradingPair trading_pair) {
         if (!request_bbo_.count(trading_pair)) {
             loge(
@@ -1781,7 +1790,8 @@ class ParserManager {
             doc["type"].is_string() && doc["type"] == "snapshot") {
             return ResponseType::kSnapshot;
         }
-        // Check if this is a success response (contains "result": "success" or "false")
+        // Check if this is a success response (contains "result": "success" or
+        // "false")
         if (doc["success"].error() == simdjson::SUCCESS) {
             return ResponseType::kNonQueryResponse;
         }
@@ -1823,7 +1833,8 @@ class ApiResponseParser {
         if (!success_field.error() &&
             success_field.type() == simdjson::ondemand::json_type::boolean) {
             bool success_value;
-            if (success_field.get_bool().get(success_value) == simdjson::SUCCESS) {
+            if (success_field.get_bool().get(success_value) ==
+                simdjson::SUCCESS) {
                 data.status = success_value ? ApiResponseStatus::kSuccess
                                             : ApiResponseStatus::kError;
             }
@@ -1840,38 +1851,45 @@ class ApiResponseParser {
             } else if (id_field.type() ==
                        simdjson::ondemand::json_type::number) {
                 simdjson::ondemand::number number = id_field.get_number();
-                    simdjson::ondemand::number_type t = number.get_number_type();
-                    switch (t) {
-                        case simdjson::ondemand::number_type::signed_integer:
-                            if (number.is_int64()) {
-                                data.id = number.get_int64();
-                            } else {
-                                loge("Unexpected signed integer size.");
-                            }
-                            break;
-                        case simdjson::ondemand::number_type::unsigned_integer:
-                            if (number.is_uint64()) {
-                                data.id = number.get_uint64();
-                            } else {
-                                loge("Unexpected unsigned integer size.");
-                            }
-                            break;
-                        case simdjson::ondemand::number_type::floating_point_number:
-                            // If it's a floating point, you can get the value as a double
-                            loge("Unexpected double");
-                            break;
-                        case simdjson::ondemand::number_type::big_integer:
-                            // Handle big integers (e.g., large numbers out of int64_t range)
-                            loge("Big integer value detected.");
-                            break;
-                        default:
-                            loge("Unknown number type.");
-                            break;
-                    }
+                simdjson::ondemand::number_type t = number.get_number_type();
+                switch (t) {
+                    case simdjson::ondemand::number_type::signed_integer:
+                        if (number.is_int64()) {
+                            data.id = number.get_int64();
+                        } else {
+                            loge("Unexpected signed integer size.");
+                        }
+                        break;
+                    case simdjson::ondemand::number_type::unsigned_integer:
+                        if (number.is_uint64()) {
+                            data.id = number.get_uint64();
+                        } else {
+                            loge("Unexpected unsigned integer size.");
+                        }
+                        break;
+                    case simdjson::ondemand::number_type::floating_point_number:
+                        // If it's a floating point, you can get the value as a
+                        // double
+                        loge("Unexpected double");
+                        break;
+                    case simdjson::ondemand::number_type::big_integer:
+                        // Handle big integers (e.g., large numbers out of
+                        // int64_t range)
+                        loge("Big integer value detected.");
+                        break;
+                    default:
+                        loge("Unknown number type.");
+                        break;
+                }
             }
         }
         return data;  // Return populated or empty data
     }
 };
 
+ParserManager InitParserManager(
+    common::TradingPairHashMap& pairs,
+    common::TradingPairReverseHashMap& pair_reverse,
+    ApiResponseParser& api_response_parser,
+    detail::FamilyBookEventGetter::ParserResponse& parser_ob_diff);
 };  // namespace bybit
\ No newline at end of file
diff --git a/aot/Https.h b/aot/Https.h
index 6e2cb2a..0d5485c 100644
--- a/aot/Https.h
+++ b/aot/Https.h
@@ -449,14 +449,14 @@ public:
     }
 
     template <typename CompletionHandler>
-    net::awaitable<bool> AsyncRequest(http::request<http::string_body>&& req, const CompletionHandler* handler, net::cancellation_slot& slot) {
+    net::awaitable<bool> AsyncRequest(http::request<http::string_body>&& req, const CompletionHandler* handler) {
         if (!IsConnected() || IsUsed()) co_return false;
         req_ = std::move(req);
         cb_ = handler;
         is_used_ = true;
-        slot.assign([this](boost::asio::cancellation_type_t) {
-            AsyncCloseSessionGracefully();
-        });
+        // slot.assign([this](boost::asio::cancellation_type_t) {
+        //     AsyncCloseSessionGracefully();
+        // });
         auto [ec_write, bytes_written] = co_await http::async_write(stream_, req_, net::as_tuple(net::use_awaitable));
         if (ec_write) {
             if (ec_write == net::error::operation_aborted) {
@@ -484,7 +484,6 @@ public:
             co_return false;
         }
         AsyncCloseSessionGracefully();
-        slot.clear();
         co_return true;
     }
 
diff --git a/src/Binance.cpp b/src/Binance.cpp
index 87b0d44..ab467a6 100644
--- a/src/Binance.cpp
+++ b/src/Binance.cpp
@@ -578,3 +578,23 @@ binance::detail::FamilyBookEventGetter::ParserResponse::Parse(
 
     return book_diff_snapshot;
 }
+
+binance::ParserManager binance::InitParserManager(
+    common::TradingPairHashMap& pairs,
+    common::TradingPairReverseHashMap& pair_reverse,
+    binance::ApiResponseParser& api_response_parser,
+    binance::detail::FamilyBookEventGetter::ParserResponse& parser_ob_diff){
+    binance::ParserManager parser_manager;
+
+    parser_manager.RegisterHandler(ResponseType::kNonQueryResponse,
+        [&api_response_parser](simdjson::ondemand::document& doc) {
+            return api_response_parser.Parse(doc);
+        });
+
+    parser_manager.RegisterHandler(ResponseType::kDepthUpdate,
+        [&parser_ob_diff](simdjson::ondemand::document& doc) {
+            return parser_ob_diff.Parse(doc);
+        });
+
+    return parser_manager;
+};
diff --git a/src/Bybit.cpp b/src/Bybit.cpp
index 88a520e..3eca7b1 100644
--- a/src/Bybit.cpp
+++ b/src/Bybit.cpp
@@ -411,4 +411,29 @@ bybit::detail::FamilyBookEventGetter::ParserResponse::Parse(
         loge("JSON error: {}", error.what());
     }
     return out;
-}
\ No newline at end of file
+}
+
+bybit::ParserManager bybit::InitParserManager(
+    common::TradingPairHashMap& pairs,
+    common::TradingPairReverseHashMap& pair_reverse,
+    bybit::ApiResponseParser& api_response_parser,
+    bybit::detail::FamilyBookEventGetter::ParserResponse& parser_ob_diff) {
+    bybit::ParserManager parser_manager;
+
+    parser_manager.RegisterHandler(ResponseType::kNonQueryResponse,
+        [&api_response_parser](simdjson::ondemand::document& doc) {
+            return api_response_parser.Parse(doc);
+        });
+
+    parser_manager.RegisterHandler(ResponseType::kDepthUpdate,
+        [&parser_ob_diff](simdjson::ondemand::document& doc) {
+            return std::get<Exchange::BookDiffSnapshot>(parser_ob_diff.Parse(doc));  // Ensure it returns BookDiffSnapshot
+        });
+
+    parser_manager.RegisterHandler(ResponseType::kSnapshot,
+        [&parser_ob_diff](simdjson::ondemand::document& doc) {
+            return std::get<Exchange::BookSnapshot>(parser_ob_diff.Parse(doc));  // Ensure it returns BookSnapshot
+        });
+
+    return parser_manager;
+};
\ No newline at end of file
diff --git a/tests/local_tests/CMakeLists.txt b/tests/local_tests/CMakeLists.txt
index a4d63bc..3b883a6 100644
--- a/tests/local_tests/CMakeLists.txt
+++ b/tests/local_tests/CMakeLists.txt
@@ -19,6 +19,8 @@ gmock_main
 concurrentqueue
 magic_enum::magic_enum
 tomlplusplus::tomlplusplus
+nlohmann_json::nlohmann_json
+simdjson::simdjson
 )
 
 target_include_directories(${PROJECT_NAME}
diff --git a/tests/local_tests/main.cpp b/tests/local_tests/main.cpp
index 221d2ae..a5c9205 100644
--- a/tests/local_tests/main.cpp
+++ b/tests/local_tests/main.cpp
@@ -346,7 +346,7 @@ void OnDiffCallback(const Exchange::BookDiffSnapshot2& diff) {
 TEST_F(BookSnapshotComponentTest, TestLaunchBidAskGeneratorComponent) {
     fmtlog::setLogLevel(fmtlog::DBG);
     ASSERT_GE(argc, 2);
-    //LogPolling log_polling(thread_pool, std::chrono::milliseconds(100));
+    LogPolling log_polling(thread_pool, std::chrono::milliseconds(100));
     aot::CoBus bus(thread_pool);
 
     config::ApiSecretKey config(argv[1]);
@@ -368,6 +368,12 @@ TEST_F(BookSnapshotComponentTest, TestLaunchBidAskGeneratorComponent) {
 
     common::TradingPairReverseHashMap pair_reverse = common::InitTPsJR(pairs);
 
+    binance::ApiResponseParser api_response_parser;
+    binance::detail::FamilyBookEventGetter::ParserResponse parser_ob_diff(
+            pairs, pair_reverse);
+    binance::ParserManager parser_manager = InitParserManager(pairs, pair_reverse, api_response_parser, parser_ob_diff);
+
+
     boost::asio::executor_work_guard<boost::asio::io_context::executor_type>
         work_guard(io_context.get_executor());
     std::thread t([this] { io_context.run(); });
@@ -375,18 +381,14 @@ TEST_F(BookSnapshotComponentTest, TestLaunchBidAskGeneratorComponent) {
     //------------------Snapshot component------------------------------------
     binance::BookSnapshotComponent component(
         boost::asio::make_strand(thread_pool), number_responses, &signer,
-        TypeExchange::TESTNET, pairs, pair_reverse, session_pool,
-        cancel_signal);
-
-    Exchange::RequestSnapshot request;
-    request.exchange_id  = common::ExchangeId::kBinance;
-    request.trading_pair = {2, 1};
+        TypeExchange::TESTNET, pairs, pair_reverse, session_pool);
 
     OnHttpsResponce cb =
         [&component, &bus, this, &pair_reverse](
             boost::beast::http::response<boost::beast::http::string_body>&
                 buffer) {
             const auto& result = buffer.body();
+            //std::cout << result << std::endl;
 
             binance::detail::FamilyBookSnapshot::ParserResponse parser(
                 pairs[{2, 1}]);
@@ -409,51 +411,104 @@ TEST_F(BookSnapshotComponentTest, TestLaunchBidAskGeneratorComponent) {
 
             bus.AsyncSend(&component, intr_ptr_bus_snapsot);
         };
-    component.RegisterCallback(request.trading_pair, &cb);
+    component.RegisterCallback({2,1}, &cb);
     //-----------------------------------------------------------------
     //--------------------------Depth stream component----------------
-    boost::asio::cancellation_signal cancel_signal;
-    boost::asio::cancellation_signal restart_signal;
 
     binance::BookEventGetterComponent event_getter_component(
         thread_pool, number_responses,
-        TypeExchange::TESTNET, pairs, &session_pool_wss, cancel_signal,restart_signal);
-
-    Exchange::RequestDiffOrderBook request_diff_order_book;
-    request.exchange_id            = common::ExchangeId::kBinance;
-    request.trading_pair           = {2, 1};
-    request.id           = 777;
+        TypeExchange::TESTNET, pairs, &session_pool_wss);
 
+    // Exchange::RequestDiffOrderBook request_diff_order_book;
+    // request.exchange_id            = common::ExchangeId::kBinance;
+    // request.trading_pair           = {2, 1};
 
     uint64_t counter_successfull   = 0;
     uint64_t counter_unsuccessfull = 0;
+    uint64_t request_accepted_by_exchange = 0;
+    bool accept_subscribe_successfully = false;
+    bool accept_unsubscribe_successfully = false;
+
 
     OnWssResponse cb_wss = [&event_getter_component, &bus, &counter_successfull,
                             &counter_unsuccessfull, this,
-                            &pair_reverse](boost::beast::flat_buffer& fb) {
-        auto data     = fb.data();  // returns a const_buffer
-        auto response = std::string_view(static_cast<const char*>(data.data()),
-                                         data.size());
-        binance::detail::FamilyBookEventGetter::ParserResponse parser(
-            pairs, pair_reverse);
-        auto result  = parser.Parse(response);
-
-        auto request = event_getter_component.book_diff_mem_pool_.Allocate(
-            &event_getter_component.book_diff_mem_pool_, result.exchange_id,
-            result.trading_pair, std::move(result.bids), std::move(result.asks),
-            result.first_id, result.last_id);
-        auto intr_ptr_request =
-            boost::intrusive_ptr<Exchange::BookDiffSnapshot2>(request);
-
-        auto bus_event =
-            event_getter_component.bus_event_book_diff_snapshot_mem_pool_
-                .Allocate(&event_getter_component
-                               .bus_event_book_diff_snapshot_mem_pool_,
-                          intr_ptr_request);
-        auto intr_ptr_bus_request =
-            boost::intrusive_ptr<Exchange::BusEventBookDiffSnapshot>(bus_event);
-
-        bus.AsyncSend(&event_getter_component, intr_ptr_bus_request);
+                            &pair_reverse,
+                            &parser_manager,
+                            &request_accepted_by_exchange,
+                            &accept_subscribe_successfully](boost::beast::flat_buffer& fb) {
+        //auto data     = fb.data();  // returns a const_buffer
+        // auto response = std::string_view(static_cast<const char*>(data.data()),
+        //                                  data.size());
+        auto response = std::string_view(static_cast<const char*>(fb.data().data()), fb.size());
+        auto answer = parser_manager.Parse(response);
+
+        std::cout << response << std::endl;
+
+        // binance::detail::FamilyBookEventGetter::ParserResponse parser(
+        //     pairs, pair_reverse);
+        // auto result  = parser.Parse(response);
+        //--------------------------------------------
+        if (std::holds_alternative<Exchange::BookDiffSnapshot>(answer)) {
+            std::visit(
+                [&](auto&& element) {
+                    using T = std::decay_t<decltype(element)>;
+                    if constexpr (std::is_same_v<T,
+                                                        Exchange::BookDiffSnapshot>) {
+                        logi("Received a BookDiffSnapshot!");
+                        Exchange::BookDiffSnapshot& result = element;
+                        auto request = event_getter_component.book_diff_mem_pool_.Allocate(
+                                        &event_getter_component.book_diff_mem_pool_, result.exchange_id,
+                                        result.trading_pair, std::move(result.bids), std::move(result.asks),
+                                        result.first_id, result.last_id);
+                    auto intr_ptr_request =
+                        boost::intrusive_ptr<Exchange::BookDiffSnapshot2>(request);
+
+                    auto bus_event =
+                        event_getter_component.bus_event_book_diff_snapshot_mem_pool_
+                            .Allocate(&event_getter_component
+                                        .bus_event_book_diff_snapshot_mem_pool_,
+                                    intr_ptr_request);
+                    auto intr_ptr_bus_request =
+                        boost::intrusive_ptr<Exchange::BusEventBookDiffSnapshot>(bus_event);
+
+                    bus.AsyncSend(&event_getter_component, intr_ptr_bus_request);
+                        // Use diffSnapshot
+                    }
+                },
+                answer);
+                counter_successfull++;
+        }
+        if (std::holds_alternative<ApiResponseData>(answer)) {
+            const auto& result = std::get<ApiResponseData>(answer);
+            logi("{}", result);
+
+            request_accepted_by_exchange++;
+            if (auto id_value = std::get_if<long int>(&result.id)) {
+                if (*id_value == 777) {
+                    accept_subscribe_successfully = true;
+                }
+            } 
+            // if (request_accepted_by_exchange == 1 &&
+            // counter_successfull > 5) component.AsyncStop();
+        }
+    };
+        //--------------------------------------------
+                                                                    // auto request = event_getter_component.book_diff_mem_pool_.Allocate(
+                                                                    //     &event_getter_component.book_diff_mem_pool_, result.exchange_id,
+                                                                    //     result.trading_pair, std::move(result.bids), std::move(result.asks),
+                                                                    //     result.first_id, result.last_id);
+                                                                    // auto intr_ptr_request =
+                                                                    //     boost::intrusive_ptr<Exchange::BookDiffSnapshot2>(request);
+
+                                                                    // auto bus_event =
+                                                                    //     event_getter_component.bus_event_book_diff_snapshot_mem_pool_
+                                                                    //         .Allocate(&event_getter_component
+                                                                    //                     .bus_event_book_diff_snapshot_mem_pool_,
+                                                                    //                 intr_ptr_request);
+                                                                    // auto intr_ptr_bus_request =
+                                                                    //     boost::intrusive_ptr<Exchange::BusEventBookDiffSnapshot>(bus_event);
+
+                                                                    // bus.AsyncSend(&event_getter_component, intr_ptr_bus_request);
 
         // if ((result.exchange_id ==
         //         common::ExchangeId::kBinance) &&
@@ -465,17 +520,23 @@ TEST_F(BookSnapshotComponentTest, TestLaunchBidAskGeneratorComponent) {
         // if (counter_successfull == 5) {
         //     component.AsyncStop();
         // }
+    //};
+    event_getter_component.RegisterCallback({2,1}, &cb_wss);
+     OnCloseSession cb_on_close_session = [this,
+    &work_guard](){
+        session_pool->CloseAllSessions();
+        work_guard.reset();
     };
-    auto cancelation_slot = cancel_signal.slot();
-    event_getter_component.RegisterCallback(request.trading_pair, &cb_wss);
+
+    event_getter_component.RegisterCallbackOnCloseSession(
+        {2,1}, &cb_on_close_session);
     //------------------------------------------------------------------------------
     //--------------------------Order book component--------------------------------
     Trading::OrderBookComponent order_book_component(boost::asio::make_strand(thread_pool));
-    order_book_component.AddOrderBook(common::ExchangeId::kBinance, request.trading_pair);
+    order_book_component.AddOrderBook(common::ExchangeId::kBinance, {2,1});
     //------------------------------------------------------------------------------
 
-    binance::BidAskGeneratorComponent bid_ask_generator(
-        boost::asio::make_strand(thread_pool), bus, 100, 1000, 10000);
+    binance::BidAskGeneratorComponent bid_ask_generator(thread_pool, bus, 100, 1000, 10000);
     // Register the snapshot callback
     auto ProcessBookEntries = [&bid_ask_generator, &bus](const auto& entries,
                                                         common::ExchangeId exchange_id,
@@ -513,22 +574,21 @@ TEST_F(BookSnapshotComponentTest, TestLaunchBidAskGeneratorComponent) {
     bus.Subscribe(&bid_ask_generator, &event_getter_component);
     bus.Subscribe(&component, &bid_ask_generator);
     bus.Subscribe(&event_getter_component, &bid_ask_generator);
-    //bus.Subscribe(&bid_ask_generator, &order_book_component);
+    bus.Subscribe(&bid_ask_generator, &order_book_component);
 
     //------------------------------------------------------------------------------
     BusEventRequestBBOPrice request_bbo_btc;
     request_bbo_btc.exchange_id    = common::ExchangeId::kBinance;
     request_bbo_btc.trading_pair   = {2, 1};
     request_bbo_btc.snapshot_depth = 1000;
+    request_bbo_btc.id = 777;
     auto intr_bus_request =
         boost::intrusive_ptr<BusEventRequestBBOPrice>(&request_bbo_btc);
     bid_ask_generator.AsyncHandleEvent(intr_bus_request);
 
-    thread_pool.join();
-    session_pool->CloseAllSessions();
-    work_guard.reset();
     t.join();
-    int z = 0;
+    log_polling.Stop();
+    thread_pool.join();
 }
 
 int main(int _argc, char** _argv) {
diff --git a/tests/unit/binance.cc b/tests/unit/binance.cc
index 5d65969..0f4ed17 100644
--- a/tests/unit/binance.cc
+++ b/tests/unit/binance.cc
@@ -137,25 +137,25 @@ class BookEventGetterComponentTest : public ::testing::Test {
 };
 
 // Helper function to initialize the parser manager
-binance::ParserManager InitParserManager(
-    common::TradingPairHashMap& pairs,
-    common::TradingPairReverseHashMap& pair_reverse,
-    binance::ApiResponseParser& api_response_parser,
-    binance::detail::FamilyBookEventGetter::ParserResponse& parser_ob_diff) {
-    binance::ParserManager parser_manager;
-
-    parser_manager.RegisterHandler(ResponseType::kNonQueryResponse,
-        [&api_response_parser](simdjson::ondemand::document& doc) {
-            return api_response_parser.Parse(doc);
-        });
-
-    parser_manager.RegisterHandler(ResponseType::kDepthUpdate,
-        [&parser_ob_diff](simdjson::ondemand::document& doc) {
-            return parser_ob_diff.Parse(doc);
-        });
-
-    return parser_manager;
-}
+// binance::ParserManager InitParserManager(
+//     common::TradingPairHashMap& pairs,
+//     common::TradingPairReverseHashMap& pair_reverse,
+//     binance::ApiResponseParser& api_response_parser,
+//     binance::detail::FamilyBookEventGetter::ParserResponse& parser_ob_diff) {
+//     binance::ParserManager parser_manager;
+
+//     parser_manager.RegisterHandler(ResponseType::kNonQueryResponse,
+//         [&api_response_parser](simdjson::ondemand::document& doc) {
+//             return api_response_parser.Parse(doc);
+//         });
+
+//     parser_manager.RegisterHandler(ResponseType::kDepthUpdate,
+//         [&parser_ob_diff](simdjson::ondemand::document& doc) {
+//             return parser_ob_diff.Parse(doc);
+//         });
+
+//     return parser_manager;
+// }
 
 // // Test case for unsubscribe functionality
 TEST_F(BookEventGetterComponentTest, TestUnSubscribeChannelBinance) {
diff --git a/tests/unit/bybit.cc b/tests/unit/bybit.cc
index 42712e1..74b0eea 100644
--- a/tests/unit/bybit.cc
+++ b/tests/unit/bybit.cc
@@ -10,30 +10,7 @@
 #include "boost/asio/io_context.hpp"
 
 // Helper function to initialize the parser manager
-bybit::ParserManager InitParserManager(
-    common::TradingPairHashMap& pairs,
-    common::TradingPairReverseHashMap& pair_reverse,
-    bybit::ApiResponseParser& api_response_parser,
-    bybit::detail::FamilyBookEventGetter::ParserResponse& parser_ob_diff) {
-    bybit::ParserManager parser_manager;
 
-    parser_manager.RegisterHandler(ResponseType::kNonQueryResponse,
-        [&api_response_parser](simdjson::ondemand::document& doc) {
-            return api_response_parser.Parse(doc);
-        });
-
-    parser_manager.RegisterHandler(ResponseType::kDepthUpdate,
-        [&parser_ob_diff](simdjson::ondemand::document& doc) {
-            return std::get<Exchange::BookDiffSnapshot>(parser_ob_diff.Parse(doc));  // Ensure it returns BookDiffSnapshot
-        });
-
-    parser_manager.RegisterHandler(ResponseType::kSnapshot,
-        [&parser_ob_diff](simdjson::ondemand::document& doc) {
-            return std::get<Exchange::BookSnapshot>(parser_ob_diff.Parse(doc));  // Ensure it returns BookSnapshot
-        });
-
-    return parser_manager;
-}
 
 // Google Test Fixture for the BookEventGetterComponent test
 class BookEventGetterComponentTest : public ::testing::Test {
@@ -103,7 +80,7 @@ class BookEventGetterComponentTest : public ::testing::Test {
                                                                                         &request_accepted_by_exchange,
                                                                                         &parser_manager](boost::beast::flat_buffer& fb) {
                                                                     auto response = std::string_view(static_cast<const char*>(fb.data().data()), fb.size());
-                                                                    std::cout << response << std::endl;
+                                                                    //std::cout << response << std::endl;
                                                                     auto answer = parser_manager.Parse(response);
 
                                                                     if (std::holds_alternative<Exchange::BookSnapshot>(answer) ||
